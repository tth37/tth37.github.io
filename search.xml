<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法学习-概率与数学期望]]></title>
    <url>%2F2019%2F08%2F19%2Falgorithm-expectation%2F</url>
    <content type="text"><![CDATA[太困了 写不动了 先占个坑qwq]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>期望</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2279消防局的设立]]></title>
    <url>%2F2019%2F08%2F19%2Fsolution-luogu-p2279%2F</url>
    <content type="text"><![CDATA[题目链接 咕 实际上就是这道题的简化版。 首先定义状态。$f[u][4]$ 表示节点 $u$ 的二级祖先（父亲的父亲）及以下节点被完全覆盖，所需的最小代价。$f[u][3]$ 表示节点 $u$ 的一级祖先及以下节点被完全覆盖所需最小代价。以此类推， $f[u][0]$ 表示节点 $u$ 的二级儿子（儿子的儿子）及以下节点被完全覆盖所需的最小代价。 考虑 $f[u][4]$ 的推导。由于每个节点被选中后只能覆盖到与其距离小于等于二的节点，要使 $u$ 的二级祖先被覆盖到，则节点 $u$ 必须被选取。对节点 $u$ 的各个儿子没有要求。因此，$f[u][4]=1+\Sigma f[v][0…4]$ 。 考虑 $f[u][3]$。由于只需要覆盖到节点 $u$ 的父亲，只需使节点 $u$ 的至少一个子节点可以覆盖到其二级祖先即可。同时，该子节点在覆盖到节点 $u$ 的二级祖先时，可以同时覆盖到节点 $u$ 的其他儿子，因此节点 $u$ 的其他儿子不必被覆盖。$f[u][3]=f[k][4]+\Sigma f[v][1…4]$。 $f[u][2]$ 的情况与 $f[u][3]$ 类似，只需保证一个儿子能将节点 $u$ 覆盖即可。 $f[u][2]=f[k][3]+\Sigma f[v][2…4]$ 。 $f[u][1]$ 与 $f[u][0]$ 的推导相对简单，因为各个子节点之间不会相互影响。 $f[u][1]=\Sigma f[v][2…4]$，$f[u][0]=\Sigma f[v][1…4]$。 对转移方程进行简单优化即可。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; G[1005];int N;int f[1005][10];void dp(int u, int fa) &#123; f[u][3] = 0x3f3f3f3f; f[u][2] = 0x3f3f3f3f; f[u][4] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dp(v, u); f[u][0] += f[v][1]; f[u][1] += f[v][2]; f[u][2] = min(f[u][2], f[v][3] - f[v][2]); f[u][3] = min(f[u][3], f[v][4] - f[v][1]); f[u][4] += f[v][0]; &#125; f[u][2] += f[u][1]; f[u][3] += f[u][0]; f[u][3] = min(f[u][3], f[u][4]); f[u][2] = min(f[u][2], f[u][3]); f[u][1] = min(f[u][1], f[u][2]); f[u][0] = min(f[u][0], f[u][1]); &#125;int main() &#123; scanf("%d", &amp;N); for (register int u = 2; u &lt;= N; ++u) &#123; int v; scanf("%d", &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); printf("%d", f[1][2]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-Pólya计数与Burnside引理]]></title>
    <url>%2F2019%2F08%2F13%2Falgorithm-polya%2F</url>
    <content type="text"><![CDATA[概述如果题目中定义一种等价关系，满足等价关系的元素被看成同一类，只统计一次；这样的问题称为等价类计数问题。一般的等价类计数问题可以用 Burnside 引理或 Pólya定理解决。 模板置换置换实际上就是一一映射，$f$ 可以看成定义域和值域为 $\lbrace 1,2,3,…,n\rbrace$ 的函数，其中 $f(1)=a_1$， $f(2)=a_2$ 等等。 f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)函数复合如果 f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)且 g=\left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)是 $\lbrace 1,2,3,…,n\rbrace$ 的两个置换，则他们的复合按照先 $f$ 后 $g$ 的顺序放置得到一个新置换： g\circ f= \left(\begin{array}{cccc} 1&2&...&n \\\ a_1&a_2&...&a_n \\ \end{array}\right) \circ \left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)循环为了处理方便，常常把置换分解成循环的乘积，其中每个循环代表一些元素“循环移位”。比如 $(1,4,3)$ 这个循环表示 $1\rightarrow 4$，$4\rightarrow 3$，$3\rightarrow 1$。 易证任意置换都可以分解为循环乘积的形式。 例题 在 2*2 方格中涂黑白两色，方格允许旋转，有几种方法？ 假设不考虑方格允许旋转，则共有 16 种上色方案。本题中“旋转后相同”即为一个等价关系，有了等价关系，所有元素会被分为若干个等价类，我们需要统计的即为等价类的个数。 对于一个置换 $f$ ，若一个着色方案 $s$ 经过置换后不变，称 $s$ 为 $f$ 的不动点。将 $f$ 的不动点数目记为 $C(f)$，则可以证明等价类数目为置换群中所有 $C(f)$ 的平均值。此结论称为 Burnside 引理。 一般地，如果置换 $f$ 被分解为 $m(f)$ 个循环的乘积，那么每个循环内所有位置的颜色必须相同，假设涂 $k$ 种颜色，则有 $C(f)=k^{m(f)}$。带入 Burnside 引理的表达式之后得到 Pólya 定理：等价类的个数等于置换群种所有置换 $f$ 的 $k^{m(f)}$ 的平均数。 将 $t$ 种颜色的 $n$ 个小球排成一个环，允许旋转和翻转，有几种方法？ 首先考虑旋转置换。记置换 $f_i$ 为将环形顺时针旋转 $i$ 个单位长度。显然，$m(f_i)=gcd(i,n)$ 。 其次考虑翻转置换。当 $n$ 为奇数时，$|G|=n$，且 $m(f)=(n-1)/2+1$；当 $n$ 为偶数时，$|G|=n$，且 $m(f)=n/2+1$。 记： a=\Sigma_{i=0}^{n-1} t^{gcd(i,n)}\\ b=\begin{cases} t^{(n-1)/2+1} , n=2k+1\\ t^{n/2+1},n=2k \end{cases}最终答案 $ans=(a+b)/2n$。]]></content>
      <tags>
        <tag>数论</tag>
        <tag>群论</tag>
        <tag>Pólya计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-KMP模式匹配]]></title>
    <url>%2F2019%2F08%2F07%2Falgorithm-kmp%2F</url>
    <content type="text"><![CDATA[概述给定一个文本 $A$ 和一个字符串 $B$ ，我们可以利用 KMP 算法尝试找到并展示 $B$ 在 $A$ 中的所有出现（occurrence）。 模板预处理前缀函数预处理出字符串 $B$ 的前缀函数 $next$ 数组，其中 $next[i]$ 为既是子串 $B[1…i]$ 的前缀同时也是该子串的后缀的最长真前缀长度。一个字符串的真前缀是其前缀但不等于该字符串本身。根据定义， $next[1]=0$ 。 算法流程 在循环中以 $i=2$ 到 $i=n$的顺序计算前缀函数 $next[i]$ 的值。（$next[1]$ 被赋值为0） 为了计算当前的前缀函数值 $next[i]$，我们令变量 $j$ 表示右端点位于 $i-1$ 的最长匹配前后缀的长度。初始时 $j=next[i-1]$ 。 通过比较 $B[j+1]$ 和 $B[i]$ 来检查长度为 $j+1$ 的后缀是否同时也是一个前缀。如果二者相等，那么置 $next[i]=j+1$，否则减少 $j$ 至 $next[j]$ 并重复该过程。 如果 $j=0$ 并且仍没有任何一次匹配，则置 $next[i]=0$ 并移至下一个下标 $i+1$ 。 F.A.Q算法流程中的步骤三，为什么要将 $j$ 减少至 $next[j]$ ？ 考虑我们正在计算的 $next[i]$ 。我们要使 $k$ 最大化，并且保证 $B[1…k]$ 与 $B[i-k+1…i]$ 相等。将其拆成两部分看，我们需要在 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等的同时，保证 $B[k]=B[i]$ ，且 $k$ 取到最大值。 不难发现，如果只需要最大化 $k-1$ 使得 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等，我们可以很快得出答案。回顾一下前缀函数的定义即可发现，记 $j$ 为 $next[i-1]$，则此时的 $j$ 即为我们需要最大化的 $k-1$ 的值。如果这时又恰好满足 $B[j+1]=B[i]$ ，则我们需要最大化的 $k$ 即为 $j+1$ 。 然而此时如果不能满足 $B[j+1]=B[i]$ ，我们就只能考虑减小 $j$ 的值。在减小 $j$ 值的同时，我们要始终保证减小后的 $j’$ 满足 $B[1…j’]=B[j-j’+1…j]$ 。 结合上图不难看出，要使得 $B[1…j’]=B[i-j’…i-1]$，即保证 $B[1…j’]=B[j-j’+1…j]$ 。而 $j’$ 的确定也十分简单，再次结合前缀函数的定义可得， $j’$ 的取值应为 $next[j]$ 。 代码实现123456next[1] = 0;for (int i = 2, j = 0; i &lt;= M; ++i) &#123; while (j &gt; 0 &amp;&amp; B[i] != B[j + 1]) j = next[j]; if (B[i] == B[j + 1]) j++; next[i] = j;&#125; 在目标串中查找子串计算出 $f$ 数组，其中 $f[i]$ 为既是子串 $B[1…i]$ 的前缀同时也是子串 $A[1…i]$ 的后缀的最长前缀长度。（注意这里不一定是真前缀）在预处理前缀函数的过程中，相当于 $B$ 串与自己本身做了一次模式匹配，因此此处的算法流程与上一个操作十分类似。 算法流程 在循环中以 $i=1$ 到 $i=n$的顺序计算 $f[i]$ 的值。 为了计算当前的 $f[i]$ ，我们令变量 $j$ 表示右端点位于 $i-1$ 的最长匹配前后缀的长度。初始时 $j=f[i-1]$ 。 通过比较 $B[j+1]$ 和 $A[i]$ 来检查 $B$ 串中长度为 $j+1$ 的前缀是否也是 $A$ 串中长度为 $j+1$ 的后缀。如果二者相等，那么置 $f[i]=j+1$，否则减少 $j$ 至 $next[j-1]$ 并重复该过程。 如果 $j=0$ 并且仍没有任何一次匹配，则置 $f[i]=0$ 并移至下一个下标 $i+1$ 。 如果 $j=M$，即找到 $B$ 在 $A$ 中的一次出现。 代码实现123456for (int i = 1, j = 0; i &lt;= N; ++i) &#123; while (j &gt; 0 &amp;&amp; A[i] != B[j + 1]) j = next[j]; if (A[i] == B[j + 1]) j++; f[i] = p; // if (f[i] == M) do something... &#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF游记-Codeforces Round]]></title>
    <url>%2F2019%2F08%2F01%2Fcodeforces-1199%2F</url>
    <content type="text"><![CDATA[比赛链接 人生第二次觉得CF的题还是可做的。目前只弄了5道，剩下一题咕着。 #A City Day简单模拟，开心的话可以写个单调队列。 #B Water Lily初中数学题，勾股定理。 (x+H)^2=x^2+L^2 \\ x=(L^2-H^2)/2H#C MP3既然硬盘的大小是固定的，那么 $K$ 应该尽可能大。为了让 $K$ 尽可能大， $k$ 也要尽可能大。 所以： k=\lfloor(I*8)/n\rfloor \\ K=2^k把 $K$ 求出来之后，我们实际上只需保留 $K$ 种不同的数字，并使删除的数字最少。 根据题意，我们只能删除最大的或最小的数。考虑对 $a$ 数组离散化，并用 $b$ 数组记录每个数值出现的次数。保留下来的数值一定是连续的$K$个，只需在 $b$数组上进行前缀和预处理，枚举保留的 $K$ 个数值位置即可。 #D Welfare State非主流警告⚠ 观察到只有一次查询，所以我们可以针对每个位置，求出当前位置在经过 $q$ 次操作后的值并输出。 先来看两个结论： 可以忽略对当前位置的最后一次一号操作之前的所有操作。 管你之前被改成什么了，经过一次一号操作就得重新来过。 对于连续的几次二号操作，只需保留 $x$ 最大的那一次操作。 废话。 本题中二号操作是针对整体的，所以考虑开数组 $s$ 记录所有二号操作的后缀最大值。在针对每一位置进行计算时，只需将最后一次一号操作之前的操作删除后，与二号操作的后缀最大值比较即可得出答案。 #E Matching vs Independent Set#F Rectangle Painting 1超水的一道 F 题！ $f[x1][y1][x2][y2]$表示将一个矩形全部涂成白色的最小费用，状态转移考虑由两个子矩形合并或将一整块上色即可。]]></content>
      <categories>
        <category>CF游记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习-splay伸展树]]></title>
    <url>%2F2019%2F07%2F24%2Falgorithm-splay%2F</url>
    <content type="text"><![CDATA[本文部分内容转载自 OI Wiki Splay $L^AT_EX$就先咕着吧……有时间慢慢搞 概述Splay是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，它由 Daniel Sleator 和 Robert Tarjan 发明。 结构节点维护信息 root 根节点编号 cnt 节点个数 node[] 节点内部信息 fa 父亲 ch[0/1] 左右儿子编号 val 节点权值 cnt 权值出现次数 sum 子树大小 1234struct Node &#123; int fa, ch[2], val, cnt, sum;&#125;node[MAXN];int root, cnt; 基本操作 update(u) 在改变节点位置后，将节点u的sum值更新 identify(u) 判断节点u是父亲的左儿子还是右儿子 clear(u) 销毁节点u 123456789void update(int u) &#123; node[u].sum = node[u].cnt + node[node[u].ch[0]].sum + node[node[u].ch[1]].sum;&#125;bool identify(int u) &#123; return u == node[node[u].fa].ch[1];&#125;void clear(int u) &#123; node[u].fa = node[u].ch[0] = node[u].ch[1] = node[u].val = node[u].cnt = node[u].sum = 0;&#125; 连接操作 connect(u, f, p) 将u连接在f的下方，连接方向为p 1234void connect(int u, int f, int p) &#123; node[u].fa = f; node[f].ch[p] = u;&#125; 旋转操作分析咕咕咕 1234567891011void rotate(int x) &#123; int y = node[x].fa; int r = node[y].fa; int rp = identify(y); int yp = identify(x); int b = node[x].ch[yp ^ 1]; connect(b, y, yp); connect(y, x, yp ^ 1); connect(x, r, rp); update(y), update(x);&#125; 旋转需要保证： 平衡树的中序遍历不变（不能破坏BST的性质） 受影响的节点维护的信息依然正确有效 root必须指向旋转后的根节点 具体分析旋转步骤（假设需要旋转的节点为x，其父亲为y，以右旋为例）： 将y的左儿子指向x的右儿子，且x的右儿子的父亲指向y 将x的右儿子指向y，且y的父亲指向x 如果原来的y还有父亲z，那么把z的某个儿子（原来y所在的儿子位置）指向x，且x的父亲指向z 1234567891011void rotate(int x) &#123; int y = node[x].fa, z = node[y].fa, p = identify(x); node[y].ch[p] = node[x].ch[p ^ 1]; node[node[x].ch[p ^ 1]].fa = y; node[x].ch[p ^ 1] = y; node[y].fa = x; node[x].fa = z; if (z) node[z].ch[y == node[z].ch[1]] = x; update(y); update(x);&#125; Splay 操作Splay规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为6种情况讨论（其中x为需要旋转到根的节点） 分析咕咕咕 12345void splay(int x) &#123; for (int f = node[x].fa; f = node[x].fa, f; rotate(x)) if (node[f].fa &amp;&amp; identify(x) == identify(f)) rotate(f); root = x;&#125; 插入操作分析咕咕咕 123456789101112131415161718192021222324252627282930void insert(int val) &#123; if (root == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; root = cnt; update(root); return; &#125; int cur = root, f = 0; while (1) &#123; if (node[cur].val == val) &#123; node[cur].cnt++; update(cur); update(f); splay(cur); break; &#125; f = cur, cur = node[cur].ch[node[cur].val &lt; k]; if (cur == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; node[cnt].fa = f; node[f].ch[node[f].val &lt; k] = cnt; update(cnt); update(f); splay(cnt); break; &#125; &#125;&#125; 查询x的排名分析咕咕咕 123456789101112131415int queryid(int val) &#123; int ans = 0, cur = root; while (1) &#123; if (val &lt; node[cur].val) cur = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].sum; if (val == node[cur].val) &#123; splay(cur); return ans + 1; &#125; ans += node[cur].cnt; cur = node[cur].ch[1]; &#125; &#125;&#125; 查询排名为k的数分析咕咕咕 1234567891011int queryrid(int k) &#123; int cur = root; while (1) &#123; if (node[cur].ch[0] &amp;&amp; k &lt;= node[node[cur].ch[0]].sum) cur = node[cur].ch[0]; else &#123; k -= node[cur].cnt + node[node[cur].ch[0]].sum; if (k &lt;= 0) return node[cur].val; cur = node[cur].ch[1]; &#125; &#125;&#125; 查询前驱分析古古古 1234567int querypre(int val) &#123; insert(val); int cur = node[root].ch[0]; while (node[cur].ch[1]) cur = node[cur].ch[1]; delet(val); return cur;&#125; 查询后继1234567int querynxt(int val) &#123; insert(val); int cur = node[root].ch[1]; while (node[cur].ch[0]) cur = node[cur].ch[0]; delet(val); return cur;&#125; 删除元素1234567891011121314151617181920212223242526272829303132void delet(int val) &#123; queryid(val); if (node[root].cnt &gt; 1) &#123; node[root].cnt--; update(root); return; &#125; if (node[root].ch[0] == 0 &amp;&amp; node[root].ch[1] == 0) &#123; clear(root); root = 0; return; &#125; if (node[root].ch[1] == 0) &#123; int cur = root; root = node[root].ch[0]; node[root].fa = 0; clear(cur); return; &#125; if (node[root].ch[0] == 0) &#123; int cur = root; root = node[root].ch[1]; node[root].fa = 0; clear(cur); return; &#125; int u = querypre(val), cur = root; // ??? node[node[cur].ch[1]].fa = u; node[u].ch[1] = node[cur].ch[1]; clear(cur); update(root);&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3275糖果]]></title>
    <url>%2F2019%2F07%2F23%2Fsolution-luogu-p3275%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个长度为$n$的序列以及$k$个条件，每个条件要求序列当中一个点的权值大于/小于/不大于/不小于/等于另一个点。求这个序列总和的最小值 $1 \le k,n \le 100000$ 感谢@oy 的贡献 差分约束系统的模板题。 记 $d$ 数组为以 $S$ 为源点到各个节点的最长路。根据最长路的性质，如果存在一条边 $(u,v,w)$ ，则一定满足以下不等式： d[u]+w(u,v)\le d[v]我们可以将题目中给出的不等关系转化为图中的有向边，然后通过单源最长路求出的一组 $\lbrace d_n\rbrace$ 即为差分约束系统的一组解。 因此，在图中连一条边 $(u,v,w)$ 相当于对 $d[u]$ 和 $d[v]$ 的取值作出限制，我们只需在构造出一张有向图，并求出其单源最长路即为答案。 有向边的构造方式如下： 限制 $d[A]=d[B]$ d[A]=d[B] \Leftrightarrow (d[B]\le d[A])\wedge(d[A]\le d[B]) \Leftrightarrow (d[B]+0\le d[A])\wedge(d[A]+0\le d[B])连边：$(A,B,0)$，$(B,A,0)$ 限制 $d[A]&lt;d[B]$ d[A]d[B]\Leftrightarrow d[B]+1\le d[A] 连边：$(B,A,1)$ 限制 $d[A]\le d[B]$ 连边：$(A,B,0)$ 限制 $d[i]&gt;0$ 连边：$(S,i,1)$ 连完所有的边后，跑一遍单源最长路；如果存在正环则输出无解。 统计答案时记得开$long$ $long$。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define die &#123;puts("-1"); exit(0);&#125;typedef long long ll;const int MAXN = 100005;struct Edge &#123; int v, w; Edge(int v, int w) &#123; this -&gt; v = v, this -&gt; w = w; &#125;&#125;;vector&lt;Edge&gt; G[MAXN];int N, K;bool inq[MAXN];int d[MAXN], cnt[MAXN];inline void AddEdge(int u, int v, int w) &#123; G[u].push_back(Edge(v, w));&#125;void SPFA() &#123; queue&lt;int&gt; q; q.push(N + 1); d[N + 1] = 0; inq[N + 1] = 1; while (q.size()) &#123; int u = q.front(); q.pop(); if (cnt[u] &gt;= N) die cnt[u]++; inq[u] = 0; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (d[u] + w &gt; d[v]) &#123; d[v] = d[u] + w; if (inq[v] == 0) &#123; inq[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= K; ++i) &#123; int X, A, B; scanf("%d%d%d", &amp;X, &amp;A, &amp;B); switch (X) &#123; case 1: AddEdge(A, B, 0); AddEdge(B, A, 0); break; case 2: if (A == B) die AddEdge(A, B, 1); break; case 3: AddEdge(B, A, 0); break; case 4: if (A == B) die AddEdge(B, A, 1); break; case 5: AddEdge(A, B, 0); break; &#125; &#125; for (register int i = 1; i &lt;= N; ++i) AddEdge(N + 1, i, 1); SPFA(); ll ans = 0; for (register int i = 1; i &lt;= N; ++i) ans += d[i]; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分约束系统</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4175网络管理]]></title>
    <url>%2F2019%2F07%2F21%2Fsolution-luogu-p4175%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵$n$个节点的树，进行$q$次操作：单点修改，或查询一条树链上的第$k$小值。 $n,q \le 80000,0 \le k \le n$ 感谢@oy的贡献 思路：树链剖分+树状数组套主席树 考虑到权值线段树自带buff——整体二分，不难想到对树链上的权值线段树求和，并在合并后的权值线段树上求第 $k$ 大即可愉快地解决本题。 在树链上的求和操作可以用树剖加线性数据结构进行维护。本题需要支持的操作只有单点修改和区间查询，所以可以用树状数组套主席树维护 dfs 序上的信息。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lson(x) (node[x].l)#define rson(x) (node[x].r)#define sum(x) (node[x].sum)#define lowbit(x) (x &amp; (-x))const int MAXN = 80005 * 2;vector&lt;int&gt; G[MAXN];struct opt &#123;int k, a, b;&#125; op[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125; node[MAXN * 80];int c[MAXN], cnt;int N, Q, L;int t[MAXN], b[MAXN];int q1[MAXN], q2[MAXN], len1, len2;int dep[MAXN], dfn[MAXN], f[MAXN], son[MAXN], top[MAXN], size[MAXN], dfn_idx;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; sum(u) += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(lson(u), l, mid, p, val); else insert(rson(u), mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void dfs1(int u, int fa) &#123; dep[u] = dep[fa] + 1; f[u] = fa; size[u] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); if (size[v] &gt; size[son[u]]) son[u] = v; size[u] += size[v]; &#125;&#125;void dfs2(int u, int topc) &#123; dfn[u] = ++dfn_idx; top[u] = topc; modify(dfn[u], t[u], 1); if (son[u]) dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == son[u] || v == f[u]) continue; dfs2(v, v); &#125;&#125;void pre_bin(int u, int* a, int&amp; len) &#123; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int pre(int u, int v) &#123; len1 = len2 = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[top[u]] - 1, q2, len2); u = f[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[v] - 1, q2, len2); return v;&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, rsum = 0; for (int i = 1; i &lt;= len1; ++i) rsum += sum(rson(q1[i])); for (int i = 1; i &lt;= len2; ++i) rsum -= sum(rson(q2[i])); if (k &lt;= rsum) &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = rson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = rson(q2[i]); return query(mid + 1, r, k); &#125; else &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = lson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = lson(q2[i]); return query(l, mid, k - rsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;Q); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;t[i]), b[++L] = t[i], c[i] = ++cnt; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (register int i = 1; i &lt;= Q; ++i) &#123; scanf("%d%d%d", &amp;op[i].k, &amp;op[i].a, &amp;op[i].b); if (op[i].k == 0) b[++L] = op[i].b; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) t[i] = id(t[i]); dfs1(1, 0); dfs2(1, 1); for (register int i = 1; i &lt;= Q; ++i) &#123; int k = op[i].k, a = op[i].a, b_ = op[i].b; if (k == 0) &#123; b_ = id(b_); modify(dfn[a], t[a], -1); t[a] = b_; modify(dfn[a], t[a], 1); &#125; else &#123; int lca = pre(a, b_); int maxk = dep[a] + dep[b_] - dep[lca] * 2 + 1; if (maxk &lt; k) &#123; puts("invalid request!"); continue; &#125; printf("%d\n", rid(query(1, L, k))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树链剖分</tag>
        <tag>树状数组</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-树套树]]></title>
    <url>%2F2019%2F07%2F21%2Falgorithm-treeintree%2F</url>
    <content type="text"><![CDATA[本文部分内容转载自 OI Wiki 树状数组套主席树 概述普通数据结构维护单一维度信息，树套树维护多维度信息。 树状数组套权值线段树树状数组套权值线段树可以在 $O(n \log^2 n)$ 的时间复杂度解决动态区间 $k$ 小值问题。 如果用线段树套平衡树中所论述的，用线段树套平衡树，即对于线段树的每一个节点，对于其所表示的区间维护一个平衡树，然后用二分来查找 $k$ 小值。由于每次查询操作都要覆盖多个区间，即有多个节点，但是平衡树并不能多个值一起查找，所以时间复杂度是 $O(n\log^3 n)$，并不是最优的。 思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 线段树套主席树 。 说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为 动态开点权值线段树 更为确切。 思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。 在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过 $O(\log n)$ 个线段树上的节点，在动态开点权值线段树上一次修改操作是 $O(\log n)$ 的，所以修改操作的时间复杂度为 $O(\log^2 n)$ 。 由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 树状数组 实现。 给出一种代码实现：luogu-p2617 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lowbit(x) (x &amp; (-x))const int MAXN = 100005 * 2;struct op &#123; char opt; int i, j, k, t;&#125;ops[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125;node[MAXN * 80];int cnt, c[MAXN];int N, M, L;int a[MAXN], b[MAXN];int qr[MAXN], ql[MAXN], qrlen, qllen;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; node[u].sum += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(node[u].l, l, mid, p, val); else insert(node[u].r, mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void pre(int u, int* a, int&amp; len) &#123; len = 0; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, lsum = 0; for (int i = 1; i &lt;= qrlen; ++i) lsum += node[node[qr[i]].l].sum; for (int i = 1; i &lt;= qllen; ++i) lsum -= node[node[ql[i]].l].sum; if (lsum &gt;= k) &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].l; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].l; return query(l, mid, k); &#125; else &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].r; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].r; return query(mid + 1, r, k - lsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%d", &amp;a[i]), b[++L] = a[i], c[i] = ++cnt; &#125; for (register int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; ops[i].opt; if (ops[i].opt == 'Q') &#123; scanf("%d%d%d", &amp;ops[i].i, &amp;ops[i].j, &amp;ops[i].k); &#125; else &#123; scanf("%d%d", &amp;ops[i].i, &amp;ops[i].t); b[++L] = ops[i].t; &#125; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) &#123; a[i] = id(a[i]); modify(i, a[i], 1); &#125; for (register int i = 1; i &lt;= M; ++i) &#123; if (ops[i].opt == 'Q') &#123; pre(ops[i].j, qr, qrlen); pre(ops[i].i - 1, ql, qllen); printf("%d\n", rid(query(1, L, ops[i].k))); &#125; else &#123; modify(ops[i].i, a[ops[i].i], -1); a[ops[i].i] = id(ops[i].t); modify(ops[i].i, a[ops[i].i], 1); &#125; &#125; return 0;&#125; 未完待续……等我学完平衡树再接着弄]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-cf1195c Basketball Exercise]]></title>
    <url>%2F2019%2F07%2F18%2Fsolution-luogu-cf1195c%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个$2*n$的矩阵，从中选出若干数，且任意两个数不上下或左右相邻，求这些数的最大总和 $1\le n \le 100000,1 \le h_{i,j}\le 1000000000$ 很水的一道C题……目测难度在黄~绿左右。请各位切题者合理评分。 注意到可以选择的球员编号是严格递增的，因此可以把状态的第一维定义为球员编号，第二维描述编号同为 $i$ 的两名球员的选取情况。 定义状态：$f[i][0/1/2]$ 表示选取了编号在 $i$ 及以前的球员，所能得到的身高总和最大值。其中，第二维的 $0$ 表示编号为 $i$ 的球员一个都不选；$1$ 表示只选上面一个；$i$ 表示只选下面一个。（显然没有上下都选的情况） 状态转移方程： f[i][0]=max\lbrace f[i-1][0],f[i-1][1],f[i-1][2]\rbrace f[i][1]=max\lbrace f[i-1][0],f[i-1][2]\rbrace+height[i][1] f[i][2]=max\lbrace f[i-1][0],f[i-1][1]\rbrace+height[i][2]Update: 用贪心可以证明，在最优解中，不会出现连续两列一个不取的情况。因此， $f[i][0]$ 其实没有必要考虑来自 $f[i-1][0]$ 的状态转移。 代码如下：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;ll h[100005][3];ll f[100005][3];int main() &#123; cin &gt;&gt; N; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][1]; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][2]; f[1][0] = 0; f[1][1] = h[1][1]; f[1][2] = h[1][2]; for (register int i = 2; i &lt;= N; ++i) &#123; f[i][0] = max(f[i - 1][0], max(f[i - 1][1], f[i - 1][2])); f[i][1] = max(f[i - 1][0], f[i - 1][2]) + h[i][1]; f[i][2] = max(f[i - 1][0], f[i - 1][1]) + h[i][2]; &#125; cout &lt;&lt; max(f[N][0], max(f[N][1], f[N][2])); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-卡特兰数]]></title>
    <url>%2F2019%2F07%2F14%2Falgorithm-maths-catalan%2F</url>
    <content type="text"><![CDATA[咕咕咕~]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1641生成字符串]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p1641%2F</url>
    <content type="text"><![CDATA[题目链接 将$n$个$1$和$m$个$0$组成字符串，使得在任意的前$k$个字符中，$1$的个数不能少于$0$的个数。求满足条件的字符串共有多少个。 $1\le m \le n \le 1000000$ 本题是卡特兰数的一个简单变式。 回忆卡特兰数的推导过程，可以生成的所有字符串共有$C_{n+m}^n$个，其中不合法的字符串有$C_{n+m}^{n+1}$个。最终答案即为$C_{n+m}^{n}-C_{n+m}^{n+1}$。计算组合数前须预处理出阶乘逆元。 代码如下： 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int p = 20100403;int N, M;int inv[2000005], fac[2000005], facinv[2000005];int C(int n, int m) &#123; return (ll) fac[n] * facinv[m] % p * facinv[n - m] % p;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; inv[1] = 1; fac[0] = fac[1] = 1; facinv[1] = 1; for (register int i = 2; i &lt;= N + M; ++i) &#123; inv[i] = (ll) (p - p / i) * inv[p % i] % p; fac[i] = (ll) i * fac[i - 1] % p; facinv[i] = (ll) facinv[i - 1] * inv[i] % p; &#125; cout &lt;&lt; (C(N + M, N) - C(N + M, N + 1) + p) % p; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>卡特兰数</tag>
        <tag>逆元</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-乘法逆元]]></title>
    <url>%2F2019%2F07%2F13%2Falgorithm-maths-multiplicativeinversion%2F</url>
    <content type="text"><![CDATA[概述 乘法逆元定义：如果一个线性同余方程$ax\equiv 1 \mod b$，则$x$成为$a \mod b$的逆元，记作$a^{-1}$。 乘法逆元一般用于求$a\/b\mod p$的值（$p$通常为质数），是解决模意义下分数数值的必要手段。 对于$a\/b\mod p$，我们可以求出$b$在$\mod p$下的逆元，然后乘上$a$再$\mod p$，就是这个分数的值了。 求解逆元的方法扩展欧几里得法求解$ax\equiv 1 \mod b$ 等价于解不定方程 $ax+by=1$，求解出的$x$即为$a \mod b$的逆元。 12345678void exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125; 快速幂法 费马小定理 若$p$为质数，$a$为正整数，且$a$、$p$互质，则$a^{p-1}\equiv 1 (\mod p)$。 因为$ax\equiv 1\mod b$ 所以$ax\equiv a^{b-1}\mod b$ 所以$x\equiv a^{b-2}\mod b$ 然后可以使用快速幂求解逆元。 代码略。 线性求逆元假设现在要求$inv[i]$。 考虑带余除法，设$p=iq+r$，则有$iq+r\equiv 0\mod p$ 注意到$p$是质数，因此$r$不为$0$，$r$的逆元存在 等式两边乘$i^{-1}r^{-1}$，得到$qr^{-1}+i^{-1}\equiv 0\mod p$ 因此$i^{-1}\equiv -qr^{-1}\equiv -(p\/i)(p \mod i)^{-1}\mod p$ 12for (inv[1] = 1, i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p;]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5021赛道修建]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p5021%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个有$n$个节点的树，在其中选出$m$条没有公共边的路径，并使得$m$条路径中最短路径的长度尽可能大。输出这个最短路径的长度。 $2\le n \le 50000,1\le m\le n-1 $ 题目要求使$m$条赛道中最短赛道的长度尽可能大，不难想到二分最短赛道的长度$len$，并判定是否能修建出$m$条赛道。 定义$f[u]$为自节点$u$向下延伸的不作为赛道的最长链长度。假设已知所有的$f[v]+w(u,v) (v\in son(u))$（即自节点$u$向下延伸的所有链的长度），则我们应在保证这些链能组成最多赛道的前提下，使保留下来的$f[v]+w(u,v)$最大。 考虑贪心。对于$f[v]+w(u,v)\ge len$的情况，可以直接将其作为一条赛道。而剩余的链，只能将它们两两拼接成赛道。由于需要使保留下来的$f[v]+w(u,v)$取最大值，所以我们可以优先使较短的链得到匹配，在剩余的无法匹配的链中取最值作为新的$f[u]$。 贪心操作可以用$multiset$实现。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50005;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G[MAXN];int N, M, L, cnt;int f[MAXN];inline bool cmp(int a, int b) &#123;return a &gt; b;&#125;inline void dfs(int u, int fa) &#123; multiset&lt;int&gt; s; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (v == fa) continue; dfs(v, u); if (f[v] + w &gt;= L) cnt++; else s.insert(f[v] + w); &#125; while (!s.empty()) &#123; multiset&lt;int&gt;::iterator it = s.begin(); s.erase(it); multiset&lt;int&gt;::iterator it1 = s.lower_bound(L - *it); if (it1 == s.end()) f[u] = max(f[u], *it); else &#123; cnt++; s.erase(it1); &#125; &#125;&#125;inline bool check() &#123; memset(f, 0, sizeof(f)); cnt = 0; dfs(1, 0); if (cnt &gt;= M) return 1; return 0;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G[u].push_back((Edge)&#123;v, w&#125;); G[v].push_back((Edge)&#123;u, w&#125;); &#125; int l = 0, r = 500000000; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; L = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-树链剖分]]></title>
    <url>%2F2019%2F07%2F04%2Falgorithm-treechainsectioning%2F</url>
    <content type="text"><![CDATA[概述树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。 具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。 模板【实现过程】 第一个 DFS 记录每个结点的深度（deep）、子树大小（size）。 第二个 DFS 记录每个结点的重子结点（heavy-son）、重边优先遍历时的 DFN 序、所在链的链顶（top，且应初始化为结点本身）。 链上的 DFN 序是连续的，可以使用线段树，树状数组维护。 每次选择深度较大的链往上跳，直到两点在同一条链上。 在 DFS 搜索的时候，子树中的结点的 DFN 序是连续的。 每一个结点记录 bottom 表示所在子树连续区间末端的结点。 这样就把子树信息转化为连续的一段区间信息。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100005;vector&lt;int&gt; G[MAXN];int N, M, R, P;int w[MAXN], fa[MAXN], size[MAXN], son[MAXN], top[MAXN], dep[MAXN];int dfn[MAXN], dfn_index;struct Node &#123; int l, r, sum, tag;&#125;node[MAXN * 2];int cnt;int a[MAXN];inline void build(Node&amp; u, int l, int r) &#123; u.tag = 0; if (l == r) &#123; u.sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r); u.sum = (node[u.l].sum + node[u.r].sum);&#125;inline void pushdown(Node&amp; u, int l, int r) &#123; if (u.tag) &#123; int mid = (l + r) &gt;&gt; 1; node[u.l].sum = (node[u.l].sum + u.tag * (mid - l + 1)); node[u.r].sum = (node[u.r].sum + u.tag * (r - mid)); node[u.l].tag = (node[u.l].tag + u.tag); node[u.r].tag = (node[u.r].tag + u.tag); u.tag = 0; &#125;&#125;inline void modify(Node&amp; u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; u.tag = (u.tag + val) % P; u.sum = (u.sum + val * (r - l + 1)) % P; return; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify(node[u.l], l, mid, ql, qr, val); if (mid &lt; qr) modify(node[u.r], mid + 1, r, ql, qr, val); u.sum = (node[u.l].sum + node[u.r].sum) % P;&#125;inline int query(Node&amp; u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return u.sum; &#125; int mid = (l + r) &gt;&gt; 1, ans = 0; pushdown(u, l, r); if (ql &lt;= mid) ans = (ans + query(node[u.l], l, mid, ql, qr)) % P; if (mid &lt; qr) ans = (ans + query(node[u.r], mid + 1, r, ql, qr)) % P; return ans;&#125;inline void dfs1(int u, int fath) &#123; size[u] = 1; fa[u] = fath; dep[u] = dep[fath] + 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fath) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;inline void dfs2(int u, int topc) &#123; top[u] = topc; dfn[u] = ++dfn_index; a[dfn[u]] = w[u]; if (son[u] == 0) return; dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;inline void ModifySubtree(int u, int val) &#123; modify(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1, val);&#125;inline int QuerySubtree(int u) &#123; return query(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1);&#125;inline void ModifyChain(int u, int v, int val) &#123; val %= P; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); modify(node[0], 1, N, dfn[top[u]], dfn[u], val); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); modify(node[0], 1, N, dfn[v], dfn[u], val);&#125;inline int QueryChain(int u, int v) &#123; int ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[top[u]], dfn[u])) % P; u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[v], dfn[u])) % P; return ans;&#125;int main() &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;R, &amp;P); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;w[i]); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(R, 0); dfs2(R, R); build(node[0], 1, N); for (register int i = 1; i &lt;= M; ++i) &#123; int opt, x, y, z; scanf("%d", &amp;opt); if (opt == 1) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); ModifyChain(x, y, z); &#125; if (opt == 2) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", QueryChain(x, y)); &#125; if (opt == 3) &#123; scanf("%d%d", &amp;x, &amp;z); ModifySubtree(x, z); &#125; if (opt == 4) &#123; scanf("%d", &amp;x); printf("%d\n", QuerySubtree(x)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2831愤怒的小鸟]]></title>
    <url>%2F2019%2F07%2F03%2Fsolution-luogu-p2831%2F</url>
    <content type="text"><![CDATA[题目链接 在平面直角坐标系中给定$n$个位于第一象限的点，求至少需要从原点引出多少条开口向下的抛物线，使它们经过所有的点。 $ 1 \le n \le 18 $ 感谢@oy的贡献 一道并不是特别难的状压dp。 状态定义：$f[s]$表示将所有剩余的猪消灭至少需要多少只小鸟，其中$s$表示已经消灭的猪的集合。 考虑状态转移，发射一个小鸟可以消灭尚未被消灭的猪。记$curve[i][j]$为一个二进制集合，表示经过第$i$、$j$号猪的抛物线能消灭哪些猪。 即： f[s]=min\lbrace f[s|curve[i][j]]+1\rbrace可以用记忆化搜索实现，注意精度控制和触摸状态。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-7;int T;int N, M;double x[19], y[19];int curve[19][19];int f[524289];inline void equals(double&amp; a, double&amp; b, double x1, double y1, double x2, double y2) &#123; a = (y1 * x2 - x1 * y2) / (x1 * x1 * x2 - x2 * x2 * x1); b = (y1 - x1 * x1 * a) / x1;&#125;inline int dp(int s) &#123; if (f[s] != -1) return f[s]; if (s == (1 &lt;&lt; N) - 1) return f[s] = 0; f[s] = INF; for (register int i = 1; i &lt;= N; ++i) &#123; for (register int j = i; j &lt;= N; ++j) &#123; f[s] = min(f[s], dp(s | curve[i][j]) + 1); &#125; &#125; return f[s];&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; memset(curve, 0, sizeof(curve)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%lf%lf", &amp;x[i], &amp;y[i]); for (register int p1 = 1; p1 &lt;= N; ++p1) &#123; for (register int p2 = p1 + 1; p2 &lt;= N; ++p2) &#123; double a, b; equals(a, b, x[p1], y[p1], x[p2], y[p2]); if (a &gt;= 0) continue; for (register int i = 1; i &lt;= N; ++i) &#123; if (x[i] * x[i] * a + x[i] * b &gt;= y[i] - EPS &amp;&amp; x[i] * x[i] * a + x[i] * b &lt;= y[i] + EPS) &#123; curve[p1][p2] |= (1 &lt;&lt; (i - 1)); curve[p2][p1] |= (1 &lt;&lt; (i - 1)); &#125; &#125; &#125; &#125; for (register int p = 1; p &lt;= N; ++p) curve[p][p] = (1 &lt;&lt; (p - 1)); memset(f, -1, sizeof(f)); printf("%d\n", dp(0)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3959宝藏]]></title>
    <url>%2F2019%2F06%2F30%2Fsolution-luogu-p3959%2F</url>
    <content type="text"><![CDATA[题目链接 输入一个有$n$个点$m$条边的有权无向图。选定任意节点作为根节点。构造一棵生成树，使得树上所有真实边权的总和最小。真实边权的计算公式：$w(u,v)\times L$，其中$L$为根节点到$u$路径上的节点总数。 $1\le n \le 12,1 \le m \le 1000$ 感谢@oy的贡献 这道题做了很长时间，从一开始推出错误的状态转移方程，到埋头优化正确的状态转移，前后花了一个多星期…… 本题题解可以保证正确性（当然欢迎Hack），却在速度上略有欠缺。 状态定义：$f[s][u][d]$ $s$表示当前已联通的点集，$u$表示当前点集生成树的树根，$d$表示$u$到起点的距离。（注意：$u$不是起点） 状态转移：状态肯定是通过挖通道来转移的。如果将$u$和$v$之间挖通，则$u$所在的连通块和$v$所在的连通块将会合并。如果以$u$作为根，$u$到起点的距离为$d$，则$v$到起点的距离为$(d+1)$。方程如下： f[s][u][d]=min\lbrace f[s1][u][d]+f[s2][v][d+1]+w(u,v)*d\rbrace其中： s1 \cup s2=s,u\in s1,v\in s2,w(u,v)\not= \inf最终要求的答案即为$\min_{1\le i \le n}f[(1&lt;&lt;n)-1][i][1]$，采用记忆化搜索实现。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int N, M;int w[13][13];int f[1&lt;&lt;13][13][13];inline int dp(int s, int u, int d) &#123; if (f[s][u][d] != -1) return f[s][u][d]; if (s == (1 &lt;&lt; (u - 1))) return f[s][u][d] = 0; int&amp; ans = f[s][u][d] = INF; for (register int s1 = s; s1; s1 = (s1 - 1) &amp; s) &#123; if (!(s1 &amp; (1 &lt;&lt; (u - 1)))) continue; for (register int v = 1; v &lt;= N; ++v) &#123; if (!(s &amp; (1 &lt;&lt; (v - 1)))) continue; if (w[u][v] == INF) continue; int s2 = s ^ s1; ans = min(ans, dp(s1, u, d) + dp(s2, v, d + 1) + w[u][v] * d); &#125; &#125; return ans;&#125;int main() &#123; memset(w, 0x3f, sizeof(w)); memset(f, -1, sizeof(f)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, t; scanf("%d%d%d", &amp;u, &amp;v, &amp;t); w[u][v] = w[v][u] = min(w[u][v], t); &#125; int ans = INF; for (register int u = 1; u &lt;= N; ++u) &#123; ans = min(ans, dp((1 &lt;&lt; N) - 1, u, 1)); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-6-20]]></title>
    <url>%2F2019%2F06%2F20%2Fbulletin-2019-6-20%2F</url>
    <content type="text"><![CDATA[招募启事tth37最近发现，他写了好多好多题解啦。但是这些题解全都被展示在Homepage里，导致Homepage不够简洁，题目检索不太方便。 于是，tth37决定在每篇题解最前面，写一段题目内容的一句话总结。但是tth37比较忙，实在不想做这件事，因此他决定招募跪求巨佬来帮他完成这项工作。 一份完整的一句话总结必须清楚地概括题面（拒绝花里胡哨），并且给出数据范围。一切字母必须采用$L^AT_EX$公式。（百度一下？） 写好一句话总结后，请将其上传至洛谷剪贴板，并将剪贴板链接发给tth37。tth37会根据其质量，酌情发送0.01~0.66元红包作为报酬。 如果在座的各位对本活动反响不够热烈，tth37可能会强迫你们当中的一些人完成这项任务。当然，没有报酬。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3953逛公园]]></title>
    <url>%2F2019%2F06%2F19%2Fsolution-luogu-p3953%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个$n$个点$m$条边的有向带权图，设起点到终点的最短路为$d$，求起点到终点满足权值总和小于等于$(d+k)$的路径数量 $1 \le p\le 10^9 $ , $1 \le n\le 10^5$ , $1 \le m\le 2 \times 10^5$ , $1 \le k\le 50$ 感谢@oy 的贡献 一道看似图论实则可以用动态规划解决的题目。 朴素的状态定义：$f[u][k]$表示从$1$号节点走到$u$号节点，路径长度为$k$的方案总数。状态转移方程： f[u][k]=\sum_{(u,v)\in E}f[v][k-w(u,v)]但是这样的状态定义有一个严重的问题：空间消耗过大。考虑到题目中给出的$K$值并不大，我们可以利用题目所要求的信息来优化状态设计。 优化后的状态定义：$d[u]$表示从$1$号节点走到$u$号节点的最短路长度，$f[u][k]$表示从$1$号节点走到$u$号节点，路径长度为$d[u]+k$的方案总数。 如此一来，状态所需的空间大大减少，但相应的状态转移略显复杂。不妨设$f[u][k]$状态可以由$f[v][x]$转移得到，则： d[v]+x+w(u,v)=d[u]+k移项，得到： x=d[u]-d[v]+k-w(u,v)因此，完整的状态转移方程如下： f[u][k]=\sum_{(u,v)\in E}f[v][d[u]-d[v]+k-w(u,v)]我们最终要求的答案即为$\sum_{i=0}^Kf[N][i]$，用记忆化搜索实现即可。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100001;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G1[MAXN], G2[MAXN];int T, N, M, K, P;bool fail;int f[MAXN][51];int d[MAXN];bool vis[MAXN];bool ins[MAXN][51];void Dijkstra() &#123; memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(0, 1)); d[1] = 0; while (q.size()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (vector&lt;Edge&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123; int v = it-&gt;v, w = it-&gt;w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; q.push(make_pair(-d[v], v)); &#125; &#125; &#125;&#125;inline int dp(int u, int k) &#123; if (k &lt; 0) return 0; if (ins[u][k])&#123; fail = 1; return 0; &#125; if (f[u][k]) return f[u][k]; ins[u][k] = 1; int ans = 0; for (vector&lt;Edge&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123; int p = it-&gt;v, w = it-&gt;w; ans = (ans + dp(p, d[u] - d[p] + k - w))%P; if (fail == 1) return 0; &#125; ins[u][k] = 0; return f[u][k] = ans;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;K, &amp;P); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G1[u].push_back((Edge)&#123;v, w&#125;); G2[v].push_back((Edge)&#123;u, w&#125;); &#125; Dijkstra(); dp(1, 0); f[1][0] = 1; int ans = 0; for (register int i = 0; i &lt;= K; ++i) &#123; ans = (ans + dp(N, i))%P; &#125; if(fail == 1) puts("-1"); else printf("%d\n", ans); fail = 0; memset(f, 0, sizeof(f)); memset(ins, 0, sizeof(ins)); for (register int i = 1; i &lt;= N; ++i) &#123; G1[i].clear(), G2[i].clear(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2627修剪草坪]]></title>
    <url>%2F2019%2F06%2F09%2Fsolution-luogu-p2627%2F</url>
    <content type="text"><![CDATA[题目链接 读入$n$个整数，选取其中若干个数，最多连续取$k$个，求取到数字和的最大值 $1\le k \le n \le 100000$ 感谢@oy 的贡献 一道单调队列入门题。 面对动规题，首先设计状态转移方程。令$f[i]$表示$1-i$中连取不超过$K$个数，且第$i$个数不取所能累加的最大和。 因为第$i$个数不取，所以在$i$之前一定连取了一段数。这段数的长度可能为$0-K$（注意是$0-K$而不是$1-K$，可以通过手推样例发现最优解中可能存在连着两个数不取的情况）。连取的一段数所能累加的和可以用前缀和计算。考虑边界条件后，状态转移方程如下： f[i]=\max_{i-K-1\le j \le i-1} \lbrace f[j]+s[i-1]-s[j] \rbrace由于$max$函数的循环变量是$j$，所以只与$i$相关的变量$s[i-1]$可以作为常数提出到$max$函数之外，即： f[i]=\max_{i-K-1\le j \le i-1}\lbrace f[j]-s[j]\rbrace +s[i-1]将状态转移方程化简到这样，就已经可以用单调队列进行优化了。我们可以用单调队列维护$f[j]-s[j]$的最值，在循环时将其最大值取出再加上$s[i-1]$即为$f[i]$。 如果想不到该如何操作，也可以这样理解： g[i]=f[i]-s[i] f[i]=\max_{i-K-1\le j \le i-1}\lbrace g[j]\rbrace+s[i-1]由于我们定义$f[i]$是第$i$个数不取的最优解，可以强行求解$f[N+1]$（虽然它似乎没有实际意义）作为本题的最终答案。 代码如下： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, K;ll s[100005], f[100005];int q[100005];int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%lld", &amp;s[i]); s[i] += s[i-1]; &#125; int l = 0, r = 1; q[0] = 0, f[0] = 0; for (register int i = 1; i &lt;= N + 1; ++i) &#123; while (l &lt; r &amp;&amp; q[l] &lt; i - K - 1) l++; f[i] = f[q[l]] - s[q[l]] + s[i-1]; while (l &lt; r &amp;&amp; f[q[r - 1]] - s[q[r - 1]] &lt; f[i] - s[i]) r--; q[r++] = i; &#125; printf("%lld", f[N + 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1600天天爱跑步(Beta)]]></title>
    <url>%2F2019%2F06%2F07%2Fsolution-luogu-p1600%2F</url>
    <content type="text"><![CDATA[题目链接 $n$个点的树上有$m$条路径$(S_i, T_i)$，每条路径上各有一个人从$S_i$跑到$T_i$。他们在第$0$时刻同时跑，每秒能跑一条边。回答$n$个询问，询问恰好在第$W_i$时刻到达节点$i$的人数。 $1 \le n \le 300000,1 \le m \le 300000 $ 感谢@tth37 的贡献 准备写一篇较为详细的题解。部分思路来自《算法竞赛进阶指南》。 游戏地图构成树形结构，为方便处理，可以取$1$号节点作为根，转化为有根树处理。 可以发现，从S到T的路径有且只有一条，并且必将经过$lca(S,T)$。 不妨设$x$节点上有一名观察员，其观察时间为$W[x]$。我们可以对$x$的位置进行分情况讨论。 $x$在$S$到$lca(S,T)$的路径上（该路径包含$lca(S,T)$）。 为方便说明，假设$S=6$，$T=4$。那么，此时$x$可能为$1$，$3$或$6$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=d[S]-d[x]$（$d$数组表示节点深度）。对上式移项，得到$W[x]+d[x]=d[S]$。 接下来，我们给每一个节点分配若干个权值，即在每一个节点上开一个一维数组，记录各个权值。根据上式，我们可以将$S$到$lca(S,T)$的路径上每一个节点的$d[S]$号权值加一。按照这种方式处理完所有玩家的信息之后，我们遍历所有节点，每个节点上的$(W[x]+d[x])$号权值即为所求。 该方法的正确性应该不难理解。$(W[x]+d[x])$号权值的意义即为该节点上满足前文所述等式的玩家个数，而满足等式意味着玩家将会在观察员探头时经过观察点，符合题意。 但是这种暴力方法显然还有优化的空间。在有根树的一条链上进行权值更改，可以尝试用树上差分的知识解决。在节点$S$上的$d[S]$号权值加一，节点$fa[lca(S,T)]$上的$d[S]$号权值减一（可以在每个节点上开一个不定长数组vector记录当前节点上的加减操作），最后进行统计时，计算当前子树所有$(W[x]+d[x])$号权值和即可。但即便如此，答案统计也并不容易实现；我们可以使用以下方法： 建立全局数组$s$，其中$s[i]$表示$i$号权值之和。深度优先遍历所有节点，在刚访问到当前节点时，记录$cnt=s[W[x]+d[x]]$。遍历当前节点上的vector，执行加减操作（例如：vector中的一项操作把$3$号权值减一，则$s[3]=s[3]-1$）。递归访问当前节点的所有子节点。访问结束后，$(s[W[x]+d[x]]-cnt)$即为所求。 结合dfs序的相关知识，访问完当前节点的所有子节点之后，$s$数组已经记录了以$x$为根的子树上所有操作。因此将访问后与访问前的权值相减，即为树上差分所得到的答案。 别忘了才分类讨论了一半呢…… $x$在$lca(S,T)$到$T$的路径上（该路径不包含$lca(S,T)$）。同样假设$S=6$，$T=4$。此时$x$可能为$2$或$4$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=(d[S]-d[lca(S,T)])+(d[x]-d[lca(S,T)])$。对上式移项，得到$W[x]-d[x]=d[S]-2*d[lca(S,T)]$。 类似地，我们只需将操作改为对$(d[S]-2*d[lca(S,T)])$号权值的操作即可。由于权值有可能为负，需要将序号整体平移$N$个单位，即改为对$(d[S]-2*d[lca(S,T)]+N)$号权值的操作。在每个节点上另开一个操作vector，统计答案时另开一个$s$数组，将计算出的答案与第一种情况的答案相加即可。 Q：为什么必须另开操作vector和$s$数组？ A：回顾一下提到的两个式子：$W[x]+d[x]=d[S]$，$W[x]-d[x]=d[S]-2*d[lca(S,T)]$如果将两者合起来操作，有可能产生“将$d[S]$号权值加一，碰巧统计答案时$W[x]-d[x]=d[S]$”的情况。然而，上述等式是没有任何意义的：$x$号节点根本无法观察到玩家。为了避免此类错误，必须将两种操作分开处理。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300005;struct opt &#123;int id, op;&#125;;vector&lt;int&gt; G[MAXN];vector&lt;opt&gt; opt1[MAXN], opt2[MAXN];int N, M;int W[MAXN];int f[MAXN][20], d[MAXN];void dfs1(int u, int fa) &#123; f[u][0] = fa, d[u] = d[fa] + 1; for (register int i = 1; i &lt;= 19; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (d[u] &lt; d[v]) swap(u, v); for (register int i = 19; i &gt;= 0; --i) &#123; if (d[f[u][i]] &gt;= d[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 19; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int s1[MAXN*3], s2[MAXN*3];int ans[MAXN];void dfs2(int u, int fa) &#123; int cnt1 = s1[W[u] + d[u] + N]; int cnt2 = s2[W[u] - d[u] + N]; for (vector&lt;opt&gt;::iterator it = opt1[u].begin(); it != opt1[u].end(); it++) s1[it-&gt;id] += it-&gt;op; for (vector&lt;opt&gt;::iterator it = opt2[u].begin(); it != opt2[u].end(); it++) s2[it-&gt;id] += it-&gt;op; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs2(v, u); &#125; ans[u] = s1[W[u] + d[u] + N] - cnt1 + s2[W[u] - d[u] + N] - cnt2;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(1, 0); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;W[i]); for (register int i = 1; i &lt;= M; ++i) &#123; int S, T; scanf("%d%d", &amp;S, &amp;T); int lca = Lca(S, T); opt1[S].push_back((opt)&#123;d[S] + N, 1&#125;); opt1[f[lca][0]].push_back((opt)&#123;d[S] + N, -1&#125;); opt2[T].push_back((opt)&#123;d[S] - 2*d[lca] + N, 1&#125;); opt2[lca].push_back((opt)&#123;d[S] - 2*d[lca] + N, -1&#125;); &#125; dfs2(1, 0); for (register int i = 1; i &lt;= N; ++i) printf("%d ", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2633 Count on a tree(COT)]]></title>
    <url>%2F2019%2F05%2F20%2Fsolution-luogu-p2633%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵$n$个节点的树，每个节点上有一个权值。对于$m$次询问，需要输出$u$到$v$的最短路径上第$k$小的点权。 $1\le n\le 100000,1 \le m\le 100000$ 感谢@tth37 的贡献 这题不难呀，怎么调了这么久？ ——Mr. G 前置知识是主席树。在利用主席树求解区间第K小数时可以发现，主席树是一种类似前缀和的数据结构，具有和前缀和类似的区间加减及差分等优秀性质。在求解线性区间的第K小数时，我们需要将该区间内的所有数值信息扔到一棵主席树中，并在这棵主席树上左右递归，以找到第K小数；同样的，我们可以类比树上前缀和的操作，定义$s[u]$为从根节点到第$u$号节点的“前缀主席树”（感性理解谢谢）。那么，包含$u$到$v$上所有数值信息的主席树就应该是： s[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]理解上式后，问题基本可以解决了。另外注意离散化和主席树的代码细节。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;// 离散化操作#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN = 100005;struct Node &#123; int l, r, sum;&#125;node[10000005];int head[MAXN],cnt;vector&lt;int&gt; G[MAXN];int N, M, L, lastans;int a[MAXN], b[MAXN];int f[MAXN][19], dep[MAXN];inline void build(Node &amp;u, int l, int r) &#123; u.sum = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r);&#125;inline void insert(Node c, Node &amp;u, int l, int r, int p) &#123; u.sum = c.sum + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r; else insert(node[c.r], node[u.r = ++cnt], mid+1, r, p), u.l = c.l;&#125;inline void dfs(int u, int fa) &#123; insert(node[head[fa]], node[head[u] = ++cnt], 1, L, id(u)); f[u][0] = fa; dep[u] = dep[fa] + 1; for (register int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (register int i = 18; i &gt;= 0; --i) &#123; if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 18; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;inline int query(Node x, Node y, Node z, Node w, int l, int r, int k) &#123; if (l == r) return l; int sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum; int mid = (l + r) &gt;&gt; 1; if(sum &gt;= k) return query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k); return query(node[x.r], node[y.r], node[z.r], node[w.r], mid+1, r, k - sum);&#125;inline int querypath(int u, int v, int k) &#123; int lca = Lca(u, v); return rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][0]]], 1, L, k));&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;a[i]), b[i] = a[i]; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; sort(b + 1, b + N + 1); L = unique(b + 1, b + N + 1) - (b + 1); build(node[head[0] = ++cnt], 1, L); dfs(1, 0); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, k; scanf("%d%d%d", &amp;u, &amp;v, &amp;k); int nowans = querypath(u^lastans, v, k); printf("%d\n", nowans); lastans = nowans; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树上前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-5-18]]></title>
    <url>%2F2019%2F05%2F18%2Fbulletin-2019-5-18%2F</url>
    <content type="text"><![CDATA[Hi~ 访问我网站的小崽子们~ 想在评论区发言的同时留下自己的个人头像吗？速戳这里！（Gravatar.com） 在这个网站注册用户，并在评论区留言时留下在Gravatar的账号邮箱，即可在评论区显示头像！ 可以在这里测试一下 由于网站是国家顶级域名（*.cn），所以缓存可能需要一周（或更长）的时间才能更新，请耐心等待！ 谢谢资瓷！]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题目列表-2019/5/29]]></title>
    <url>%2F2019%2F05%2F14%2Flist-for-class%2F</url>
    <content type="text"><![CDATA[动态规划题目列表~速戳 【例1】数字三角形 【变1】数字矩形 【变2】数字矩形+ 【变3】数字矩形++ 123456789for(int i=1;i&lt;=n;++i) f[i][m]=a[i][m];for(int j=m-1;j&gt;=1;--j)&#123; f[1][j]=a[1][j]+max(f[1][j+1],f[2][j+1]); for(int i=2;i&lt;n;++i)&#123; f[i][j]=a[i][j]+max(max(f[i-1][j+1],f[i][j+1]),f[i+1][j+1]); &#125; f[n][j]=a[n][j]+max(f[n][j+1],f[n-1][j+1]);&#125; 【例2】最长路经 【变1】滑雪 【变2】矩形嵌套 【例3】最长不降子序列 【变1】修剪草坪 【变2】烽火传递 【例4】传纸条 【变1】哦呦筷子 【例5】矩阵链乘 【变1】能量项链 【例6】括号配对 【例7】树的最大独立集 【变1】树的独立集 【变2】潜入行动]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1273有线电视网]]></title>
    <url>%2F2019%2F04%2F25%2Fsolution-luogu-p1273%2F</url>
    <content type="text"><![CDATA[题目链接 背包类树形dp。本题需要运用分组背包模型。 首先定义状态：$f[u][i]$表示以$u$为根的子树上，选择$i$个用户时的最大利润。由于电视公司可能亏本，因此$f$数组应赋极小初值。 可以将选择的用户个数看作背包的容量维度，将获得的利润看作背包的价值维度。可以设计出如下的状态转移： f[u][i]=max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}其中，$v$为$u$的子节点，$w$为这条边的权值。在$u$每个子节点上有许多“物品”，“物品”总数即为以$v$为根的子树上用户的个数；每个“物品”所具有的价值即为其最大利润，即$f[v][j]$。同时不应忽略边权对利润带来的影响。 注意细节处理及边界。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-素数的判定]]></title>
    <url>%2F2019%2F04%2F13%2Falgorithm-maths-primecheck%2F</url>
    <content type="text"><![CDATA[版权声明：本篇文章由特邀讲师胡家睿撰写，tth37只负责搬运、整理和发布；版权归胡家睿所有。 概述 素数定义：除1和本身以外没有其他因数的数 素数在信息学竞赛中有较多的应用，素数判定是解决复杂数论问题的基础。本篇文章介绍了一些素数判定的方法。 单个素数判定朴素判定： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;n;++i)&#123; if(n%i==0) return false;//除1、n以外还存在因数，所以n为合数； &#125; return true；//循环后没有判定为合数，则为素数。&#125; 时间复杂度：$\Theta (n)$ 优化： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;=sqrt(n);++i)&#123; if(n%i==0) return false; &#125; return true；&#125; 时间复杂度：$\Theta(\sqrt{n})$ 证明： ​ 若一个数$n$为合数，则它一定拥有一个质因数$k$。可以知道，$n/k$（记为$s$）为$n$的因数，且$s$不等于$n$。$k$和$s$二者必定有一个数小于等于$\sqrt{n}$，否则$k*s$一定大于$n$。所以只要在$\sqrt{n}$以内循环一遍即可。 埃氏素数筛如果用上面的方法判定$1-n$以内所有素数，会发现时间复杂度非常高。那么这个时候就要用筛法了。大致意思是用素数来筛掉合数，然后用$f$数组储存是否是素数。 1234567f[1]=true;//特判还是很必要的for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue;//i为合数直接跳过 for(int j=i+i;j&lt;=n;j+=i)&#123; f[j]=true;//i为素数，i的倍数一定为合数 &#125;&#125; 优化： 1234567f[1]=true;for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue; for(int j=i*i;j&lt;=n;j+=i)&#123;//这里只变了乘号，但是会快很多喔 f[j]=true; &#125;&#125; 原因是：$i*i$以下的所有合数都已经被筛掉了。具体证法，可以接着看下去（在线性筛里有类似的思想，所以看完可以尝试一下自己证明）。 素数线性筛上一个筛法时间复杂度$\Theta(log log n)$非常接近线性。但是要达到线性还差一点（这里不是比赛要求掌握所以就当兴趣学吧） 上一个筛法的大概想法，是每一个素数的倍数都筛掉，所以是让每一个合数都被它的质因子筛一遍。 那么接下来的筛法，就是让每个合数的最小质因子筛一遍（要开一个prime数组存所有素数）。先放代码： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f[10005],prime[10005];int main()&#123; ll n,i,j,cnt=0; cin&gt;&gt;n; //这个地方不用特判1,因为我们判定是否为素数的方法是f[i]是否为0; for(i=2;i&lt;=n;++i) &#123; if(!f[i]) &#123; prime[++cnt]=i;//存入素数; f[i]=i; &#125; for(j=1;j&lt;=cnt;++j) &#123; if(prime[j]*i&gt;n||prime[j]&gt;f[i]) break;//判定出界或i的因子中有比当前素数更小的（即prime[j]*i已经被f[i]筛过了）; f[prime[j]*i]=prime[j];//标记所有未被标记的i的倍数； &#125; &#125; cin&gt;&gt;i; cout&lt;&lt;f[i]&lt;&lt;" "; return 0; &#125; 核心就在于神奇的判定方法，可以多咀嚼咀嚼 时间复杂度$\Theta(n)$搞定，还可以找到$1-n$内所有合数的最小质因数。]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4559列队]]></title>
    <url>%2F2019%2F04%2F10%2Fsolution-luogu-p4559%2F</url>
    <content type="text"><![CDATA[题目链接 本题是主席树的一个简单应用。 阅读题目，不难得出贪心策略。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。（不会证） 对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。 为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下） 接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案： $r\le ql$ 此时处于当前值域内的所有学生都要往右跑 $qr\le l$ 此时处于当前值域内的所有学生都要往左跑 当前值域内没有学生 返回 $0$ 否则，必须将值域拆分，递归到左右子节点进行统计。 本题最绕的地方在于学生编号和学生位置是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int L=1000005;int N,M;struct Node&#123; int l,r; ll gl,gr,sum;&#125;node[L*22+5];int head[MAXN];int cnt;inline void build(Node&amp; u,int l,int r)&#123; u.sum=u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1;u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l; u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+1); u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);&#125;inline ll query(Node x,Node y,int l,int r,ll ql,ll qr)&#123; ll sum=y.sum-x.sum; ll gl=y.gl-x.gl,gr=y.gr-x.gr; if(sum==0) return 0; if(qr&lt;=l) return gl+(2*l-ql-qr)*(qr-ql+1)/2; if(ql&gt;=r) return gr+(ql+qr-2*r)*(qr-ql+1)/2; int mid=(l+r)&gt;&gt;1; ll lsum=node[y.l].sum-node[x.l].sum; return query(node[x.l],node[y.l],l,mid,ql,ql+lsum-1)+ query(node[x.r],node[y.r],mid+1,r,ql+lsum,qr);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); build(node[0],1,L); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); insert(node[head[i-1]],node[head[i]=++cnt],1,L,a); &#125; for(register int i=1;i&lt;=M;++i)&#123; ll l,r,k; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); printf("%lld\n",query(node[head[l-1]],node[head[r]],1,L,k,k+r-l)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5283异或粽子]]></title>
    <url>%2F2019%2F04%2F09%2Fsolution-luogu-p5283%2F</url>
    <content type="text"><![CDATA[题目链接 分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。 用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus … \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r] \oplus s[l-1]$。 将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。 将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。 在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。 注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。 另外，在将(1&lt;&lt;d)这样的式子转long long时，不能写成(long long)(1&lt;&lt;d)，而是((long long)1&lt;&lt;d)。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int DEP=31;int N,M;ll ans,s[MAXN];struct State&#123; ll val; int r,k; bool operator &lt;(const State&amp; rhs) const &#123;return val&lt;rhs.val;&#125;&#125;;priority_queue&lt;State&gt; q;struct Node&#123; int son[2],sum;&#125;trie[MAXN*(DEP+2)];int head[MAXN],cnt;inline void insert(Node c,Node&amp; u,ll val,int d)&#123; u.sum=c.sum+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; u.son[!x]=c.son[!x]; insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d-1);&#125;inline ll query(Node u,ll val,int d,int k)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; int lsum=trie[u.son[!x]].sum; if(lsum&gt;=k) return ((ll)1&lt;&lt;d)+(ll)query(trie[u.son[!x]],val,d-1,k); return (ll)query(trie[u.son[x]],val,d-1,k-lsum);&#125;int main()&#123; trie[0].son[0]=trie[0].son[1]=trie[0].sum=0; insert(trie[0],trie[head[0]=++cnt],0,DEP); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; ll a; scanf("%lld",&amp;a); s[i]=s[i-1]^a; insert(trie[head[i-1]],trie[head[i]=++cnt],s[i],DEP); q.push((State)&#123;query(trie[head[i-1]],s[i],DEP,1),i,1&#125;); &#125; for(register int i=1;i&lt;=M;++i)&#123; ans+=q.top().val; int r=q.top().r,k=q.top().k; q.pop(); if(k==r) continue; q.push((State)&#123;query(trie[head[r-1]],s[r],DEP,k+1),r,k+1&#125;); &#125; printf("%lld",ans); return 0;&#125; $p.s.$洛谷评测机有点小慢，不开O2会小概率发生TLE QwQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>可持久化trie</tag>
        <tag>异或</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-04-08]]></title>
    <url>%2F2019%2F04%2F08%2Fbulletin-2019-4-8%2F</url>
    <content type="text"><![CDATA[tth37 Blog已经绑定了最新域名：tth37.cn ！(购买自阿里云) 由于一些奇怪的原因（DNS域名解析和CNAME配置问题），我的博客在四月七日至四月八日出现许多异常，现已全部修复。 但在四月九日至四月十日的测试中，我被疯狂打脸；现在已经可以保证，只要在浏览器输入栏输入 tth37.cn，即可自动跳转https://tth37.cn，并在*CloudFlare*证书授权下安全运行。 请大佬们在新域名下体验高速加载和流畅访问新体验吧！ 另外，左侧边栏“日程表”已经启用；网站基本搭建完毕。以后将缩减网站维护时间。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习-可持久化数据结构]]></title>
    <url>%2F2019%2F03%2F29%2Falgorithm-persistentdatastructure%2F</url>
    <content type="text"><![CDATA[概述可持久化数据结构可以存储数据集在任意时间的历史状态。“可持久化”的基本思想是在每项操作结束后，仅创建数据结构中发生改变的部分的副本，不拷贝其他部分。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，可持久化数据结构能够高效地记录一个数据结构的所有历史状态。 可持久化Trie【实现过程】 设当前可持久化Trie的根节点为root，令p=root，i=0 建立一个新的节点，令root‘=q 若p!=0，则对于每种字符c，令trie[q,c]=trie[p,c] 建立一个新的节点q’，令trie[q,s]=q‘ 令p=trie[p,s]，q=trie[q,s]，i=i+1 重复步骤3-5，直到i到达字符串末尾 【例题】最大异或和 luogu-p4735给定一个非负整数序列{a}，初始长度为N。 有M个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。 Q l r x：询问操作，你需要找到一个位置p，满足l≤p≤r，使得： a[p]⊕a[p+1]⊕…⊕a[N]⊕x 最大，输出最大是多少。 【分析】考虑异或前缀和。根据异或运算的性质： a[p]\oplus a[p+1]\oplus ...\oplus a[N]\oplus x=s[p-1]\oplus s[N]\oplus x对于添加操作，序列s很容易维护。对于询问操作，问题变为：已知一个整数val=s[N] xor x，求一个位置p，满足l-1&lt;=p&lt;=r-1，使得s[p] xor val最大。显然可以将s数组插入可持久化Trie中，每次取出在l与r范围内的数据进行贪心（尽量往相反的节点走），从而求出答案。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC optimize(3)//QwQ#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=600005;const int DEP=24;int N,M;int trie[MAXN*26][2],sum[MAXN*26];int head[MAXN],cnt=1;int s[MAXN];inline void insert(int c,int u,int val,int d)&#123; sum[u]=sum[c]+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; trie[u][!x]=trie[c][!x]; insert(trie[c][x],trie[u][x]=++cnt,val,d-1);&#125;inline int query(int c,int u,int val,int d)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; if(sum[trie[u][!x]]&gt;sum[trie[c][!x]]) return (1&lt;&lt;d)+query(trie[c][!x],trie[u][!x],val,d-1); else return query(trie[c][x],trie[u][x],val,d-1);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); insert(0,0,0,DEP); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); s[i]=s[i-1]^a; insert(head[i-1],head[i]=++cnt,s[i],DEP); &#125; for(register int i=1;i&lt;=M;++i)&#123; char opt; getchar(),opt=getchar(); if(opt=='A')&#123; int a; scanf("%d",&amp;a); N++; s[N]=s[N-1]^a; insert(head[N-1],head[N]=++cnt,s[N],DEP); &#125; else&#123; int l,r,a; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); if(l==r) printf("%d\n",s[l-1]^s[N]^a); else printf("%d\n",query(head[l-2],head[r-1],a^s[N],DEP)); &#125; &#125; return 0;&#125; 可持久化数组【例题】【模板】可持久化数组 luogu-p3919如题，你需要维护这样的一个长度为 N 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 【分析】在原数组上建立线段树，在叶子节点上记录原数组数值。执行完修改操作后，根据可持久化的思想，只需更改一条链上的节点信息；执行完访问操作后，则可以将目前操作的根节点指针指向被查询的历史状态根节点。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;struct Node&#123; int l,r,val;&#125;node[MAXN*22+5];int N,M,cnt;int a[MAXN],head[MAXN];inline void build(Node&amp; u,int l,int r)&#123; if(l==r)&#123; u.val=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void change(Node c,Node&amp; u,int l,int r,int p,int val)&#123; if(l==r)&#123; u.val=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)&#123; change(node[c.l],node[u.l=++cnt],l,mid,p,val); u.r=c.r; &#125; else&#123; change(node[c.r],node[u.r=++cnt],mid+1,r,p,val); u.l=c.l; &#125;&#125;inline int query(Node u,int l,int r,int p)&#123; if(l==r) return u.val; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) return query(node[u.l],l,mid,p); else return query(node[u.r],mid+1,r,p);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) scanf("%d",&amp;a[i]); build(node[0],1,N); for(register int i=1;i&lt;=M;++i)&#123; int v,opt,p,val; scanf("%d%d",&amp;v,&amp;opt); if(opt==1)&#123; scanf("%d%d",&amp;p,&amp;val); change(node[head[v]],node[head[i]=++cnt],1,N,p,val); &#125; else&#123; scanf("%d",&amp;p); head[i]=head[v]; printf("%d\n",query(node[head[i]],1,N,p)); &#125; &#125; return 0;&#125; 可持久化值域线段树（主席树）【例题】【模板】可持久化线段树 luogu-p3834给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。 【分析】值域有负数出现，考虑离散化。假设离散化后的值域为[1,L]。 在值域上建立线段树，每个节点上存储该值域内有多少个数据。对线段树进行可持久化处理，与上一题可持久化数组实现方式类似。 在查询时，如果一个节点的左子节点上的cnt值小于等于正在查询的K，则问题转化为求左半区间内第K小值；否则，转化为求右半区间内第K-cnt小值。 查询时的操作类似于在值域上的二分，因此复杂度在log级别。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN=200005;struct Node&#123; int l,r,sum;&#125;node[MAXN&lt;&lt;6];int N,M,L,cnt;int a[MAXN],b[MAXN];int head[MAXN];inline void build(Node u,int l,int r)&#123; u.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],1,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l;&#125;inline int query(Node c,Node u,int l,int r,int k)&#123; if(l==r) return l; int sum=node[u.l].sum-node[c.l].sum,mid=(l+r)&gt;&gt;1; if(sum&gt;=k) return query(node[c.l],node[u.l],1,mid,k); else return query(node[c.r],node[u.r],mid+1,r,k-sum);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+N+1); L=unique(b+1,b+N+1)-(b+1); head[0]=0; build(node[0],1,L); for(register int i=1;i&lt;=N;++i) insert(node[head[i-1]],node[head[i]=++cnt],1,L,id(i)); for(register int i=1;i&lt;=M;++i)&#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",rid(query(node[head[l-1]],node[head[r]],1,L,k))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化trie</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4516潜入行动]]></title>
    <url>%2F2019%2F03%2F28%2Fsolution-luogu-p4516%2F</url>
    <content type="text"><![CDATA[这是一个并不简单的背包类树形dp…… 很自然地想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。 状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是： f[u][i+j]=combine(f[u][i],f[v][j])相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为： f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1] f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1]) f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1] f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100005;const int mod=1000000007;int N,K;int f[MAXN][105][2][2];int g[105][2][2];int size[MAXN];vector&lt;int&gt; G[MAXN];inline int Mod(ll x,ll y)&#123; x%=mod,y%=mod; return (int)(x+y)%mod;&#125;void dp(int u,int fa)&#123; size[u]=1; f[u][0][0][0]=f[u][1][1][0]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(v,u); for(register int i=0;i&lt;=min(size[u],K);++i)&#123; g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0; g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0; g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0; g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0; &#125; for(register int i=0;i&lt;=min(size[u],K);++i)&#123; for(register int j=0;j&lt;=min(size[v],K-i);++j)&#123; f[u][i+j][0][0]=Mod((ll)f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]); f[u][i+j][0][1]=Mod((ll)f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*((ll)f[v][j][1][1]+(ll)f[v][j][0][1])); f[u][i+j][1][0]=Mod((ll)f[u][i+j][1][0],(ll)g[i][1][0]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1])); f[u][i+j][1][1]=Mod((ll)f[u][i+j][1][1],(ll)g[i][1][0]*((ll)f[v][j][1][0]+(ll)f[v][j][1][1])+(ll)g[i][1][1]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]+(ll)f[v][j][1][0]+(ll)f[v][j][1][1])); &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1,0); printf("%d",(int)(f[1][K][0][1]+f[1][K][1][1])%mod); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-背包类树形dp]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-knapsacktreedp%2F</url>
    <content type="text"><![CDATA[树形分组背包【例题】 选课 luogu-p2014 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 【分析】记录状态：$f[u][i]$为以$u$为根的子树上，选择$i$门课所能获得的最大学分。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。那么在$u$上相当于有一个容量为$M$的背包，每个子树中不同的状态相当于不同的物品，例如$f[v][j]$为体积为$j$，价值为$f[v][j]$中存储的数值。 在本题中，由于所有关系构成森林结构，因此可以设$0$号结点为“没有先修课”的课的先修课。然后以$0$为根，进行状态转移即可。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define Pb push_backconst int MAXN=305;const int MAXM=305;int N,M;vector&lt;int&gt; son[MAXN];int a[MAXN],f[MAXN][MAXM];inline void dp(int u)&#123; for(vector&lt;int&gt;::iterator it=son[u].begin();it!=son[u].end();it++) &#123; int v=*it; dp(v); for(register int i=M;i&gt;=0;--i) for(register int j=0;j&lt;=i;++j) f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]); &#125; if(u) &#123; for(register int i=M;i&gt;=1;--i) f[u][i]=f[u][i-1]+a[u]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) &#123; int k,s; scanf("%d%d",&amp;k,&amp;s); son[k].Pb(i);a[i]=s; &#125; dp(0); printf("%d",f[0][M]); return 0;&#125; 【例题】有线电视网 luogu-p1273某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 【分析】记录状态：$f[i][j]$为以$i$为根，选择$j$个用户最多有多少收入。状态转移时如果无法从正面入手（如本题不知道价格的最值，且价值分布更为稀疏），可以从反面设计状态，在输出答案时进行判断即可。转移时可以记录$size$数组进行优化。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125; 组合计数类树形背包【例题】树的独立集 （原创）给定一棵有$N$个结点的树，输出这棵树中包含$K$个结点的独立集个数。 【分析】有关组合计数的背包类树形dp问题，一般均可用以下方式解决。 记录状态：$f[u][k][0/1]$ 为以$u$为根的子树，$u$的状态为选或不选，共选择$k$个结点时独立集的个数。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。每递归访问结束一个子结点，就考虑把该子结点的状态与已经处理一部分的当前结点状态相匹配。每访问完一个结点，就把配对后产生的状态归为已处理的状态。由于需要根据之前的状态推导后续状态，因此不难看出利用到背包的思想。 状态转移方程的基本思想如下： f[u][i+j][(state)]=combine(f[u][i][(state)]*f[u][j][(state)])本题的状态转移方程也不难推出： f[u][0][i+j]=\sum f[u][0][i]*(f[v][0][j]+f[v][1][j]) f[u][1][i+j]=\sum f[u][1][i]*f[v][0][j]【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10005;int N,K;vector&lt;int&gt; G[MAXN];int f[MAXN][105][2];int g[105][2];int size[MAXN];void dp(int fa,int u)&#123; size[u]=1; f[u][0][0]=1,f[u][1][1]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(u,v); for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; g[i][0]=f[u][i][0],f[u][i][0]=0; g[i][1]=f[u][i][1],f[u][i][1]=0; &#125; for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; for(register int j=0;j&lt;=min(K-i,size[v]);++j)&#123; f[u][i+j][0]+=g[i][0]*(f[v][j][0]+f[v][j][1]); f[u][i+j][1]+=g[i][1]*f[v][j][0]; &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(0,1); printf("%d",f[1][K][0]+f[1][K][1]); return 0;&#125; 习题潜入行动 未完待续~]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2774方格取数问题]]></title>
    <url>%2F2019%2F03%2F24%2Fsolution-luogu-p2774%2F</url>
    <content type="text"><![CDATA[题目链接 不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。 首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。 源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。 如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。 问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAXN=100005;int N,M,S,T;ll sum;int nx[]=&#123;0,1,0,-1&#125;;int ny[]=&#123;1,0,-1,0&#125;;struct Edge&#123; int v,w,nxt;&#125;mem[MAXN];int head[MAXN],cnt=1;inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].w=w; mem[cnt].v=v; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int d[MAXN];bool vis[MAXN];inline bool bfs()&#123; memset(vis,0,sizeof(vis)); vis[S]=1;d[S]=0; queue&lt;int&gt; q; q.push(S); while(q.size())&#123; int u=q.front();q.pop(); for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(vis[v]||(w==0)) continue; vis[v]=1;d[v]=d[u]+1; q.push(v); &#125; &#125; return vis[T];&#125;inline int dfs(int u,int flow)&#123; if(u==T) return flow; int rflow; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(w==0||d[u]+1!=d[v]) continue; if(rflow=dfs(v,min(flow,w)))&#123; mem[i].w-=rflow; mem[i^1].w+=rflow; return rflow; &#125; &#125; return 0;&#125;inline int Dinic()&#123; int maxflow=0,lowflow; while(bfs())&#123; while(lowflow=dfs(S,INF)) maxflow+=lowflow; &#125; return maxflow;&#125;int main()&#123; scanf("%d%d",&amp;M,&amp;N); S=0,T=M*N+1; for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125; printf("%lld",sum-Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目列表-网络流]]></title>
    <url>%2F2019%2F03%2F24%2Flist-networkflow%2F</url>
    <content type="text"><![CDATA[方格取数问题（二分图+建模技巧）将原图黑白染色，并保证产生矛盾的两个位置颜色不同。源点连接黑点，白点连接汇点，黑点连接与之产生矛盾的白点。通过 最大和=全局和-最小割，在建立的网络上跑最小割（最大流）即可。 123456789101112131415161718192021for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125;]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-03-24]]></title>
    <url>%2F2019%2F03%2F24%2Fbulletin-2019-3-24%2F</url>
    <content type="text"><![CDATA[2019/3/24，tth37搭建了这个github博客。 tth37希望在这个博客里记录一些自己学习OI的心得，并发布一些题解，贴出学习规划。 但tth37实在是太弱了，因此他会更新得十分缓慢。 另外，还请shiwt巨佬多多指教。 任何一个伟大的思想，都有一个微不足道的开始。 p.s. 可能会将洛谷博客上的文章搬运过来，所以有些文章的发布时间可能在此之前，请别见怪。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题目列表-动态规划]]></title>
    <url>%2F2019%2F03%2F20%2Flist-dp%2F</url>
    <content type="text"><![CDATA[任务安排（斜率优化+费用提前计算） f[i]=min_{0\le j]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1080国王游戏]]></title>
    <url>%2F2019%2F01%2F26%2Fsolution-luogu-p1080%2F</url>
    <content type="text"><![CDATA[题目链接 高精度怎能少了Python3题解。。。 贪心策略一楼dalao已经讲得很清楚了，上一发超短代码（学Python就是为了水高精） 123456789101112131415N=int(input())s=input().split()S=int(s[0])T=int(s[1])a=[]for i in range(1,N+1): k=input().split() a.append((int(k[0]),int(k[1])))a.sort(key=lambda x:x[0]*x[1])ans=0for i in range(0,N): if(S//(a[i])[1]&gt;ans): ans=S//(a[i])[1] S*=(a[i])[0]print(ans)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1022计算器的改良]]></title>
    <url>%2F2018%2F12%2F19%2Fsolution-luogu-p1022%2F</url>
    <content type="text"><![CDATA[题目链接 本题是一道非常漂亮的模拟。只要能理清思路，代码并不会特别复杂。 首先分析题目。解一元一次方程最简单的方法就是移项，把常数移到等号右侧，把一次项系数移到等号左侧，用常数除以系数即为答案。那么在读入字符串的过程中，便可以进行操作。 对于字符串中的数据，我们可以用类似快读的方法读入。然而，要判断这些数据从哪里来，到哪里去，便是本题的关键所在。 对于每个数据，要想清楚地辨别它的身份，我们只需解决三个问题： 1.该数据是正数还是负数？ 3.该数据在等号左侧还是在等号右侧？ 2.该数据是常数还是系数？ 第一个问题看似十分无脑，用一个变量f1来存储符号即可（将f1赋值为1或-1，在读入数据结束时将得到的数据乘以f1）。但需特别注意，在一个表达式的开头（等号左侧和等号右侧的表达式）不会有‘+’、‘-’符号，所以在程序的开头和读入‘=’号是，要将f1赋值为1。 第二个问题也非常简单，可以用变量f2来存储。因为这个问题与移项运算的符号有关，因此也可以将f2赋值为1或-1，并约定在等号左侧时f2为1，在等号右侧时f2为-1。（当然你也可以反着约定） 第三个问题同样不难解决。在读入数据结束后（即读入了一个符号），判断这个符号是运算符还是字母即可。如果是字母，则将得到的数据移到等号右侧，否则将数据移到等号左侧。但是还有一个注意点：如果一个未知数的系数为1，我们会将系数省略。因此在读入数据为0时，我们要将其更改为1。 经过分析，你会发现本题一点也不难实现。其关键在于对数据状态的准确描述。用清晰、简洁的变量描述状态，根据不同的状态采取不同的措施，这便是编程学习的一大基本素养。 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int l,r;//l代表系数，r代表常数 char x; //用x存储字母 void solve()&#123; char c; int f1=1,f2=1,tmp=0; while(~scanf("%c",&amp;c)) &#123; if(c&gt;='0'&amp;&amp;c&lt;='9')//类似快读的读入方式 &#123; tmp*=10; tmp+=c-'0'; &#125; else &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') l+=(tmp==0)?f2*f1:tmp*f2*f1,x=c;//判断系数是否为1 else r+=tmp*(-f2)*f1; tmp=0; &#125; if(c=='+') &#123;f1=1;continue;&#125; if(c=='-') &#123;f1=-1;continue;&#125; if(c=='=') &#123;f2=-1;f1=1;continue;&#125; &#125;&#125;int main()&#123; solve(); printf("%c=%0.3f",x,(float)r/l==0?abs((float)r/l):(float)r/l); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1204挤牛奶]]></title>
    <url>%2F2018%2F12%2F15%2Fsolution-luogu-p1204%2F</url>
    <content type="text"><![CDATA[题目链接 介绍一种本题的贪心解法。 本题要求读入一些挤牛奶的时间段，求最长至少有一人在挤牛奶的时间段和最长没有人在挤牛奶的时间段。把读入的区间视作线段，则题意转变为求至少有一条线段覆盖的最大区间和没有线段覆盖的区间。 假设读入数据如下： 首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。 然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。 程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。 程序如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int N; struct node&#123; int begin,end;&#125;m[5005];bool cmp(node a,node b)&#123; return a.begin&lt;b.begin;&#125;int main()&#123; scanf("%d",&amp;N); for(register int i=1;i&lt;=N;++i) scanf("%d%d",&amp;m[i].begin,&amp;m[i].end); sort(m+1,m+1+N,cmp); int begin=m[1].begin; int end=m[1].end; int ans1=0,ans2=0; for(register int i=2;i&lt;=N;++i)&#123; if(m[i].begin&lt;=end) end=max(end,m[i].end); else&#123; ans1=max(ans1,end-begin); ans2=max(ans2,m[i].begin-end); begin=m[i].begin; end=m[i].end; &#125; &#125; ans1=max(ans1,end-begin); printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
