<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解-luogu-p2627修剪草坪]]></title>
    <url>%2F2019%2F06%2F09%2Fsolution-luogu-p2627%2F</url>
    <content type="text"><![CDATA[题目链接 一道单调队列入门题。 面对动规题，首先设计状态转移方程。令$f[i]$表示$1-i$中连取不超过$K$个数，且第$i$个数不取所能累加的最大和。 因为第$i$个数不取，所以在$i$之前一定连取了一段数。这段数的长度可能为$0-K$（注意是$0-K$而不是$1-K$，可以通过手推样例发现最优解中可能存在连着两个数不取的情况）。连取的一段数所能累加的和可以用前缀和计算。考虑边界条件后，状态转移方程如下： $$f[i]=\max_{i-K-1\le j \le i-1} \lbrace f[j]+s[i-1]-s[j] \rbrace$$ 由于$max$函数的循环变量是$j$，所以只与$i$相关的变量$s[i-1]$可以作为常数提出到$max$函数之外，即： $$f[i]=\max_{i-K-1\le j \le i-1}\lbrace f[j]-s[j]\rbrace +s[i-1]$$ 将状态转移方程化简到这样，就已经可以用单调队列进行优化了。我们可以用单调队列维护$f[j]-s[j]$的最值，在循环时将其最大值取出再加上$s[i-1]$即为$f[i]$。 如果想不到该如何操作，也可以这样理解： $$g[i]=f[i]-s[i]$$$$f[i]=\max_{i-K-1\le j \le i-1}\lbrace g[j]\rbrace+s[i-1]$$ 由于我们定义$f[i]$是第$i$个数不取的最优解，可以强行求解$f[N+1]$（虽然它似乎没有实际意义）作为本题的最终答案。 代码如下： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, K;ll s[100005], f[100005];int q[100005];int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%lld", &amp;s[i]); s[i] += s[i-1]; &#125; int l = 0, r = 1; q[0] = 0, f[0] = 0; for (register int i = 1; i &lt;= N + 1; ++i) &#123; while (l &lt; r &amp;&amp; q[l] &lt; i - K - 1) l++; f[i] = f[q[l]] - s[q[l]] + s[i-1]; while (l &lt; r &amp;&amp; f[q[r - 1]] - s[q[r - 1]] &lt; f[i] - s[i]) r--; q[r++] = i; &#125; printf("%lld", f[N + 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1600天天爱跑步(Beta)]]></title>
    <url>%2F2019%2F06%2F07%2Fsolution-luogu-p1600%2F</url>
    <content type="text"><![CDATA[题目链接 准备写一篇较为详细的题解。部分思路来自《算法竞赛进阶指南》。 游戏地图构成树形结构，为方便处理，可以取$1$号节点作为根，转化为有根树处理。 可以发现，从S到T的路径有且只有一条，并且必将经过$lca(S,T)$。 不妨设$x$节点上有一名观察员，其观察时间为$W[x]$。我们可以对$x$的位置进行分情况讨论。 $x$在$S$到$lca(S,T)$的路径上（该路径包含$lca(S,T)$）。 为方便说明，假设$S=6$，$T=4$。那么，此时$x$可能为$1$，$3$或$6$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=d[S]-d[x]$（$d$数组表示节点深度）。对上式移项，得到$W[x]+d[x]=d[S]$。 接下来，我们给每一个节点分配若干个权值，即在每一个节点上开一个一维数组，记录各个权值。根据上式，我们可以将$S$到$lca(S,T)$的路径上每一个节点的$d[S]$号权值加一。按照这种方式处理完所有玩家的信息之后，我们遍历所有节点，每个节点上的$(W[x]+d[x])$号权值即为所求。 该方法的正确性应该不难理解。$(W[x]+d[x])$号权值的意义即为该节点上满足前文所述等式的玩家个数，而满足等式意味着玩家将会在观察员探头时经过观察点，符合题意。 但是这种暴力方法显然还有优化的空间。在有根树的一条链上进行权值更改，可以尝试用树上差分的知识解决。在节点$S$上的$d[S]$号权值加一，节点$fa[lca(S,T)]$上的$d[S]$号权值减一（可以在每个节点上开一个不定长数组vector记录当前节点上的加减操作），最后进行统计时，计算当前子树所有$(W[x]+d[x])$号权值和即可。但即便如此，答案统计也并不容易实现；我们可以使用以下方法： 建立全局数组$s$，其中$s[i]$表示$i$号权值之和。深度优先遍历所有节点，在刚访问到当前节点时，记录$cnt=s[W[x]+d[x]]$。遍历当前节点上的vector，执行加减操作（例如：vector中的一项操作把$3$号权值减一，则$s[3]=s[3]-1$）。递归访问当前节点的所有子节点。访问结束后，$(s[W[x]+d[x]]-cnt)$即为所求。 结合dfs序的相关知识，访问完当前节点的所有子节点之后，$s$数组已经记录了以$x$为根的子树上所有操作。因此将访问后与访问前的权值相减，即为树上差分所得到的答案。 别忘了才分类讨论了一半呢…… $x$在$lca(S,T)$到$T$的路径上（该路径不包含$lca(S,T)$）。同样假设$S=6$，$T=4$。此时$x$可能为$2$或$4$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=(d[S]-d[lca(S,T)])+(d[x]-d[lca(S,T)])$。对上式移项，得到$W[x]-d[x]=d[S]-2*d[lca(S,T)]$。 类似地，我们只需将操作改为对$(d[S]-2*d[lca(S,T)])$号权值的操作即可。由于权值有可能为负，需要将序号整体平移$N$个单位，即改为对$(d[S]-2*d[lca(S,T)]+N)$号权值的操作。在每个节点上另开一个操作vector，统计答案时另开一个$s$数组，将计算出的答案与第一种情况的答案相加即可。 Q：为什么必须另开操作vector和$s$数组？ A：回顾一下提到的两个式子：$W[x]+d[x]=d[S]$，$W[x]-d[x]=d[S]-2*d[lca(S,T)]$如果将两者合起来操作，有可能产生“将$d[S]$号权值加一，碰巧统计答案时$W[x]-d[x]=d[S]$”的情况。然而，上述等式是没有任何意义的：$x$号节点根本无法观察到玩家。为了避免此类错误，必须将两种操作分开处理。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300005;struct opt &#123;int id, op;&#125;;vector&lt;int&gt; G[MAXN];vector&lt;opt&gt; opt1[MAXN], opt2[MAXN];int N, M;int W[MAXN];int f[MAXN][20], d[MAXN];void dfs1(int u, int fa) &#123; f[u][0] = fa, d[u] = d[fa] + 1; for (register int i = 1; i &lt;= 19; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (d[u] &lt; d[v]) swap(u, v); for (register int i = 19; i &gt;= 0; --i) &#123; if (d[f[u][i]] &gt;= d[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 19; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int s1[MAXN*3], s2[MAXN*3];int ans[MAXN];void dfs2(int u, int fa) &#123; int cnt1 = s1[W[u] + d[u] + N]; int cnt2 = s2[W[u] - d[u] + N]; for (vector&lt;opt&gt;::iterator it = opt1[u].begin(); it != opt1[u].end(); it++) s1[it-&gt;id] += it-&gt;op; for (vector&lt;opt&gt;::iterator it = opt2[u].begin(); it != opt2[u].end(); it++) s2[it-&gt;id] += it-&gt;op; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs2(v, u); &#125; ans[u] = s1[W[u] + d[u] + N] - cnt1 + s2[W[u] - d[u] + N] - cnt2;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(1, 0); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;W[i]); for (register int i = 1; i &lt;= M; ++i) &#123; int S, T; scanf("%d%d", &amp;S, &amp;T); int lca = Lca(S, T); opt1[S].push_back((opt)&#123;d[S] + N, 1&#125;); opt1[f[lca][0]].push_back((opt)&#123;d[S] + N, -1&#125;); opt2[T].push_back((opt)&#123;d[S] - 2*d[lca] + N, 1&#125;); opt2[lca].push_back((opt)&#123;d[S] - 2*d[lca] + N, -1&#125;); &#125; dfs2(1, 0); for (register int i = 1; i &lt;= N; ++i) printf("%d ", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2633 Count on a tree(COT)]]></title>
    <url>%2F2019%2F05%2F20%2Fsolution-luogu-p2633%2F</url>
    <content type="text"><![CDATA[题目链接 这题不难呀，怎么调了这么久？ ——Mr. G 前置知识是主席树。在利用主席树求解区间第K小数时可以发现，主席树是一种类似前缀和的数据结构，具有和前缀和类似的区间加减及差分等优秀性质。在求解线性区间的第K小数时，我们需要将该区间内的所有数值信息扔到一棵主席树中，并在这棵主席树上左右递归，以找到第K小数；同样的，我们可以类比树上前缀和的操作，定义$s[u]$为从根节点到第$u$号节点的“前缀主席树”（感性理解谢谢）。那么，包含$u$到$v$上所有数值信息的主席树就应该是：$$s[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]$$理解上式后，问题基本可以解决了。另外注意离散化和主席树的代码细节。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;// 离散化操作#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN = 100005;struct Node &#123; int l, r, sum;&#125;node[10000005];int head[MAXN],cnt;vector&lt;int&gt; G[MAXN];int N, M, L, lastans;int a[MAXN], b[MAXN];int f[MAXN][19], dep[MAXN];inline void build(Node &amp;u, int l, int r) &#123; u.sum = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r);&#125;inline void insert(Node c, Node &amp;u, int l, int r, int p) &#123; u.sum = c.sum + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r; else insert(node[c.r], node[u.r = ++cnt], mid+1, r, p), u.l = c.l;&#125;inline void dfs(int u, int fa) &#123; insert(node[head[fa]], node[head[u] = ++cnt], 1, L, id(u)); f[u][0] = fa; dep[u] = dep[fa] + 1; for (register int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (register int i = 18; i &gt;= 0; --i) &#123; if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 18; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;inline int query(Node x, Node y, Node z, Node w, int l, int r, int k) &#123; if (l == r) return l; int sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum; int mid = (l + r) &gt;&gt; 1; if(sum &gt;= k) return query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k); return query(node[x.r], node[y.r], node[z.r], node[w.r], mid+1, r, k - sum);&#125;inline int querypath(int u, int v, int k) &#123; int lca = Lca(u, v); return rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][0]]], 1, L, k));&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;a[i]), b[i] = a[i]; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; sort(b + 1, b + N + 1); L = unique(b + 1, b + N + 1) - (b + 1); build(node[head[0] = ++cnt], 1, L); dfs(1, 0); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, k; scanf("%d%d%d", &amp;u, &amp;v, &amp;k); int nowans = querypath(u^lastans, v, k); printf("%d\n", nowans); lastans = nowans; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树上前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-5-18]]></title>
    <url>%2F2019%2F05%2F18%2Fbulletin-2019-5-18%2F</url>
    <content type="text"><![CDATA[Hi~ 访问我网站的小崽子们~ 想在评论区发言的同时留下自己的个人头像吗？速戳这里！（Gravatar.com） 在这个网站注册用户，并在评论区留言时留下在Gravatar的账号邮箱，即可在评论区显示头像！ 可以在这里测试一下 由于网站是国家顶级域名（*.cn），所以缓存可能需要一周（或更长）的时间才能更新，请耐心等待！ 谢谢资瓷！]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题目列表-2019/5/29]]></title>
    <url>%2F2019%2F05%2F14%2Flist-for-class%2F</url>
    <content type="text"><![CDATA[动态规划题目列表~速戳 【例1】数字三角形 【变1】数字矩形 【变2】数字矩形+ 【变3】数字矩形++ 123456789for(int i=1;i&lt;=n;++i) f[i][m]=a[i][m];for(int j=m-1;j&gt;=1;--j)&#123; f[1][j]=a[1][j]+max(f[1][j+1],f[2][j+1]); for(int i=2;i&lt;n;++i)&#123; f[i][j]=a[i][j]+max(max(f[i-1][j+1],f[i][j+1]),f[i+1][j+1]); &#125; f[n][j]=a[n][j]+max(f[n][j+1],f[n-1][j+1]);&#125; 【例2】最长路经 【变1】滑雪 【变2】矩形嵌套 【例3】最长不降子序列 【变1】修剪草坪 【变2】烽火传递 【例4】传纸条 【变1】哦呦筷子 【例5】矩阵链乘 【变1】能量项链 【例6】括号配对 【例7】树的最大独立集 【变1】树的独立集 【变2】潜入行动]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1273有线电视网]]></title>
    <url>%2F2019%2F04%2F25%2Fsolution-luogu-p1273%2F</url>
    <content type="text"><![CDATA[题目链接 背包类树形dp。本题需要运用分组背包模型。 首先定义状态：$f[u][i]$表示以$u$为根的子树上，选择$i$个用户时的最大利润。由于电视公司可能亏本，因此$f$数组应赋极小初值。 可以将选择的用户个数看作背包的容量维度，将获得的利润看作背包的价值维度。可以设计出如下的状态转移：$$f[u][i]=max_{v\in son(u)}{f[u][i-j]+f[v][j]-w}$$其中，$v$为$u$的子节点，$w$为这条边的权值。在$u$每个子节点上有许多“物品”，“物品”总数即为以$v$为根的子树上用户的个数；每个“物品”所具有的价值即为其最大利润，即$f[v][j]$。同时不应忽略边权对利润带来的影响。 注意细节处理及边界。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-素数的判定]]></title>
    <url>%2F2019%2F04%2F13%2Falgorithm-maths-primecheck%2F</url>
    <content type="text"><![CDATA[版权声明：本篇文章由特邀讲师胡家睿撰写，tth37只负责搬运、整理和发布；版权归胡家睿所有。 概述 素数定义：除1和本身以外没有其他因数的数 素数在信息学竞赛中有较多的应用，素数判定是解决复杂数论问题的基础。本篇文章介绍了一些素数判定的方法。 单个素数判定朴素判定： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;n;++i)&#123; if(n%i==0) return false;//除1、n以外还存在因数，所以n为合数； &#125; return true；//循环后没有判定为合数，则为素数。&#125; 时间复杂度：$\Theta (n)$ 优化： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;=sqrt(n);++i)&#123; if(n%i==0) return false; &#125; return true；&#125; 时间复杂度：$\Theta(\sqrt{n})$ 证明： ​ 若一个数$n$为合数，则它一定拥有一个质因数$k$。可以知道，$n/k$（记为$s$）为$n$的因数，且$s$不等于$n$。$k$和$s$二者必定有一个数小于等于$\sqrt{n}$，否则$k*s$一定大于$n$。所以只要在$\sqrt{n}$以内循环一遍即可。 埃氏素数筛如果用上面的方法判定$1-n$以内所有素数，会发现时间复杂度非常高。那么这个时候就要用筛法了。大致意思是用素数来筛掉合数，然后用$f$数组储存是否是素数。 1234567f[1]=true;//特判还是很必要的for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue;//i为合数直接跳过 for(int j=i+i;j&lt;=n;j+=i)&#123; f[j]=true;//i为素数，i的倍数一定为合数 &#125;&#125; 优化： 1234567f[1]=true;for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue; for(int j=i*i;j&lt;=n;j+=i)&#123;//这里只变了乘号，但是会快很多喔 f[j]=true; &#125;&#125; 原因是：$i*i$以下的所有合数都已经被筛掉了。具体证法，可以接着看下去（在线性筛里有类似的思想，所以看完可以尝试一下自己证明）。 素数线性筛上一个筛法时间复杂度$\Theta(log log n)$非常接近线性。但是要达到线性还差一点（这里不是比赛要求掌握所以就当兴趣学吧） 上一个筛法的大概想法，是每一个素数的倍数都筛掉，所以是让每一个合数都被它的质因子筛一遍。 那么接下来的筛法，就是让每个合数的最小质因子筛一遍（要开一个prime数组存所有素数）。先放代码： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f[10005],prime[10005];int main()&#123; ll n,i,j,cnt=0; cin&gt;&gt;n; //这个地方不用特判1,因为我们判定是否为素数的方法是f[i]是否为0; for(i=2;i&lt;=n;++i) &#123; if(!f[i]) &#123; prime[++cnt]=i;//存入素数; f[i]=i; &#125; for(j=1;j&lt;=cnt;++j) &#123; if(prime[j]*i&gt;n||prime[j]&gt;f[i]) break;//判定出界或i的因子中有比当前素数更小的（即prime[j]*i已经被f[i]筛过了）; f[prime[j]*i]=prime[j];//标记所有未被标记的i的倍数； &#125; &#125; cin&gt;&gt;i; cout&lt;&lt;f[i]&lt;&lt;" "; return 0; &#125; 核心就在于神奇的判定方法，可以多咀嚼咀嚼 时间复杂度$\Theta(n)$搞定，还可以找到$1-n$内所有合数的最小质因数。]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4559列队]]></title>
    <url>%2F2019%2F04%2F10%2Fsolution-luogu-p4559%2F</url>
    <content type="text"><![CDATA[题目链接 本题是主席树的一个简单应用。 阅读题目，不难得出贪心策略。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。（不会证） 对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。 为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下） 接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案： $r\le ql$ 此时处于当前值域内的所有学生都要往右跑 $qr\le l$ 此时处于当前值域内的所有学生都要往左跑 当前值域内没有学生 返回 $0$ 否则，必须将值域拆分，递归到左右子节点进行统计。 本题最绕的地方在于学生编号和学生位置是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int L=1000005;int N,M;struct Node&#123; int l,r; ll gl,gr,sum;&#125;node[L*22+5];int head[MAXN];int cnt;inline void build(Node&amp; u,int l,int r)&#123; u.sum=u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1;u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l; u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+1); u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);&#125;inline ll query(Node x,Node y,int l,int r,ll ql,ll qr)&#123; ll sum=y.sum-x.sum; ll gl=y.gl-x.gl,gr=y.gr-x.gr; if(sum==0) return 0; if(qr&lt;=l) return gl+(2*l-ql-qr)*(qr-ql+1)/2; if(ql&gt;=r) return gr+(ql+qr-2*r)*(qr-ql+1)/2; int mid=(l+r)&gt;&gt;1; ll lsum=node[y.l].sum-node[x.l].sum; return query(node[x.l],node[y.l],l,mid,ql,ql+lsum-1)+ query(node[x.r],node[y.r],mid+1,r,ql+lsum,qr);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); build(node[0],1,L); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); insert(node[head[i-1]],node[head[i]=++cnt],1,L,a); &#125; for(register int i=1;i&lt;=M;++i)&#123; ll l,r,k; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); printf("%lld\n",query(node[head[l-1]],node[head[r]],1,L,k,k+r-l)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5283异或粽子]]></title>
    <url>%2F2019%2F04%2F09%2Fsolution-luogu-p5283%2F</url>
    <content type="text"><![CDATA[题目链接 分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。 用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus … \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r] \oplus s[l-1]$。 将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。 将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。 在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。 注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。 另外，在将(1&lt;&lt;d)这样的式子转long long时，不能写成(long long)(1&lt;&lt;d)，而是((long long)1&lt;&lt;d)。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int DEP=31;int N,M;ll ans,s[MAXN];struct State&#123; ll val; int r,k; bool operator &lt;(const State&amp; rhs) const &#123;return val&lt;rhs.val;&#125;&#125;;priority_queue&lt;State&gt; q;struct Node&#123; int son[2],sum;&#125;trie[MAXN*(DEP+2)];int head[MAXN],cnt;inline void insert(Node c,Node&amp; u,ll val,int d)&#123; u.sum=c.sum+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; u.son[!x]=c.son[!x]; insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d-1);&#125;inline ll query(Node u,ll val,int d,int k)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; int lsum=trie[u.son[!x]].sum; if(lsum&gt;=k) return ((ll)1&lt;&lt;d)+(ll)query(trie[u.son[!x]],val,d-1,k); return (ll)query(trie[u.son[x]],val,d-1,k-lsum);&#125;int main()&#123; trie[0].son[0]=trie[0].son[1]=trie[0].sum=0; insert(trie[0],trie[head[0]=++cnt],0,DEP); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; ll a; scanf("%lld",&amp;a); s[i]=s[i-1]^a; insert(trie[head[i-1]],trie[head[i]=++cnt],s[i],DEP); q.push((State)&#123;query(trie[head[i-1]],s[i],DEP,1),i,1&#125;); &#125; for(register int i=1;i&lt;=M;++i)&#123; ans+=q.top().val; int r=q.top().r,k=q.top().k; q.pop(); if(k==r) continue; q.push((State)&#123;query(trie[head[r-1]],s[r],DEP,k+1),r,k+1&#125;); &#125; printf("%lld",ans); return 0;&#125; $p.s.$洛谷评测机有点小慢，不开O2会小概率发生TLE QwQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>可持久化trie</tag>
        <tag>异或</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-04-08]]></title>
    <url>%2F2019%2F04%2F08%2Fbulletin-2019-4-8%2F</url>
    <content type="text"><![CDATA[tth37 Blog已经绑定了最新域名：tth37.cn ！(购买自阿里云) 由于一些奇怪的原因（DNS域名解析和CNAME配置问题），我的博客在四月七日至四月八日出现许多异常，现已全部修复。 但在四月九日至四月十日的测试中，我被疯狂打脸；现在已经可以保证，只要在浏览器输入栏输入 tth37.cn，即可自动跳转https://tth37.cn，并在*CloudFlare*证书授权下安全运行。 请大佬们在新域名下体验高速加载和流畅访问新体验吧！ 另外，左侧边栏“日程表”已经启用；网站基本搭建完毕。以后将缩减网站维护时间。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习-可持久化数据结构]]></title>
    <url>%2F2019%2F03%2F29%2Falgorithm-persistentdatastructure%2F</url>
    <content type="text"><![CDATA[概述可持久化数据结构可以存储数据集在任意时间的历史状态。“可持久化”的基本思想是在每项操作结束后，仅创建数据结构中发生改变的部分的副本，不拷贝其他部分。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，可持久化数据结构能够高效地记录一个数据结构的所有历史状态。 可持久化Trie【实现过程】 设当前可持久化Trie的根节点为root，令p=root，i=0 建立一个新的节点，令root‘=q 若p!=0，则对于每种字符c，令trie[q,c]=trie[p,c] 建立一个新的节点q’，令trie[q,s]=q‘ 令p=trie[p,s]，q=trie[q,s]，i=i+1 重复步骤3-5，直到i到达字符串末尾 【例题】最大异或和 luogu-p4735给定一个非负整数序列{a}，初始长度为N。 有M个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。 Q l r x：询问操作，你需要找到一个位置p，满足l≤p≤r，使得： a[p]⊕a[p+1]⊕…⊕a[N]⊕x 最大，输出最大是多少。 【分析】考虑异或前缀和。根据异或运算的性质：$$a[p]\oplus a[p+1]\oplus …\oplus a[N]\oplus x=s[p-1]\oplus s[N]\oplus x$$对于添加操作，序列s很容易维护。对于询问操作，问题变为：已知一个整数val=s[N] xor x，求一个位置p，满足l-1&lt;=p&lt;=r-1，使得s[p] xor val最大。显然可以将s数组插入可持久化Trie中，每次取出在l与r范围内的数据进行贪心（尽量往相反的节点走），从而求出答案。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC optimize(3)//QwQ#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=600005;const int DEP=24;int N,M;int trie[MAXN*26][2],sum[MAXN*26];int head[MAXN],cnt=1;int s[MAXN];inline void insert(int c,int u,int val,int d)&#123; sum[u]=sum[c]+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; trie[u][!x]=trie[c][!x]; insert(trie[c][x],trie[u][x]=++cnt,val,d-1);&#125;inline int query(int c,int u,int val,int d)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; if(sum[trie[u][!x]]&gt;sum[trie[c][!x]]) return (1&lt;&lt;d)+query(trie[c][!x],trie[u][!x],val,d-1); else return query(trie[c][x],trie[u][x],val,d-1);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); insert(0,0,0,DEP); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); s[i]=s[i-1]^a; insert(head[i-1],head[i]=++cnt,s[i],DEP); &#125; for(register int i=1;i&lt;=M;++i)&#123; char opt; getchar(),opt=getchar(); if(opt=='A')&#123; int a; scanf("%d",&amp;a); N++; s[N]=s[N-1]^a; insert(head[N-1],head[N]=++cnt,s[N],DEP); &#125; else&#123; int l,r,a; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); if(l==r) printf("%d\n",s[l-1]^s[N]^a); else printf("%d\n",query(head[l-2],head[r-1],a^s[N],DEP)); &#125; &#125; return 0;&#125; 可持久化数组【例题】【模板】可持久化数组 luogu-p3919如题，你需要维护这样的一个长度为 N 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 【分析】在原数组上建立线段树，在叶子节点上记录原数组数值。执行完修改操作后，根据可持久化的思想，只需更改一条链上的节点信息；执行完访问操作后，则可以将目前操作的根节点指针指向被查询的历史状态根节点。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;struct Node&#123; int l,r,val;&#125;node[MAXN*22+5];int N,M,cnt;int a[MAXN],head[MAXN];inline void build(Node&amp; u,int l,int r)&#123; if(l==r)&#123; u.val=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void change(Node c,Node&amp; u,int l,int r,int p,int val)&#123; if(l==r)&#123; u.val=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)&#123; change(node[c.l],node[u.l=++cnt],l,mid,p,val); u.r=c.r; &#125; else&#123; change(node[c.r],node[u.r=++cnt],mid+1,r,p,val); u.l=c.l; &#125;&#125;inline int query(Node u,int l,int r,int p)&#123; if(l==r) return u.val; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) return query(node[u.l],l,mid,p); else return query(node[u.r],mid+1,r,p);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) scanf("%d",&amp;a[i]); build(node[0],1,N); for(register int i=1;i&lt;=M;++i)&#123; int v,opt,p,val; scanf("%d%d",&amp;v,&amp;opt); if(opt==1)&#123; scanf("%d%d",&amp;p,&amp;val); change(node[head[v]],node[head[i]=++cnt],1,N,p,val); &#125; else&#123; scanf("%d",&amp;p); head[i]=head[v]; printf("%d\n",query(node[head[i]],1,N,p)); &#125; &#125; return 0;&#125; 可持久化值域线段树（主席树）【例题】【模板】可持久化线段树 luogu-p3834给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。 【分析】值域有负数出现，考虑离散化。假设离散化后的值域为[1,L]。 在值域上建立线段树，每个节点上存储该值域内有多少个数据。对线段树进行可持久化处理，与上一题可持久化数组实现方式类似。 在查询时，如果一个节点的左子节点上的cnt值小于等于正在查询的K，则问题转化为求左半区间内第K小值；否则，转化为求右半区间内第K-cnt小值。 查询时的操作类似于在值域上的二分，因此复杂度在log级别。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN=200005;struct Node&#123; int l,r,sum;&#125;node[MAXN&lt;&lt;6];int N,M,L,cnt;int a[MAXN],b[MAXN];int head[MAXN];inline void build(Node u,int l,int r)&#123; u.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],1,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l;&#125;inline int query(Node c,Node u,int l,int r,int k)&#123; if(l==r) return l; int sum=node[u.l].sum-node[c.l].sum,mid=(l+r)&gt;&gt;1; if(sum&gt;=k) return query(node[c.l],node[u.l],1,mid,k); else return query(node[c.r],node[u.r],mid+1,r,k-sum);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+N+1); L=unique(b+1,b+N+1)-(b+1); head[0]=0; build(node[0],1,L); for(register int i=1;i&lt;=N;++i) insert(node[head[i-1]],node[head[i]=++cnt],1,L,id(i)); for(register int i=1;i&lt;=M;++i)&#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",rid(query(node[head[l-1]],node[head[r]],1,L,k))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化trie</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4516潜入行动]]></title>
    <url>%2F2019%2F03%2F28%2Fsolution-luogu-p4516%2F</url>
    <content type="text"><![CDATA[这是一个并不简单的背包类树形dp…… 很自然地想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。 状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是： $$f[u][i+j]=combine(f[u][i],f[v][j])$$ 相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为： $$f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]$$ $$f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])$$ $$f[u][i+j][0][1]=\sum (f[u][i][0][1]*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]*f[v][j][1][1]$$ $$f[u][i+j][1][1]=\sum (f[u][i][1][0]*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))$$ 具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100005;const int mod=1000000007;int N,K;int f[MAXN][105][2][2];int g[105][2][2];int size[MAXN];vector&lt;int&gt; G[MAXN];inline int Mod(ll x,ll y)&#123; x%=mod,y%=mod; return (int)(x+y)%mod;&#125;void dp(int u,int fa)&#123; size[u]=1; f[u][0][0][0]=f[u][1][1][0]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(v,u); for(register int i=0;i&lt;=min(size[u],K);++i)&#123; g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0; g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0; g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0; g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0; &#125; for(register int i=0;i&lt;=min(size[u],K);++i)&#123; for(register int j=0;j&lt;=min(size[v],K-i);++j)&#123; f[u][i+j][0][0]=Mod((ll)f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]); f[u][i+j][0][1]=Mod((ll)f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*((ll)f[v][j][1][1]+(ll)f[v][j][0][1])); f[u][i+j][1][0]=Mod((ll)f[u][i+j][1][0],(ll)g[i][1][0]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1])); f[u][i+j][1][1]=Mod((ll)f[u][i+j][1][1],(ll)g[i][1][0]*((ll)f[v][j][1][0]+(ll)f[v][j][1][1])+(ll)g[i][1][1]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]+(ll)f[v][j][1][0]+(ll)f[v][j][1][1])); &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1,0); printf("%d",(int)(f[1][K][0][1]+f[1][K][1][1])%mod); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-背包类树形dp]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-knapsacktreedp%2F</url>
    <content type="text"><![CDATA[树形分组背包【例题】 选课 *luogu-p2014 *在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 【分析】记录状态：$f[u][i]$为以$u$为根的子树上，选择$i$门课所能获得的最大学分。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。那么在$u$上相当于有一个容量为$M$的背包，每个子树中不同的状态相当于不同的物品，例如$f[v][j]$为体积为$j$，价值为$f[v][j]$中存储的数值。 在本题中，由于所有关系构成森林结构，因此可以设$0$号结点为“没有先修课”的课的先修课。然后以$0$为根，进行状态转移即可。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define Pb push_backconst int MAXN=305;const int MAXM=305;int N,M;vector&lt;int&gt; son[MAXN];int a[MAXN],f[MAXN][MAXM];inline void dp(int u)&#123; for(vector&lt;int&gt;::iterator it=son[u].begin();it!=son[u].end();it++) &#123; int v=*it; dp(v); for(register int i=M;i&gt;=0;--i) for(register int j=0;j&lt;=i;++j) f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]); &#125; if(u) &#123; for(register int i=M;i&gt;=1;--i) f[u][i]=f[u][i-1]+a[u]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) &#123; int k,s; scanf("%d%d",&amp;k,&amp;s); son[k].Pb(i);a[i]=s; &#125; dp(0); printf("%d",f[0][M]); return 0;&#125; 【例题】有线电视网 luogu-p1273某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 【分析】记录状态：$f[i][j]$为以$i$为根，选择$j$个用户最多有多少收入。状态转移时如果无法从正面入手（如本题不知道价格的最值，且价值分布更为稀疏），可以从反面设计状态，在输出答案时进行判断即可。转移时可以记录$size$数组进行优化。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125; 组合计数类树形背包【例题】树的独立集 （原创）给定一棵有$N$个结点的树，输出这棵树中包含$K$个结点的独立集个数。 【分析】有关组合计数的背包类树形dp问题，一般均可用以下方式解决。 记录状态：$f[u][k][0/1]$ 为以$u$为根的子树，$u$的状态为选或不选，共选择$k$个结点时独立集的个数。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。每递归访问结束一个子结点，就考虑把该子结点的状态与已经处理一部分的当前结点状态相匹配。每访问完一个结点，就把配对后产生的状态归为已处理的状态。由于需要根据之前的状态推导后续状态，因此不难看出利用到背包的思想。 状态转移方程的基本思想如下： $$f[u][i+j][(state)]=combine(f[u][i][(state)]*f[u][j][(state)])$$ 本题的状态转移方程也不难推出： $$f[u][0][i+j]=\sum f[u][0][i]*(f[v][0][j]+f[v][1][j])$$ $$f[u][1][i+j]=\sum f[u][1][i]*f[v][0][j]$$ 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10005;int N,K;vector&lt;int&gt; G[MAXN];int f[MAXN][105][2];int g[105][2];int size[MAXN];void dp(int fa,int u)&#123; size[u]=1; f[u][0][0]=1,f[u][1][1]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(u,v); for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; g[i][0]=f[u][i][0],f[u][i][0]=0; g[i][1]=f[u][i][1],f[u][i][1]=0; &#125; for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; for(register int j=0;j&lt;=min(K-i,size[v]);++j)&#123; f[u][i+j][0]+=g[i][0]*(f[v][j][0]+f[v][j][1]); f[u][i+j][1]+=g[i][1]*f[v][j][0]; &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(0,1); printf("%d",f[1][K][0]+f[1][K][1]); return 0;&#125; 习题潜入行动 未完待续~]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2774方格取数问题]]></title>
    <url>%2F2019%2F03%2F24%2Fsolution-luogu-p2774%2F</url>
    <content type="text"><![CDATA[题目链接 不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。 首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。 源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。 如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。 问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAXN=100005;int N,M,S,T;ll sum;int nx[]=&#123;0,1,0,-1&#125;;int ny[]=&#123;1,0,-1,0&#125;;struct Edge&#123; int v,w,nxt;&#125;mem[MAXN];int head[MAXN],cnt=1;inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].w=w; mem[cnt].v=v; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int d[MAXN];bool vis[MAXN];inline bool bfs()&#123; memset(vis,0,sizeof(vis)); vis[S]=1;d[S]=0; queue&lt;int&gt; q; q.push(S); while(q.size())&#123; int u=q.front();q.pop(); for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(vis[v]||(w==0)) continue; vis[v]=1;d[v]=d[u]+1; q.push(v); &#125; &#125; return vis[T];&#125;inline int dfs(int u,int flow)&#123; if(u==T) return flow; int rflow; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(w==0||d[u]+1!=d[v]) continue; if(rflow=dfs(v,min(flow,w)))&#123; mem[i].w-=rflow; mem[i^1].w+=rflow; return rflow; &#125; &#125; return 0;&#125;inline int Dinic()&#123; int maxflow=0,lowflow; while(bfs())&#123; while(lowflow=dfs(S,INF)) maxflow+=lowflow; &#125; return maxflow;&#125;int main()&#123; scanf("%d%d",&amp;M,&amp;N); S=0,T=M*N+1; for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125; printf("%lld",sum-Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目列表-网络流]]></title>
    <url>%2F2019%2F03%2F24%2Flist-networkflow%2F</url>
    <content type="text"><![CDATA[方格取数问题（二分图+建模技巧）将原图黑白染色，并保证产生矛盾的两个位置颜色不同。源点连接黑点，白点连接汇点，黑点连接与之产生矛盾的白点。通过 最大和=全局和-最小割，在建立的网络上跑最小割（最大流）即可。 123456789101112131415161718192021for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125;]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-03-24]]></title>
    <url>%2F2019%2F03%2F24%2Fbulletin-2019-3-24%2F</url>
    <content type="text"><![CDATA[2019/3/24，tth37搭建了这个github博客。 tth37希望在这个博客里记录一些自己学习OI的心得，并发布一些题解，贴出学习规划。 但tth37实在是太弱了，因此他会更新得十分缓慢。 另外，还请shiwt巨佬多多指教。 任何一个伟大的思想，都有一个微不足道的开始。 p.s. 可能会将洛谷博客上的文章搬运过来，所以有些文章的发布时间可能在此之前，请别见怪。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题目列表-动态规划]]></title>
    <url>%2F2019%2F03%2F20%2Flist-dp%2F</url>
    <content type="text"><![CDATA[任务安排（斜率优化+费用提前计算）$$f[i]=min_{0\le j&lt;i}{f[j]-(S+T[i])*C[i]+T[i]*C[i]+S*C[N]}$$ 特别行动队（斜率优化）$$f[i]=max_{0\le j&lt;i}{f[j]+A*(S[i]-S[j])^2+B*(S[i]-S[j])+C}$$ 玩具装箱（斜率优化）$$f[i]=min_{0\le j&lt;i}{f[j]+(A[i]-A[j]-L-1)^2}$$斜率优化的适用范围是只有一个自变量。 形如这样的转移方程：$$f[i]=min_{0\le j&lt;i}{f[j]+(i-j+S[i]-S[j]-L-1)^2}$$ 操作难度较大，可以将$S[i]+i$存在$A$数组中，即可全部化为一个自变量。 锯木厂选址（斜率优化）$$f[i]=min_{1\le j&lt;i}{C[i-1]-W[j]*(D[i]-D[j])}$$ 打印文章（斜率优化）$$f[i]=min_{0\le j&lt;i}{f[j]+(S[i]-S[j])^2+M}$$调到心态爆炸……getK函数中如果除数为0则要返回1e100 序列分割（斜率优化）$$f[i][j]=max_{0 \le k&lt;j}{f[i-1][k]+S[k]*(S[j]-S[k])}$$不开long long见祖宗。题目中如果说“非负整数”一定记得判断除数是否为0。 对于转移方程中的第一维，稍加观察就会发现可以使用滚动数组。（虽然也需要一些额外的数组记录状态） 绿色通道（二分答案+单调队列）$$f[i]=min_{i-M-1 \le j &lt;i}{f[j]+a[i]}$$ 二分发怒程度$M$，$f$数组中存储选择当前题目最少多少体力。统计最终答案只需检验最后$M$个状态即可。 12int ans=INF;for(register int i=N-M;i&lt;=N;++i) ans=min(ans,f[i]); 股票交易（单调队列+很多条件）$$f[i][j]=-AP[i]*j(0 \le j \le AS[i])$$ $$f[i][j]=max{f[i][j],f[i-1][j]}(0 \le j \le M)$$ $$f[i][j]=max_{j-AS[i] \le k&lt;j}{f[i-W-1][k]-(j-k)*AP[i]}(0 \le j \le M)$$ $$f[i][j]=max_{j&lt;k \le j+BS[i]}{f[i-W-1][k]+(k-j)*BP[i]}(0 \le j \le M)$$条件特别多，需要仔细分析题意并且列出状态转移方程。先进行较简单的转移，再利用单调队列进行复杂转移。注意第四种状态转移要使用逆序循环。 如此恶心的状态转移让我不禁想起飞扬的小鸟 潜入行动（背包类树形dp）$$f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]$$ $$f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])$$ $$f[u][i+j][0][1]=\sum (f[u][i][0][1]*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]*f[v][j][1][1]$$ $$f[u][i+j][1][1]=\sum (f[u][i][1][0]*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))$$ 题解链接 特别注意空间问题，中间运算转long long，保存时再转int 子串（线性dp+滚动数组）$$f[i][0][0][0]=1$$ $$f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][k][1]$$ $$a[i]=b[j]:f[i][j][k][1]=f[i-1][j-1][k][1]+f[i-1][j-1][k-1][0]+f[i-1][j-1][k-1][1]$$ $$a[i] \ne b[j]:f[i][j][k][1]=0$$ 滚动数组注意点： 状态转移方程只依赖前一维或前两维状态 状态数组要被滚动的一维只开1或2 对于0/1滚动数组，可以结合位运算&amp;和^进行判断奇偶性和减一操作 换教室（期望dp）$$f[i][j][0]=min{f[i-1][j][0]+dis[C[i-1]][C[i]],f[i-1][j][1]+K[i-1]*dis[D[i-1]][C[i]]+(1-K[i-1])*dis[C[i-1]][C[i]]}$$ $$f[i][j][1]=min{f[i-1][j-1][0]+K[i]*dis[C[i-1]][D[i]]+(1-K[i])*dis[C[i-1]][C[i]],f[i-1][j-1][1]+K[i-1]*K[i]*dis[D[i-1]][D[i]]+K[i-1]*(1-K[i])*dis[D[i-1]][C[i]]+(1-K[i-1])*K[i]*dis[C[i-1]][D[i]]+(1-K[i-1])*(1-K[i])*dis[C[i-1]][C[i]]}$$ 期望dp可以单独开一维表示状态，以便于列举出所有情况。本题的转移方程是一个很好的例子。如果tth37开心的话，Ta可能会写一篇数学期望专题具体讲解此类题目。 过河（线性dp+玄学离散化）$$f[i]=min_{S \le j \le T}{f[i-j]+flag[i]}$$ 由于m非常小，因此采用2520缩点，即两点之间距离超过2520的，可以将距离改为$dis % 2520$，从而离散化。 统计单词个数（线性dp+字符串）$$f[i][j]=max{f[i][j],f[r][j-1]+g[r+1][i]}$$ 字符串处理使用string类find函数。 线性dp时再次强调，需要分清阶段、状态和决策变量；阶段在最外层循环，决策在最内层。在寻找关系时可以从推导或定义角度辨析，也可以根据转移方程进行识别。 有线电视网（背包类树形dp）$$f[u][i]=max_{v\in son(u)}{f[u][i-j]+f[v][j]-w}$$题解链接 棋盘制作（单调栈）似乎没有转移方程 注意单调栈的处理方式（玄学方法或通用方法），在退栈时务必退干净。 12345678910//玄学方法：for(register int i=1;i&lt;=N+1;++i)&#123; while(cnt&gt;0&amp;&amp;a[s[cnt]]&gt;=a[i])&#123; ans=max(ans,(i-s[cnt-1]-1)*a[s[cnt]]); cnt--; &#125; s[++cnt]=i;&#125;//通用方法：先处理出每个位置左边第一个比它小的，再处理出右边第一个比它小的，最后枚举]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1080国王游戏]]></title>
    <url>%2F2019%2F01%2F26%2Fsolution-luogu-p1080%2F</url>
    <content type="text"><![CDATA[题目链接 高精度怎能少了Python3题解。。。 贪心策略一楼dalao已经讲得很清楚了，上一发超短代码（学Python就是为了水高精） 123456789101112131415N=int(input())s=input().split()S=int(s[0])T=int(s[1])a=[]for i in range(1,N+1): k=input().split() a.append((int(k[0]),int(k[1])))a.sort(key=lambda x:x[0]*x[1])ans=0for i in range(0,N): if(S//(a[i])[1]&gt;ans): ans=S//(a[i])[1] S*=(a[i])[0]print(ans)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1022计算器的改良]]></title>
    <url>%2F2018%2F12%2F19%2Fsolution-luogu-p1022%2F</url>
    <content type="text"><![CDATA[题目链接 本题是一道非常漂亮的模拟。只要能理清思路，代码并不会特别复杂。 首先分析题目。解一元一次方程最简单的方法就是移项，把常数移到等号右侧，把一次项系数移到等号左侧，用常数除以系数即为答案。那么在读入字符串的过程中，便可以进行操作。 对于字符串中的数据，我们可以用类似快读的方法读入。然而，要判断这些数据从哪里来，到哪里去，便是本题的关键所在。 对于每个数据，要想清楚地辨别它的身份，我们只需解决三个问题： 1.该数据是正数还是负数？ 3.该数据在等号左侧还是在等号右侧？ 2.该数据是常数还是系数？ 第一个问题看似十分无脑，用一个变量f1来存储符号即可（将f1赋值为1或-1，在读入数据结束时将得到的数据乘以f1）。但需特别注意，在一个表达式的开头（等号左侧和等号右侧的表达式）不会有‘+’、‘-’符号，所以在程序的开头和读入‘=’号是，要将f1赋值为1。 第二个问题也非常简单，可以用变量f2来存储。因为这个问题与移项运算的符号有关，因此也可以将f2赋值为1或-1，并约定在等号左侧时f2为1，在等号右侧时f2为-1。（当然你也可以反着约定） 第三个问题同样不难解决。在读入数据结束后（即读入了一个符号），判断这个符号是运算符还是字母即可。如果是字母，则将得到的数据移到等号右侧，否则将数据移到等号左侧。但是还有一个注意点：如果一个未知数的系数为1，我们会将系数省略。因此在读入数据为0时，我们要将其更改为1。 经过分析，你会发现本题一点也不难实现。其关键在于对数据状态的准确描述。用清晰、简洁的变量描述状态，根据不同的状态采取不同的措施，这便是编程学习的一大基本素养。 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int l,r;//l代表系数，r代表常数 char x; //用x存储字母 void solve()&#123; char c; int f1=1,f2=1,tmp=0; while(~scanf("%c",&amp;c)) &#123; if(c&gt;='0'&amp;&amp;c&lt;='9')//类似快读的读入方式 &#123; tmp*=10; tmp+=c-'0'; &#125; else &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') l+=(tmp==0)?f2*f1:tmp*f2*f1,x=c;//判断系数是否为1 else r+=tmp*(-f2)*f1; tmp=0; &#125; if(c=='+') &#123;f1=1;continue;&#125; if(c=='-') &#123;f1=-1;continue;&#125; if(c=='=') &#123;f2=-1;f1=1;continue;&#125; &#125;&#125;int main()&#123; solve(); printf("%c=%0.3f",x,(float)r/l==0?abs((float)r/l):(float)r/l); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1204挤牛奶]]></title>
    <url>%2F2018%2F12%2F15%2Fsolution-luogu-p1204%2F</url>
    <content type="text"><![CDATA[题目链接 介绍一种本题的贪心解法。 本题要求读入一些挤牛奶的时间段，求最长至少有一人在挤牛奶的时间段和最长没有人在挤牛奶的时间段。把读入的区间视作线段，则题意转变为求至少有一条线段覆盖的最大区间和没有线段覆盖的区间。 假设读入数据如下： 首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。 然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。 程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。 程序如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int N; struct node&#123; int begin,end;&#125;m[5005];bool cmp(node a,node b)&#123; return a.begin&lt;b.begin;&#125;int main()&#123; scanf("%d",&amp;N); for(register int i=1;i&lt;=N;++i) scanf("%d%d",&amp;m[i].begin,&amp;m[i].end); sort(m+1,m+1+N,cmp); int begin=m[1].begin; int end=m[1].end; int ans1=0,ans2=0; for(register int i=2;i&lt;=N;++i)&#123; if(m[i].begin&lt;=end) end=max(end,m[i].end); else&#123; ans1=max(ans1,end-begin); ans2=max(ans2,m[i].begin-end); begin=m[i].begin; end=m[i].end; &#125; &#125; ans1=max(ans1,end-begin); printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
