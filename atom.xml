<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tth37&#39;s Blog</title>
  
  <subtitle>Think twice, Code once</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tth37.cn/"/>
  <updated>2020-01-21T16:51:13.432Z</updated>
  <id>https://tth37.cn/</id>
  
  <author>
    <name>tth37</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「SNOI2019」纸牌</title>
    <link href="https://tth37.cn/2020/01/21/solution-loj-3098/"/>
    <id>https://tth37.cn/2020/01/21/solution-loj-3098/</id>
    <published>2020-01-21T15:12:20.000Z</published>
    <updated>2020-01-21T16:51:13.432Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3098" target="_blank" rel="noopener">#3098. 「SNOI2019」纸牌</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>有一副纸牌，牌一共有 $n$ 种，每种有 $C$ 张。三张连号的牌或三张相同的牌可以组成一叠，如果一组拍可以分成若干叠，就称其为一组王牌。现已从牌堆摸了一些初始牌，需要再挑出一些牌组成一组王牌，求有多少种可能组成的王牌。</p><p>$1\le n \le 1e18,0\le C \le 1000$</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>麻将题这种套路我真不明白是怎么想出来的…… 总之能用就行了。</p><p>记 $f[i][a][b]$ 表示仅考虑前 $i$ 种牌，选了 $a$ 叠 $(i-1,i,i+1)$ 和 $b$ 叠 $(i,i+1,i+2)$ 的方案数。不难发现 $a$ 和 $b$ 均不超过 $3$，否则会有重复。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][b][c] = f[i - 1][a][b]\times (\lfloor\frac{C-s-\lceil d[i]-s\rceil}{3}\rfloor+1)</script><p>将状态的后两维压至一维，即可矩阵大力转移。对于特殊点构造转移矩阵即可。</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>动态规划转移前的可行性判断。</p><p>矩阵操作前（乘法、初始化单位矩阵）不要忘记清零！</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> m, n;</span><br><span class="line">    <span class="hljs-keyword">int</span> g[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">Matrix <span class="hljs-title">mul</span><span class="hljs-params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    c.m = a.m, c.n = b.n;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.m; ++i)</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c.n; ++j) &#123;</span><br><span class="line">            c.g[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; a.n; ++k)</span><br><span class="line">                c.g[i][j] = (c.g[i][j] + <span class="hljs-number">1l</span>l * a.g[i][k] * b.g[k][j] % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="hljs-keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="hljs-keyword">int</span> C, x;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mk</span><span class="hljs-params">(Matrix&amp; a)</span> </span>&#123;</span><br><span class="line">    a.m = a.n = <span class="hljs-number">9</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j)</span><br><span class="line">            a.g[i][j] = i == j ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">Matrix <span class="hljs-title">qpow</span><span class="hljs-params">(Matrix a, ll n)</span> </span>&#123;</span><br><span class="line">    Matrix ret;</span><br><span class="line">    mk(ret);</span><br><span class="line">    <span class="hljs-keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) ret = mul(ret, a);</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">        n &gt;&gt;= <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    Matrix X;</span><br><span class="line">    X.m = <span class="hljs-number">9</span>, X.n = <span class="hljs-number">1</span>;</span><br><span class="line">    X.g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">9</span>; ++i)</span><br><span class="line">        X.g[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">    Matrix F;</span><br><span class="line">    F.m = F.n = <span class="hljs-number">9</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j)</span><br><span class="line">            F.g[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; b &lt;= <span class="hljs-number">2</span>; ++b)</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt;= <span class="hljs-number">2</span>; ++c)</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt;= <span class="hljs-number">2</span>; ++a) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> s = a + b + c;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (C &lt; s) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                    F.g[a * <span class="hljs-number">3</span> + b][b * <span class="hljs-number">3</span> + c] = (C - s) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;x);</span><br><span class="line">    ll cur = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>; t &lt;= x; ++t) &#123;</span><br><span class="line">        ll p;</span><br><span class="line">        <span class="hljs-keyword">int</span> d;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%d"</span>, &amp;p, &amp;d);</span><br><span class="line">        X = mul(qpow(F, p - cur - <span class="hljs-number">1</span>), X);</span><br><span class="line">        Matrix G;</span><br><span class="line">        G.m = G.n = <span class="hljs-number">9</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j)</span><br><span class="line">                G.g[i][j] = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; b &lt;= <span class="hljs-number">2</span>; ++b)</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt;= <span class="hljs-number">2</span>; ++c) </span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt;= <span class="hljs-number">2</span>; ++a) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> s = a + b + c;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (C &lt; s) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                    <span class="hljs-keyword">int</span> cer = <span class="hljs-number">0</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (d &lt;= s) cer = s;</span><br><span class="line">                    <span class="hljs-keyword">else</span> cer = s + <span class="hljs-number">3</span> * ((d - s + <span class="hljs-number">2</span>) / <span class="hljs-number">3</span>);</span><br><span class="line">                    <span class="hljs-keyword">if</span> (C &lt; cer) <span class="hljs-keyword">continue</span>;</span><br><span class="line">                    G.g[a * <span class="hljs-number">3</span> + b][b * <span class="hljs-number">3</span> + c] = (C - cer) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        X = mul(G, X);</span><br><span class="line">        cur = p;</span><br><span class="line">    &#125;</span><br><span class="line">    X = mul(qpow(F, n - cur), X);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, X.g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3098. 「SNOI2019」纸牌&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;有一副纸牌，牌一共有 $n$ 种，每种有 $C$ 张。三张连号的牌或三张相同的牌可以组成一叠，如果一组拍可以分成若干叠，就称其为一组王牌。现已从牌堆摸了一些初始牌，需要再挑出一些牌组成一组王牌，求有多少种可能组成的王牌。&lt;/p&gt;
&lt;p&gt;$1\le n \le 1e18,0\le C \le 1000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="矩阵" scheme="https://tth37.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>「HNOI2019」校园旅行</title>
    <link href="https://tth37.cn/2020/01/21/solution-loj-3057/"/>
    <id>https://tth37.cn/2020/01/21/solution-loj-3057/</id>
    <published>2020-01-21T09:33:56.000Z</published>
    <updated>2020-01-21T10:07:28.060Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3057" target="_blank" rel="noopener">#3057. 「HNOI2019」校园旅行</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给定一个有 $n$ 个节点、 $m$ 条边的简单无向图，每个节点有权值 $0$ 或 $1$。有 $q$ 次询问，每次询问两个节点 $u$、$v$ 间是否存在一条路径（可重复），使经过的节点权值为 $01$ 回文串。</p><p>$n \le 5000, m\le 500000, q\le 100000$</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>考虑动态规划，记 $f[i][j]$ 表示 $i$、$j$ 两点是否存在回文路径。若 $f[x][y]=1,(x,z)\in E,(y,w)\in E,a[z]=a[w]$，则 $f[z][w]=1$。转移时枚举边转移，时间复杂度 $O(m^2)$。</p><p>考虑优化，仅保留等效边。只考虑 <strong>连接两个权值相同节点的边</strong> ，可以发现这些边将原图分为若干个连通块。假如只在其中一个联通块中状态转移，其转移方法取决于 <strong>该联通块是否为二分图</strong>。若是二分图，则连通块内 <strong>任意两点间路径长度的奇偶性确定</strong>；否则不确定。因此，可以将二分图等效为该图的 <strong>生成树</strong>，恰好同样符合上述性质；如果不是二分图，则在生成树中添加一个自环即可。</p><p>对于 <strong>连接两个不同权值节点的边</strong>，在任意连通块中显然可以得到其生成树与原图的性质相同。</p><p>因此可以将边数降至 $O(n)$ 级别，就可做了。</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>不知道为什么记忆化搜索写挂了，查不出错。<a href="https://loj.ac/submission/727560" target="_blank" rel="noopener">0/30 pts code</a></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> s[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> n, m, q;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G0[MAXN], G1[MAXN], G[MAXN];</span><br><span class="line"><span class="hljs-keyword">bool</span> vis0[MAXN], vis1[MAXN];</span><br><span class="line"><span class="hljs-keyword">bool</span> vis2[MAXN], vis3[MAXN];</span><br><span class="line"><span class="hljs-keyword">bool</span> col[MAXN];</span><br><span class="line"><span class="hljs-keyword">bool</span> flag;</span><br><span class="line"><span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; qu;</span><br><span class="line"><span class="hljs-keyword">bool</span> vis[MAXN][MAXN], f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_ck0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis1[u] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G0[u]) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis1[v] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">col[v] = col[u] ^ <span class="hljs-number">1</span>;</span><br><span class="line">dfs_ck0(v);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (col[v] == col[u]) flag = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_gen0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis0[u] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G0[u])</span><br><span class="line"><span class="hljs-keyword">if</span> (vis0[v] == <span class="hljs-number">0</span>)</span><br><span class="line">G[u].push_back(v), G[v].push_back(u), dfs_gen0(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_ck1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis3[u] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G1[u]) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis3[v] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">col[v] = col[u] ^ <span class="hljs-number">1</span>;</span><br><span class="line">dfs_ck1(v);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (col[v] == col[u]) flag = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs_gen1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vis2[u] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G1[u])</span><br><span class="line"><span class="hljs-keyword">if</span> (vis2[v] == <span class="hljs-number">0</span>)</span><br><span class="line">G[u].push_back(v), G[v].push_back(u), dfs_gen1(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s + <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> u, v;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="hljs-keyword">if</span> (s[u] == s[v]) </span><br><span class="line">G0[u].push_back(v), G0[v].push_back(u);</span><br><span class="line"><span class="hljs-keyword">else</span> </span><br><span class="line">G1[u].push_back(v), G1[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis0[i]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">flag = <span class="hljs-number">1</span>;</span><br><span class="line">dfs_ck0(i);</span><br><span class="line">dfs_gen0(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) G[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">memset</span>(col, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(col));</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis2[i]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">flag = <span class="hljs-number">1</span>;</span><br><span class="line">dfs_ck1(i);</span><br><span class="line">dfs_gen1(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) G[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">qu.push(make_pair(i, i));</span><br><span class="line">vis[i][i] = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[u]) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (s[u] == s[v]) </span><br><span class="line">qu.push(make_pair(u, v)), vis[u][v] = vis[v][u] = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (qu.size()) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x = qu.front().first, y = qu.front().second;</span><br><span class="line">qu.pop();</span><br><span class="line">f[x][y] = f[y][x] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> z : G[x]) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> w : G[y]) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (s[z] == s[w] &amp;&amp; vis[z][w] == <span class="hljs-number">0</span>)</span><br><span class="line">qu.push(make_pair(z, w)), vis[z][w] = vis[w][z] = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> a, b;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="hljs-keyword">if</span> (f[a][b]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"YES"</span>);</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3057&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3057. 「HNOI2019」校园旅行&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给定一个有 $n$ 个节点、 $m$ 条边的简单无向图，每个节点有权值 $0$ 或 $1$。有 $q$ 次询问，每次询问两个节点 $u$、$v$ 间是否存在一条路径（可重复），使经过的节点权值为 $01$ 回文串。&lt;/p&gt;
&lt;p&gt;$n \le 5000, m\le 500000, q\le 100000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分图" scheme="https://tth37.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>生成树计数</title>
    <link href="https://tth37.cn/2020/01/20/algorithm-gentree/"/>
    <id>https://tth37.cn/2020/01/20/algorithm-gentree/</id>
    <published>2020-01-20T09:16:31.000Z</published>
    <updated>2020-01-20T09:37:45.480Z</updated>
    
    <content type="html"><![CDATA[<p>这里好像得写点什么…… oy 快帮我出出主意</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>定义：一个方阵的行列式表示为 $|A|$</p><script type="math/tex; mode=display">|A|=\sum_{p}(-1)^{\sigma(p)}\prod_{i=1}^na_i,p_i</script><script type="math/tex; mode=display">\left|\begin{array}{cccc}     a_{11} &    a_{12}     \\     a_{21} &    a_{22}  \end{array}\right| =a_{11}a_{22}-a_{12}a_{21}</script><h3 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h3><p>大雾 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里好像得写点什么…… oy 快帮我出出主意&lt;/p&gt;
&lt;h3 id=&quot;行列式&quot;&gt;&lt;a href=&quot;#行列式&quot; class=&quot;headerlink&quot; title=&quot;行列式&quot;&gt;&lt;/a&gt;行列式&lt;/h3&gt;&lt;p&gt;定义：一个方阵的行列式表示为 $|A|$&lt;/p&gt;
&lt;script typ
      
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
    
      <category term="生成树" scheme="https://tth37.cn/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「SNOI2019」字符串</title>
    <link href="https://tth37.cn/2020/01/20/solution-loj-3095/"/>
    <id>https://tth37.cn/2020/01/20/solution-loj-3095/</id>
    <published>2020-01-19T16:10:55.000Z</published>
    <updated>2020-01-21T10:08:48.449Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3095" target="_blank" rel="noopener">#3095. 「SNOI2019」字符串</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给出一个长度为 $n$的由小写字母组成的字符串 ，设其中第$i$ 个字符为 $a_i$。设删掉第 $i$个字符之后得到的字符串为$s _i$ ，请按照字典序对 $s_1$,…，$s_n$从小到大输出编号。若两个字符串相等，则认为编号小的字符串字典序更小。</p><p>$1 \le n \le 10^5$</p><p>感谢@oy的贡献</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>考虑字符串 $s_i$ 与 $s_j$ 的比较。根据等效分析，可知比较这两个字符串的大小只需知道任意两个相邻后缀的 $\text{LCP}$ 即可。可以通过 $O(n)$ 预处理后，手写排序 $\text{cmp}$ 函数，$O(n\log n)$ 排序得到答案。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-keyword">char</span> s[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> lcp[MAXN];  <span class="hljs-comment">// lcp(i, i+1)</span></span><br><span class="line"><span class="hljs-keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i = x, j = y;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i &gt; j)</span><br><span class="line">        swap(i, j);</span><br><span class="line">    <span class="hljs-keyword">int</span> t = lcp[i];</span><br><span class="line">    <span class="hljs-keyword">if</span> (t &gt;= j - i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (x &lt; y)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s[i + t + <span class="hljs-number">1</span>] &lt; s[i + t]) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (i == x)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i == x)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s + <span class="hljs-number">1</span>);</span><br><span class="line">    lcp[n] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s[i] == s[i + <span class="hljs-number">1</span>])</span><br><span class="line">            lcp[i] = lcp[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            lcp[i] = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans[i] = i;</span><br><span class="line">    sort(ans + <span class="hljs-number">1</span>, ans + n + <span class="hljs-number">1</span>, cmp);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3095&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3095. 「SNOI2019」字符串&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给出一个长度为 $n$的由小写字母组成的字符串 ，设其中第$i$ 个字符为 $a_i$。设删掉第 $i$个字符之后得到的字符串为$s _i$ ，请按照字典序对 $s_1$,…，$s_n$从小到大输出编号。若两个字符串相等，则认为编号小的字符串字典序更小。&lt;/p&gt;
&lt;p&gt;$1 \le n \le 10^5$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="字符串" scheme="https://tth37.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>「USACO 2019.12 Platinum」Bessie&#39;s Snow Cow</title>
    <link href="https://tth37.cn/2020/01/20/solution-loj-3227/"/>
    <id>https://tth37.cn/2020/01/20/solution-loj-3227/</id>
    <published>2020-01-19T16:06:20.000Z</published>
    <updated>2020-01-21T10:09:44.760Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3227" target="_blank" rel="noopener">#3227. 「USACO 2019.12 Platinum」Bessie’s Snow Cow</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给定$n$个节点的一棵有根树，$q$次操作，每次操作可以令一个节点的子树的所有节点增加一个颜色$i$,或查询一个节点的颜色数</p><p>$1 \le n,q \le 10^5$</p><p>感谢@oy的贡献</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>考虑维护 $C$ 个数据结构，存储每种颜色所对应的 $\text{dfs}$ 序的区间。根据 <em>势能分析</em> 可证明复杂度。剩余部分用线段树模拟即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="hljs-built_in">set</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; S[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson(u) node[u].l</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson(u) node[u].r</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> val(u) node[u].val</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tag(u) node[u].tag</span></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">        <span class="hljs-keyword">int</span> l, r;</span><br><span class="line">        ll val, tag;</span><br><span class="line">    &#125;node[MAXN &lt;&lt; <span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> R, cnt;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        val(u) = val(lson(u)) + val(rson(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (tag(u) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> llen = mid - l + <span class="hljs-number">1</span>, rlen = r - mid;</span><br><span class="line">        val(lson(u)) += <span class="hljs-number">1l</span>l * llen * tag(u),</span><br><span class="line">        val(rson(u)) += <span class="hljs-number">1l</span>l * rlen * tag(u);</span><br><span class="line">        tag(lson(u)) += tag(u),</span><br><span class="line">        tag(rson(u)) += tag(u);</span><br><span class="line">        tag(u) = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        u = ++cnt;</span><br><span class="line">        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">        build(lson(u), l, mid), build(rson(u), mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr, ll val)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">            val(u) += <span class="hljs-number">1l</span>l * (r - l + <span class="hljs-number">1</span>) * val;</span><br><span class="line">            tag(u) += val;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(u, l, r);</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ql &lt;= mid) </span><br><span class="line">            modify_range(lson(u), l, mid, ql, qr, val);</span><br><span class="line">        <span class="hljs-keyword">if</span> (mid &lt; qr)</span><br><span class="line">            modify_range(rson(u), mid + <span class="hljs-number">1</span>, r, ql, qr, val);</span><br><span class="line">        pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function">ll <span class="hljs-title">query_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> ql, <span class="hljs-keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class="line">            <span class="hljs-keyword">return</span> val(u);</span><br><span class="line">        pushdown(u, l, r);</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">        ll ret = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ql &lt;= mid)</span><br><span class="line">            ret += query_range(lson(u), l, mid, ql, qr);</span><br><span class="line">        <span class="hljs-keyword">if</span> (mid &lt; qr)</span><br><span class="line">            ret += query_range(rson(u), mid + <span class="hljs-number">1</span>, r, ql, qr);</span><br><span class="line">        <span class="hljs-keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, q;</span><br><span class="line"><span class="hljs-keyword">int</span> dfn[MAXN], size[MAXN], dfn_idx;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfn_idx;</span><br><span class="line">    size[u] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> u, v;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    T.build(T.R, <span class="hljs-number">1</span>, n);</span><br><span class="line">    <span class="hljs-keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> op, x, c;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="hljs-keyword">int</span> l = dfn[x], r = dfn[x] + size[x] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, T.query_range(T.R, <span class="hljs-number">1</span>, n, l, r));</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;c);</span><br><span class="line">            <span class="hljs-built_in">set</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt;::iterator it = S[c].lower_bound(make_pair(l, r));</span><br><span class="line">            <span class="hljs-keyword">int</span> nl = l, nr = r;</span><br><span class="line">            <span class="hljs-keyword">if</span> (it != S[c].begin()) &#123;</span><br><span class="line">                it--;</span><br><span class="line">                <span class="hljs-keyword">if</span> (it-&gt;second &gt;= l) &#123;</span><br><span class="line">                    nl = it-&gt;first;</span><br><span class="line">                    nr = max(r, it-&gt;second);</span><br><span class="line">                    T.modify_range(T.R, <span class="hljs-number">1</span>, n, it-&gt;first, it-&gt;second, <span class="hljs-number">-1</span>);</span><br><span class="line">                    S[c].erase(it++);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> it++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">while</span> (it != S[c].end() &amp;&amp; it-&gt;first &lt;= r + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">                nr = max(r, it-&gt;second);</span><br><span class="line">                T.modify_range(T.R, <span class="hljs-number">1</span>, n, it-&gt;first, it-&gt;second, <span class="hljs-number">-1</span>);</span><br><span class="line">                S[c].erase(it++);</span><br><span class="line">            &#125;</span><br><span class="line">            T.modify_range(T.R, <span class="hljs-number">1</span>, n, nl, nr, <span class="hljs-number">1</span>);</span><br><span class="line">            S[c].insert(make_pair(nl, nr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3227&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3227. 「USACO 2019.12 Platinum」Bessie’s Snow Cow&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给定$n$个节点的一棵有根树，$q$次操作，每次操作可以令一个节点的子树的所有节点增加一个颜色$i$,或查询一个节点的颜色数&lt;/p&gt;
&lt;p&gt;$1 \le n,q \le 10^5$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="set" scheme="https://tth37.cn/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>「USACO 2019.12 Platinum」Greedy Pie Eaters</title>
    <link href="https://tth37.cn/2020/01/20/solution-loj-3226/"/>
    <id>https://tth37.cn/2020/01/20/solution-loj-3226/</id>
    <published>2020-01-19T16:02:46.000Z</published>
    <updated>2020-01-21T10:09:31.642Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3226" target="_blank" rel="noopener">#3226. 「USACO 2019.12 Platinum」Greedy Pie Eaters</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给定$n$个数中$m$个区间，每个区间有一个权值，要求输出总区间权值最大的一个序列使得每个序列不被之前的序列的并集完全覆盖</p><p>$1 \le n \le 300,1 \le m \le \frac{n(n-1)}{2}$</p><p>感谢@oy的贡献</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>区间 DP。考虑对于每个区间，最后一个奶牛一定至少吃掉了一个派。枚举这个派，并进行状态转移即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line">ll a[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>], f[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>], g[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>][<span class="hljs-number">305</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> w, l, r;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;w, &amp;l, &amp;r);</span><br><span class="line">        a[l][r] = <span class="hljs-number">1l</span>l * w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = i + l - <span class="hljs-number">1</span>; j &lt;= n; ++i, ++j) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                g[i][j][k] = max(&#123; a[i][j], g[i + <span class="hljs-number">1</span>][j][k], g[i][j - <span class="hljs-number">1</span>][k] &#125;);</span><br><span class="line">                f[i][j] = max(f[i][j], f[i][k - <span class="hljs-number">1</span>] + f[k + <span class="hljs-number">1</span>][j] + g[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, f[<span class="hljs-number">1</span>][n]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3226&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3226. 「USACO 2019.12 Platinum」Greedy Pie Eaters&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给定$n$个数中$m$个区间，每个区间有一个权值，要求输出总区间权值最大的一个序列使得每个序列不被之前的序列的并集完全覆盖&lt;/p&gt;
&lt;p&gt;$1 \le n \le 300,1 \le m \le \frac{n(n-1)}{2}$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>形式幂级数与生成函数</title>
    <link href="https://tth37.cn/2020/01/19/algorithm-genfunc/"/>
    <id>https://tth37.cn/2020/01/19/algorithm-genfunc/</id>
    <published>2020-01-19T12:56:59.000Z</published>
    <updated>2020-01-20T09:15:45.461Z</updated>
    
    <content type="html"><![CDATA[<p>这里好像得写点什么……</p><a id="more"></a><h3 id="常用形式幂级数"><a href="#常用形式幂级数" class="headerlink" title="常用形式幂级数"></a>常用形式幂级数</h3><p>$\sum_{n\ge 0}x^n=\frac{1}{1-x}$</p><p>$\sum_{n\ge 1}x^n=\frac{x}{1-x}$</p><p>$\sum_{n\ge 1}nx^n=\frac{x}{(1-x)^2}$</p><p>$\sum_{n\ge 0}\frac{1}{n!}x^n=e^x$</p><p>$\sum_{n\ge 0}\frac{1}{n!}x^n=e^x$</p><h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><h4 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h4><p>$<br>\sum_{n\ge 0} A_n x^n<br>$</p><p>处理无标号的组合问题。</p><p>例：求节点数为 $n$ 的二叉树（不带标号）的个数。</p><p>令 $F(x)$ 表示该问题的生成函数，考虑一棵二叉树可以划分成根节点和左右子树。所以，$F(x)=xF^2(x)+1$，即左子树与右子树的方案相乘，加上根节点以及空节点的状态。</p><h4 id="指数型生成函数"><a href="#指数型生成函数" class="headerlink" title="指数型生成函数"></a>指数型生成函数</h4><p>$<br>\sum_{n\ge 0} A_n \frac{1}{n!}x^n<br>$</p><p>处理有标号的组合问题。</p><p>原理：考虑将两个有标号的组合对象合并，需要将新标号的一部分分给左侧、再将另一部分分给右侧，恰好为 $n\choose k$ 的形式。处理标号合并问题。</p><p>例：联通图计数。求 $n$ 个带标号的点的联通图数量。</p><p>考虑任意图可以被划分为若干联通图。</p><p>定义联通图的生成函数为 $F(x)$，任意图的生成函数为 $G(x)$。</p><p>注意到联通图的生成函数很好求，$G(x)=\sum_{n\ge 0}\frac{2^{n(n-1)/2}}{n!}x^n$。另一方面，任意图是由联通图构成的，因此 $G(x)=e^{F(x)}$。（任意多个组合在一起的方案数）</p><p>因此，$F(x)=\ln G(x)$，通过多项式操作可以快速求得。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里好像得写点什么……&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
    
      <category term="生成函数" scheme="https://tth37.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="多项式" scheme="https://tth37.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拆分数</title>
    <link href="https://tth37.cn/2020/01/19/algorithm-numdivide/"/>
    <id>https://tth37.cn/2020/01/19/algorithm-numdivide/</id>
    <published>2020-01-19T10:00:06.000Z</published>
    <updated>2020-01-19T12:16:08.051Z</updated>
    
    <content type="html"><![CDATA[<p>拆分数问题：将大小为 $n$ 的正整数拆分为若干无序的正整数的和的方案数。</p><p>感谢 @oy 对本文做出的巨大贡献（即吊锤 tth37）</p><a id="more"></a><h3 id="动态规划一-O-n-2"><a href="#动态规划一-O-n-2" class="headerlink" title="动态规划一 $O(n^2)$"></a>动态规划一 $O(n^2)$</h3><p>记 $f[i][j]$ 为将 $i$ 拆分为若干个大小不超过 $j$ 的整数的和的方案数。</p><p>分类讨论：第一种情况为 <strong>最大的拆分数恰好为 $j$</strong>，第二种为 <strong>最大的拆分数小于等于 $j-1$</strong>。对于第一种情况，可以强制拆分出一个 $j$，也可以考虑为将 $i-j$ 拆分，再强制插入一个 $j$ 所得到的方案数；对于第二种情况，直接套用定义 $f[i][j-1]$ 即可。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]=f[i-j][j]+f[i][j-1]</script><h3 id="动态规划二-O-n-2"><a href="#动态规划二-O-n-2" class="headerlink" title="动态规划二 $O(n^2)$"></a>动态规划二 $O(n^2)$</h3><p>记 $g[i][j]$ 为将 $i$ 拆分为 $j$ 个整数的和的方案数。</p><p>分类讨论：第一种情况为 <strong>最小的拆分数恰好为 $1$</strong>，第二种为 <strong>最小的拆分数大于 $1$</strong>。对于第一种情况，可以强制拆分出一个 $1$，也可以考虑为将 $i-1$ 拆分，再强制插入一个 $1$ 所得到的方案数；对于第二种情况，不难发现在 $g[i-j][j]$ 的方案中 <strong>所有的拆分数都加上 $1$</strong> 后，满足最小的拆分数大于 $1$ 并且所有拆分数之和恰好为 $i$，即为所求。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">g[i][j]=g[i-1][j-1]+g[i-j][j]</script><h3 id="动态规划三-O-n-sqrt-n"><a href="#动态规划三-O-n-sqrt-n" class="headerlink" title="动态规划三 $O(n\sqrt n)$"></a>动态规划三 $O(n\sqrt n)$</h3><blockquote><p>性质：在 $n$ 以下且大小超过 $\sqrt n$ 的数不超过 $\sqrt n$ 个。</p></blockquote><p>考虑将 <em>动态规划一</em> 和 <em>动态规划二</em> 中的思想合并。</p><p>记 $f’[i][j]$ 仍为将 $i$ 拆分为若干个大小不超过 $j$ 的整数的和的方案数。唯一的区别是，我们只需将 $f’$ 数组的第二维循环到 $\sqrt n$ 即可。</p><p>记 $g’[i][j]$ 为将 $i$ 拆分为若干个整数的和的方案数，其中 <strong>大于等于 $\sqrt n$ 的数有 $j$ 个</strong>，对于这类数我们称之为 <strong>大数</strong>。</p><p>对 $g’$ 数组分类讨论：第一种情况为划分出 <strong>最小的大数恰好为 $\sqrt n$</strong>，另一种情况为 <strong>最小的大数大于 $\sqrt n$</strong>。对于第一种情况，可以强制拆分出一个 $\sqrt n$，也可以考虑为将 $i-\sqrt n$ 拆分，再强制插入一个 $\sqrt n$ 所得到的方案数；对于第二种情况，不难发现再 $g’[i][j]$ 的方案中 <strong>所有的大数都加上 $1$</strong> 后，满足最小的 <strong>大数</strong> 大于 $\sqrt n$ 并且所有拆分数之和恰好为 $i$。 </p><p>对于初值，$g[i][0]$ 显然为 $f[i][\sqrt n -1]$。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">g[i][0]=f[i][\sqrt n-1] \\g[i][j]=g[i-\sqrt n][j-1]+g[i-j][j]</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拆分数问题：将大小为 $n$ 的正整数拆分为若干无序的正整数的和的方案数。&lt;/p&gt;
&lt;p&gt;感谢 @oy 对本文做出的巨大贡献（即吊锤 tth37）&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
    
      <category term="组合计数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>solution-bzoj-3032</title>
    <link href="https://tth37.cn/2020/01/19/solution-bzoj-3032/"/>
    <id>https://tth37.cn/2020/01/19/solution-bzoj-3032/</id>
    <published>2020-01-19T02:48:21.000Z</published>
    <updated>2020-01-19T02:48:21.713Z</updated>
    
    <content type="html"><![CDATA[<p><a href></a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括征集中~</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括征集中~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>「JSOI2019」神经网络</title>
    <link href="https://tth37.cn/2019/12/18/solution-loj-3102/"/>
    <id>https://tth37.cn/2019/12/18/solution-loj-3102/</id>
    <published>2019-12-18T15:21:41.000Z</published>
    <updated>2020-01-21T10:09:15.703Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3102" target="_blank" rel="noopener">#3102. 「JSOI2019」神经网络</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给定$m$棵无根树，总结点数为$k$,对于任意两个属于不同的树的点，在形成的图$G$中连一条边，求$G$中的哈密顿回路数</p><p>$1 \le m \le 300， 1 \le k \le 5 \times 10^3$</p><p>感谢@oy的贡献</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>根据题意，合法的哈密顿回路只能从一个点走到同一棵树上相邻的点，或是其他树上的任意点。因此在每一棵树上经过的路径必定是几条不相交的链。可以先计算<strong>将树拆分成链</strong>的方案数，再将它们合并起来。</p><p>将树拆分成链可以用背包类树形 DP 解决。记 $f[u][i][0/1/2]$ 表示将以 $u$ 为根的子树拆分成 $i$ 条<strong>有向</strong>链的方案数，特殊的，根节点所在的链没有方向。$0$ 表示根节点所在的链长度为 $1$ ，$1$ 表示根节点为所在链的一个端点，$2$ 表示根节点不是其所在链的端点。</p><p>大力树形背包转移即可，略显繁琐，详见代码。</p><p>接下来考虑将若干条链合并为哈密顿回路。考虑简化后的问题：有若干种颜色的小球，每种颜色的小球个数不定。将所有小球摆成一个环，并且不能有颜色相同的小球位于相邻位置。求方案数。</p><p>在本题中，颜色即对应树，小球对应链。构造每一种颜色的生成函数如下：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}f_i i!\sum_{j=1}^{i}(-1)^{i-j} {i-1\choose j-1}\frac{x^j}{j!}</script><p>其中 $f_i$ 表示将树划分为 $i$ 条链的方案数。对于保证至少有奇数个同色对的方案，需要乘系数 $-1$。将所有生成函数卷起来，每种系数前做一个<strong>环排</strong>统计方案即可。</p><p>至此 JSOI2019 就全部做完了，还是非常吃力的。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">5005</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">305</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">int</span> v, nxt;</span><br><span class="line">&#125;edge[MAXN &lt;&lt; <span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> head[MAXN], cnt;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].nxt = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m;</span><br><span class="line">ll f[MAXN][MAXN][<span class="hljs-number">3</span>], t[MAXN][MAXN][<span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> size[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[u] = <span class="hljs-number">1</span>;</span><br><span class="line">f[u][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].nxt) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> v = edge[i].v;</span><br><span class="line"><span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;</span><br><span class="line">dp(v, u);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= size[u]; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">ll tmp1 = (f[v][j][<span class="hljs-number">0</span>] + f[v][j][<span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + f[v][j][<span class="hljs-number">2</span>] * <span class="hljs-number">2</span>) % MOD;</span><br><span class="line">ll tmp2 = (f[v][j][<span class="hljs-number">0</span>] + f[v][j][<span class="hljs-number">1</span>]) % MOD;</span><br><span class="line">t[u][i + j][<span class="hljs-number">0</span>] = (t[u][i + j][<span class="hljs-number">0</span>] + tmp1 * f[u][i][<span class="hljs-number">0</span>]) % MOD;</span><br><span class="line">t[u][i + j][<span class="hljs-number">1</span>] = (t[u][i + j][<span class="hljs-number">1</span>] + tmp1 * f[u][i][<span class="hljs-number">1</span>]) % MOD;</span><br><span class="line">t[u][i + j][<span class="hljs-number">2</span>] = (t[u][i + j][<span class="hljs-number">2</span>] + tmp1 * f[u][i][<span class="hljs-number">2</span>]) % MOD;</span><br><span class="line">t[u][i + j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = (t[u][i + j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + tmp2 * f[u][i][<span class="hljs-number">0</span>]) % MOD;</span><br><span class="line">t[u][i + j - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = (t[u][i + j - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + tmp2 * f[u][i][<span class="hljs-number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">size[u] += size[v];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= size[u]; ++i) &#123;</span><br><span class="line">f[u][i][<span class="hljs-number">0</span>] = t[u][i][<span class="hljs-number">0</span>],</span><br><span class="line">f[u][i][<span class="hljs-number">1</span>] = t[u][i][<span class="hljs-number">1</span>],</span><br><span class="line">f[u][i][<span class="hljs-number">2</span>] = t[u][i][<span class="hljs-number">2</span>],</span><br><span class="line">t[u][i][<span class="hljs-number">0</span>] = t[u][i][<span class="hljs-number">1</span>] = t[u][i][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv[MAXN], fac[MAXN], facinv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> fac[n] * facinv[m] % MOD * facinv[n - m] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[MAXN * MAXM], c[MAXN * MAXM], b[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">fac[<span class="hljs-number">0</span>] = facinv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">inv[<span class="hljs-number">1</span>] = fac[<span class="hljs-number">1</span>] = facinv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">5000</span>; ++i) &#123;</span><br><span class="line">inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1l</span>l * i % MOD;</span><br><span class="line">facinv[i] = facinv[i - <span class="hljs-number">1</span>] * inv[i] % MOD;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>; cas &lt;= m; ++cas) &#123;</span><br><span class="line">cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> u, v;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">AddEdge(u, v), AddEdge(v, u);</span><br><span class="line">&#125;</span><br><span class="line">dp(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">ll tmp = (f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>] + f[<span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + f[<span class="hljs-number">1</span>][i][<span class="hljs-number">2</span>] * <span class="hljs-number">2</span>) * fac[i] % MOD;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">b[j] = (b[j] + ((i - j) &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * tmp * C(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) % MOD * facinv[j] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; ++i) c[i] = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; ++i) </span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) </span><br><span class="line">c[i + j] = (c[i + j] + a[i] * b[j] % MOD) % MOD;</span><br><span class="line">len += n;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; ++i) a[i] = c[i];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">head[i] = <span class="hljs-number">0</span>;</span><br><span class="line">b[i] = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">f[i][j][<span class="hljs-number">0</span>] = f[i][j][<span class="hljs-number">1</span>] = f[i][j][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">t[i][j][<span class="hljs-number">0</span>] = t[i][j][<span class="hljs-number">1</span>] = t[i][j][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; ++i)</span><br><span class="line">ans = (ans + a[i] * fac[i] % MOD * inv[i] % MOD + MOD) % MOD;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3102&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3102. 「JSOI2019」神经网络&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给定$m$棵无根树，总结点数为$k$,对于任意两个属于不同的树的点，在形成的图$G$中连一条边，求$G$中的哈密顿回路数&lt;/p&gt;
&lt;p&gt;$1 \le m \le 300， 1 \le k \le 5 \times 10^3$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="组合计数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
      <category term="生成函数" scheme="https://tth37.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2019」精准预测</title>
    <link href="https://tth37.cn/2019/12/18/solution-loj-3101/"/>
    <id>https://tth37.cn/2019/12/18/solution-loj-3101/</id>
    <published>2019-12-18T15:21:37.000Z</published>
    <updated>2020-01-21T10:09:01.873Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3101" target="_blank" rel="noopener">#3101. 「JSOI2019」精准预测</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>给定$n$个人，$m$个预测，每个预测从$t$时刻$x$的状态，可以推断$t+1$时刻$y$的状态，求每个人$k$的$\sum_{i = 1}^{n}live(k,i) ，i \neq k$ 其中$live(i,j) = 1$表示$i$和$j$在$T +1$时存活，否则$live(i,j) = 0$</p><p>$1 \le T \le 10^6,1 \le n \le 5 \times 10^4 ,1 \le m \le 10^5$</p><p>感谢@oy的贡献</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>记 $(t,x,0)$ 表示 $t$ 时刻 $x$ 死亡的状态， $(t,x,1)$ 表示 $t$ 时刻 $x$ 活着的状态。</p><p>$\text{2-SAT}$ 建图：对于限制条件 $0$，连边 $(t,x,1)\rightarrow(t+1,y,0)$ 和 $(t+1,y,1)\rightarrow(t,x,0)$；对于限制条件 $2$，连边 $(t,x,1)\rightarrow(t,y,0)$ 和 $(t,y,1)\rightarrow(t,x,0)$。此外还需要连边 $(t,x,0)\rightarrow(t+1,x,0)$ 和 $(t+1,x,1)\rightarrow(t,x,1)$。</p><p>建完图后即可求出每一个人在 $T+1$ 时刻活着时，有多少人在同一时刻必然死亡。其中有部分人自己产生矛盾，即可以从 $(x,T+1,1)$ 推导出 $(x,T+1,0)$，那么这部分人也必然死亡。</p><p>不难发现建出的图为 $\text{DAG}$。考虑只保留需要的 $O(m+n)$ 个点即可。</p><p>在求解时只能做到 $\text{bitset}$ 复杂度，可以考虑将 $\text{bitset}$ 值域分段操作。</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>不要看错题！</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXT = MAXN * <span class="hljs-number">4</span> + MAXM * <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> t, p;</span><br><span class="line">    Type(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>) &#123;t = x, p = y;&#125;</span><br><span class="line">    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Type&amp; rhs) <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p != rhs.p) <span class="hljs-keyword">return</span> p &lt; rhs.p;</span><br><span class="line">        <span class="hljs-keyword">return</span> t &lt; rhs.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> T, n, m;</span><br><span class="line"><span class="hljs-built_in">map</span>&lt;Type, <span class="hljs-keyword">int</span>&gt; mp;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt;</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G[MAXT];</span><br><span class="line"><span class="hljs-built_in">bitset</span>&lt;16668&gt; s[MAXT], delta;</span><br><span class="line"><span class="hljs-keyword">bool</span> vis[MAXT];</span><br><span class="line"><span class="hljs-keyword">int</span> ans[MAXN], delt;</span><br><span class="line"><span class="hljs-keyword">bool</span> noans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    G[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (u &lt;= <span class="hljs-number">2</span> * n &amp;&amp; (u &amp; <span class="hljs-number">1</span>)) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> p = (u + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (l &lt;= p &amp;&amp; p &lt;= r)</span><br><span class="line">            s[u][p - l + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> v = *it;</span><br><span class="line">        dfs(v);</span><br><span class="line">        s[u] |= s[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;T, &amp;n, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mp[Type(T + <span class="hljs-number">1</span>, i)] = ++cnt, ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> c, t, x, y;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>, &amp;c, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mp[Type(t, x)] == <span class="hljs-number">0</span>)</span><br><span class="line">                mp[Type(t, x)] = ++cnt, ++cnt;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mp[Type(t + <span class="hljs-number">1</span>, y)] == <span class="hljs-number">0</span>)</span><br><span class="line">                mp[Type(t + <span class="hljs-number">1</span>, y)] = ++cnt, ++cnt;</span><br><span class="line">            AddEdge(mp[Type(t, x)], mp[Type(t + <span class="hljs-number">1</span>, y)]),</span><br><span class="line">            AddEdge(mp[Type(t + <span class="hljs-number">1</span>, y)] + <span class="hljs-number">1</span>, mp[Type(t, x)] + <span class="hljs-number">1</span>);    </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mp[Type(t, x)] == <span class="hljs-number">0</span>)</span><br><span class="line">                mp[Type(t, x)] = ++cnt, ++cnt;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mp[Type(t, y)] == <span class="hljs-number">0</span>)</span><br><span class="line">                mp[Type(t, y)] = ++cnt, ++cnt;</span><br><span class="line">            AddEdge(mp[Type(t, x)] + <span class="hljs-number">1</span>, mp[Type(t, y)]),</span><br><span class="line">            AddEdge(mp[Type(t, y)] + <span class="hljs-number">1</span>, mp[Type(t, x)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> lt = <span class="hljs-number">0</span>, lp = <span class="hljs-number">0</span>, lc = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : mp) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> t = it.first.t, p = it.first.p, c = it.second;</span><br><span class="line">        <span class="hljs-keyword">if</span> (lt) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (lp == p) &#123;</span><br><span class="line">            AddEdge(lc, c), AddEdge(c + <span class="hljs-number">1</span>, lc + <span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lt = t, lp = p, lc = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= n; l += <span class="hljs-number">16667</span>) &#123;</span><br><span class="line">        r = min(n, l + <span class="hljs-number">16666</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            s[i].reset();</span><br><span class="line">        delta.reset();</span><br><span class="line">        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            dfs(i &lt;&lt; <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s[i &lt;&lt; <span class="hljs-number">1</span>][i - l + <span class="hljs-number">1</span>]) &#123;</span><br><span class="line">                noans[i] = <span class="hljs-number">1</span>;</span><br><span class="line">                delta[i - l + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            s[i &lt;&lt; <span class="hljs-number">1</span>] |= delta;</span><br><span class="line">            ans[i] += r - l + <span class="hljs-number">1</span> - s[i &lt;&lt; <span class="hljs-number">1</span>].count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, noans[i] ? <span class="hljs-number">0</span> : ans[i] - <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3101. 「JSOI2019」精准预测&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;给定$n$个人，$m$个预测，每个预测从$t$时刻$x$的状态，可以推断$t+1$时刻$y$的状态，求每个人$k$的$\sum_{i = 1}^{n}live(k,i) ，i \neq k$ 其中$live(i,j) = 1$表示$i$和$j$在$T +1$时存活，否则$live(i,j) = 0$&lt;/p&gt;
&lt;p&gt;$1 \le T \le 10^6,1 \le n \le 5 \times 10^4 ,1 \le m \le 10^5$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
    
    </summary>
    
    
      <category term="2-SAT" scheme="https://tth37.cn/tags/2-SAT/"/>
    
      <category term="bitset" scheme="https://tth37.cn/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2019」节日庆典</title>
    <link href="https://tth37.cn/2019/12/07/solution-loj-3103/"/>
    <id>https://tth37.cn/2019/12/07/solution-loj-3103/</id>
    <published>2019-12-07T15:39:32.000Z</published>
    <updated>2019-12-10T14:46:26.429Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3103" target="_blank" rel="noopener">#3103. 「JSOI2019」节日庆典</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>对于给定字符串 $S$，求 $S$ 的每个前缀的最小循环后缀。</p><p>$|S|\le 3000000$</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>考虑对 $S$ 的每个前缀维护一个集合 $T$，包含该前缀的最小后缀位置。将这些最小后缀位置称为“候选点”。</p><p>记正在处理的前缀为 $k$，那么这个集合具有以下性质：</p><ol><li><p>若 $i,j\in T(i&lt;j)$，那么 $S[j..k]=S[i..i+k-j]$，即后缀 $j$ 为后缀 $i$ 的前缀。</p></li><li><p>若 $i,j\in T(i&lt;j)$，且 $S[j..k]=S[i..i+k-j]$，若 $i+k-j\ge j$，则 $j$ 不会成为最优位置。</p><p>简单说明一下性质 2。容易发现后缀 $i$ 的形式为 $ABABA$，后缀 $j$ 为 $ABA$。若循环后缀的下一位较小，则 $A$ 为最优后缀；反之，则 $ABABA$ 为最优位置；$ABA$ 不会成为最优位置。</p></li></ol><p>维护出这个集合后，发现对于 $S$ 的每个前缀，集合 $T$ 的大小不超过 $\log k$。暴力枚举集合中所有候选点并比较即可。</p><p>具体比较方法可以利用性质 1，转化为后缀与原串的比较。在进行<strong>后缀与原串的比较</strong>时可以利用 <a href="https://tth37.cn/2019/12/01/algorithm-exkmp/">扩展 KMP</a> 算法中求出的 $\text{next}$ 数组进行 $O(1)$ 复杂度比较。</p><p>细节处理比较麻烦。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next next233</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">3e6</span> + <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> s[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> next[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> st1[MAXN], st2[MAXN], cnt1, cnt2;</span><br><span class="line"><span class="hljs-keyword">int</span> *x = st1, *y = st2;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exKMP_pre</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="hljs-number">0</span>] = n;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p + <span class="hljs-number">1</span> &lt; n &amp;&amp; T[p] == T[p + <span class="hljs-number">1</span>]) p++;</span><br><span class="line">    next[<span class="hljs-number">1</span>] = p;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        p = k + next[k] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> l = next[x - k];</span><br><span class="line">        <span class="hljs-keyword">if</span> (x + l &lt;= p) next[x] = l;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = p - x + <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) j = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (x + j &lt; n &amp;&amp; T[x + j] == T[j]) j++;</span><br><span class="line">            next[x] = j;</span><br><span class="line">            k = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = p + k - q + <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (next[t] &lt; k - t + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s[next[t]] &lt; s[t + next[t]]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = q - p;</span><br><span class="line">    <span class="hljs-keyword">if</span> (next[t] &lt; p) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s[next[t]] &lt; s[t + next[t]]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);</span><br><span class="line">    exKMP_pre(s);</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        x[++cnt1] = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= cnt1; ++k) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> q = x[k];</span><br><span class="line">            <span class="hljs-keyword">if</span> (cnt2 == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                y[++cnt2] = q;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">int</span> p = y[cnt2];</span><br><span class="line">            <span class="hljs-keyword">if</span> (s[i] &gt; s[p + i - q]) <span class="hljs-keyword">continue</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s[i] &lt; s[p + i - q]) &#123;</span><br><span class="line">                y[cnt2 = <span class="hljs-number">1</span>] = q;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (s[i] == s[p + i - q]) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (p + i - q &lt; q) y[++cnt2] = q;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(x, y);</span><br><span class="line">        cnt1 = cnt2, cnt2 = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> ans = x[<span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>; k &lt;= cnt1; ++k) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (cmp(ans, x[k], i) == <span class="hljs-number">1</span>) ans = x[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ans + <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3103&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3103. 「JSOI2019」节日庆典&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;对于给定字符串 $S$，求 $S$ 的每个前缀的最小循环后缀。&lt;/p&gt;
&lt;p&gt;$|S|\le 3000000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="KMP" scheme="https://tth37.cn/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>「NOI2014」动物园</title>
    <link href="https://tth37.cn/2019/12/02/solution-loj-2246/"/>
    <id>https://tth37.cn/2019/12/02/solution-loj-2246/</id>
    <published>2019-12-01T17:15:35.000Z</published>
    <updated>2019-12-01T17:30:21.054Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/2246" target="_blank" rel="noopener">#2246. 「NOI2014」动物园</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括征集中~</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>回顾一下我们在 <a href="https://tth37.cn/2019/12/01/algorithm-exkmp/">扩展 KMP</a> 算法中求出的 $\text{next}$ 函数：$\text{next}[i]$ 表示后缀 $i$ 即 $T[i..|T|]$ 与 $T$ 的最长公共前缀。 </p><p>如果我们对读入的字符串已经求出了 $\text{next}$ 数组，那么这题就迎刃而解了。</p><p>首先，我们不考虑 <em>前后缀不可重叠</em> 的限制，尝试计算 $\text{num}$ 数组。观察字符串 $S$ 的每一个后缀 $i$，不难发现这些后缀将对 $\text{num}[i..i+\text{next}[i]-1]$ 产生贡献。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">a b a b a</span><br><span class="line"></span><br><span class="line">a    a b    a b a</span><br><span class="line">|    | |    | | |</span><br><span class="line">a    a b    a b a</span><br></pre></td></tr></table></figure><p>如果考虑 <em>前后缀不可重叠</em> 的限制条件，可以发现后缀 $i$ 不会对 $i\times 2$ 及以后的 $\text{num}$ 产生贡献。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">a b a b a</span><br><span class="line"></span><br><span class="line">a    a b    a b a</span><br><span class="line">|    | |    X X X</span><br><span class="line">a    a b    a b a</span><br></pre></td></tr></table></figure><p>只需对 $\text{num}$ 数组进行差分即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next next233</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> next[MAXN], num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exKMP_pre</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="hljs-number">0</span>] = n;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p + <span class="hljs-number">1</span> &lt; n &amp;&amp; T[p] == T[p + <span class="hljs-number">1</span>]) p++;</span><br><span class="line">    next[<span class="hljs-number">1</span>] = p;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        p = k + next[k] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> l = next[x - k];</span><br><span class="line">        <span class="hljs-keyword">if</span> (x + l &lt;= p) next[x] = l;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = p - x + <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) j = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (x + j &lt; n &amp;&amp; T[x + j] == T[j]) j++;</span><br><span class="line">            next[x] = j;</span><br><span class="line">            k = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> T, ans;</span><br><span class="line"><span class="hljs-keyword">char</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="hljs-keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(next));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(num));</span><br><span class="line">        <span class="hljs-built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        exKMP_pre(a);</span><br><span class="line">        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(a);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (next[i]) &#123;</span><br><span class="line">                num[i] ++;</span><br><span class="line">                num[min(i + next[i], i &lt;&lt; <span class="hljs-number">1</span>)]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            num[i] += num[i - <span class="hljs-number">1</span>];</span><br><span class="line">            ans = <span class="hljs-number">1l</span>l * ans * (num[i] + <span class="hljs-number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/2246&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#2246. 「NOI2014」动物园&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括征集中~&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="KMP" scheme="https://tth37.cn/tags/KMP/"/>
    
      <category term="差分" scheme="https://tth37.cn/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>扩展 KMP</title>
    <link href="https://tth37.cn/2019/12/01/algorithm-exkmp/"/>
    <id>https://tth37.cn/2019/12/01/algorithm-exkmp/</id>
    <published>2019-12-01T15:43:05.000Z</published>
    <updated>2019-12-04T17:04:47.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文源自计蒜客课件，<strong>切勿外传！</strong></p></blockquote><p>扩展 KMP 能在 $O(|S|+|T|)$ 时间复杂度内处理出字符串 $S$ 的所有后缀与字符串 $T$ 的最长公共前缀。</p><p>之所以称为扩展 KMP，是因为其思想和 KMP 算法很类似。</p><a id="more"></a><h3 id="text-next-函数"><a href="#text-next-函数" class="headerlink" title="$\text{next}$ 函数"></a>$\text{next}$ 函数</h3><p>记 $\text{next}[i]$ 表示后缀 $i$ 即 $T[i..|T|]$ 与 $T$ 的最长公共前缀。</p><p>例如：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数组索引</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">字符串数组</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">$\text{next}$ 数组</td><td style="text-align:center">9</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><p>注意 $\text{next}$ 数组是对于 <strong>模式串 $T$</strong> 构建的。</p><h3 id="如何获取-text-next-函数"><a href="#如何获取-text-next-函数" class="headerlink" title="如何获取 $\text{next}$ 函数"></a>如何获取 $\text{next}$ 函数</h3><p>假设 $\text{next}<a href="0\le i&lt;x">i</a>$ 的值都已经求出，现在要求 $\text{next}[x]$。</p><p>假设 $p=\max\lbrace i+\text{next}[i]-1\rbrace$ 对于所有 $0&lt; i &lt; x$，我们找到 $i+next[i]-1$ 的最大值，令 $k$ 为这个最大值对应的 $i$，令 $p$ 为 $k+\text{next}[k]-1$，$p$ 就是我们目前已知的匹配到的最远位置。</p><p>根据定义我们可以得到： $T[k..p]=T[0..\text{next}[k]-1]$，如下图所示蓝色部分：</p><p><img src="https://res.jisuanke.com/img/upload/20180516/6cb6bc2387e42ba0a7ee4dcfe9332b9eb0b58f37.png" alt></p><p>现在我们要求 $T[x..n-1]$ 与 $T[0..n-1]$ 的最长公共前缀。</p><p>由 $T[k..p]=T[0..\text{next}[k]-1]$ 得：</p><p>$T[x..p]=T[x-k..\text{next}[k]-1]$，如下图所示红色部分：</p><p><img src="https://res.jisuanke.com/img/upload/20180516/0dd52d39385ff16ee85cc915742fc3d1c62ae173.png" alt></p><p>设 $l=\text{next}[x-k]$，根据下图，可以得到：</p><p>$T[0..l-1]=T[x-k..x-k+l-1]=T[x..x+l-1]$，如下图所示黄色部分：</p><p><img src="https://res.jisuanke.com/img/upload/20180516/d9cb7344732ed21100f545c2b38119074d6bf7d2.png" alt></p><p>也就是说，如果图中黄色部分小于红色部分，也就是 $l&lt;p-x+1$ 即 $x+l\le p$，那么我们可以确定 $\text{next}[x]=l$。否则，我们从 $p-x+1$ 和 $p+1$ 位置开始逐一比较，求出 $\text{next}[x]$ 的值。</p><p>由于在这个过程中， $p$ 满足不下降性质，因此总体时间复杂度为 $O(n)$。</p><h3 id="获取-text-next-函数的代码实现"><a href="#获取-text-next-函数的代码实现" class="headerlink" title="获取 $\text{next}$ 函数的代码实现"></a>获取 $\text{next}$ 函数的代码实现</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exKMP_pre</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="hljs-number">0</span>] = n;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p + <span class="hljs-number">1</span> &lt; n &amp;&amp; T[p] == T[p + <span class="hljs-number">1</span>]) p++;</span><br><span class="line">    next[<span class="hljs-number">1</span>] = p;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>; x &lt; n; ++x) &#123;</span><br><span class="line">        p = k + next[k] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> l = next[x - k];</span><br><span class="line">        <span class="hljs-keyword">if</span> (x + l &lt;= p) next[x] = l;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = p - x + <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) j = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (x + j &lt; n &amp;&amp; T[x + j] == T[j]) j++;</span><br><span class="line">            next[x] = j;</span><br><span class="line">            k = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决原问题"><a href="#解决原问题" class="headerlink" title="解决原问题"></a>解决原问题</h3><p>记 $\text{extend}[i]$ 表示字符串 $S$ 的第 $i$ 个后缀和 $T$ 的最长公共前缀。假设 $\text{extend}<a href="0\le i&lt;x">i</a>$ 已经求出，现在需要计算 $\text{extend}[x]$。</p><p>已知：$S[k..p]=T[0..\text{extend}[k]]$，求 $S[x..n]$ 与 $T[0..m]$ 的最长公共前缀。解法与计算 $\text{next}$ 的方法类似，记录 $p=i+\text{extend[i]}-1$ 的最大值。</p><p><img src="https://res.jisuanke.com/img/upload/20180516/761b7f45f24395bab2e469d658b7353672480a4e.png" alt></p><p>根据红色部分的等价，我们可以利用 $\text{next}[x-k]$ 得到黄色部分等价性，剩下的分析就和求 $\text{next}$ 的过程一样了。</p><h3 id="获取-text-extend-函数的代码实现"><a href="#获取-text-extend-函数的代码实现" class="headerlink" title="获取 $\text{extend}$ 函数的代码实现"></a>获取 $\text{extend}$ 函数的代码实现</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exKMP</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *S, <span class="hljs-keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(T), m = <span class="hljs-built_in">strlen</span>(S);</span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p &lt; m &amp;&amp; p &lt; n &amp;&amp; S[p] == T[p]) p++;</span><br><span class="line">    extend[<span class="hljs-number">0</span>] = p;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>; x &lt; m; ++x) &#123;</span><br><span class="line">        p = k + extend[k] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> l = next[x - k];</span><br><span class="line">        <span class="hljs-keyword">if</span> (x + l &lt;= p) extend[x] = l;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = p - x + <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) j = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> (x + j &lt; m &amp;&amp; j &lt; n &amp;&amp; S[x + j] == T[j]) j++;</span><br><span class="line">            extend[x] = j;</span><br><span class="line">            k = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文源自计蒜客课件，&lt;strong&gt;切勿外传！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展 KMP 能在 $O(|S|+|T|)$ 时间复杂度内处理出字符串 $S$ 的所有后缀与字符串 $T$ 的最长公共前缀。&lt;/p&gt;
&lt;p&gt;之所以称为扩展 KMP，是因为其思想和 KMP 算法很类似。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="字符串" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="KMP" scheme="https://tth37.cn/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>「CEOI2018」云计算</title>
    <link href="https://tth37.cn/2019/11/23/solution-loj-3182/"/>
    <id>https://tth37.cn/2019/11/23/solution-loj-3182/</id>
    <published>2019-11-23T14:52:04.000Z</published>
    <updated>2019-11-24T15:34:08.088Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3182" target="_blank" rel="noopener">#3182. 「CEOI2018」云计算</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括征集中~ 球球你再帮我写几篇吧 TAT @oykz2333</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p>这题也太巧妙了叭！ ——tth37</p></blockquote><p>考虑<strong>类似背包</strong>的动态规划。记 $f[i]$ 表示满足订单后恰好剩余 $i$ 个核心的最大利润。</p><p>先不考虑时钟频率的限制条件，则问题可以转化为普通背包问题：将计算机的价格视为负数，将订单的核心数视为负数，采用背包问题的状态转移即可。</p><p>如果考虑到时钟频率的限制，则需要满足：在将每个订单放入背包之前，必须将所有时钟频率大于等于该订单的计算机放入背包中。</p><p>将计算机和订单按照时钟频率排序后，依次加入背包即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> c, f, v;</span><br><span class="line">    <span class="hljs-keyword">bool</span> type;</span><br><span class="line">&#125;a[MAXN * <span class="hljs-number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a.f != b.f) <span class="hljs-keyword">return</span> a.f &gt; b.f;</span><br><span class="line">    <span class="hljs-keyword">return</span> a.type &lt; b.type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, m, tot;</span><br><span class="line">ll f[MAXN * <span class="hljs-number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;a[i].c, &amp;a[i].f, &amp;a[i].v), a[i].type = <span class="hljs-number">0</span>, tot += a[i].c;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;a[n + i].c, &amp;a[n + i].f, &amp;a[n + i].v), a[n + i].type = <span class="hljs-number">1</span>;</span><br><span class="line">    sort(a + <span class="hljs-number">1</span>, a + n + m + <span class="hljs-number">1</span>, cmp);</span><br><span class="line">    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0xcf</span>, <span class="hljs-keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + m; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[i].type == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = tot; j &gt;= a[i].c; --j)</span><br><span class="line">                f[j] = max(f[j], f[j - a[i].c] - a[i].v);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= tot - a[i].c; ++j)</span><br><span class="line">                f[j] = max(f[j], f[j + a[i].c] + a[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= tot; ++i)</span><br><span class="line">        ans = max(ans, f[i]);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3182&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3182. 「CEOI2018」云计算&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括征集中~ 球球你再帮我写几篇吧 TAT @oykz2333&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>「雅礼集训 2018 Day4」Magic</title>
    <link href="https://tth37.cn/2019/11/23/solution-loj-6503/"/>
    <id>https://tth37.cn/2019/11/23/solution-loj-6503/</id>
    <published>2019-11-22T17:43:34.000Z</published>
    <updated>2019-11-26T16:45:05.966Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6503" target="_blank" rel="noopener">#6503. 「雅礼集训 2018 Day4」Magic</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括征集中~</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>由于题意中<strong>本质不同的方案</strong>不是特别好处理，我们可以在每张卡片上标号，将计算出的答案乘上 $\prod_{i=1}^m\frac{1}{a_i!}$ 即可。</p><p>考虑容斥。记 $f[i]$ 为<strong>至少有 $i$ 个魔法对</strong>的方案数，则答案为 $\sum_{i=k}^n(-1)^{i-k}\times{i\choose k}\times f[i]$。</p><p>注意：<a href="https://tth37.cn/2019/11/22/solution-loj-3106/">「TJOI2019」唱、跳、rap 和篮球</a> 即为本题 $k=0$ 的特例。</p><p>考虑如何计算 $f[i]$。设第一种颜色至少有 $i_1$ 个魔法对，第二种颜色至少有 $i_2$ 个魔法对……以此类推。考虑以下构造序列的方法：第 $j$ 种颜色保留 $i_j$ 张卡片作为预留卡片，将剩余的卡片任意排列，然后依次将所有预留的卡片插入到原序列中<strong>与之颜色相同的卡片的后面</strong>。不难发现，按照该方法构造序列的方案数为 $(n-k)!\times\prod_{j=1}^m{a_j\choose i_j}\times \frac{(a_j-1)!}{(a_j-i_j-1)!}$，并且该序列中至少有 $\sum_{j=1}^mi_j$ 个魔法对。</p><p>因此，得到 $f[i]$ 的计算方法：</p><script type="math/tex; mode=display">f[i]=\sum_{i_1=0}^{a_1-1}\sum_{i_2=0}^{a_2-1}...\sum_{i_m=0}^{a_m-1}[i_1+i_2+...+i_m=i] (n-i)!\times\prod_{j=1}^m{a_j\choose i_j}\times \frac{(a_j-1)!}{(a_j-i_j-1)!}</script><p>注意到这是一个 $m$ 维卷积的形式，但是如果用暴力生成函数 + NTT 计算，复杂度为 $O(mn\log n)$，不能通过本题。我们可以用类似<strong>启发式合并</strong>的策略，交换多项式乘法运算顺序，每次将两个<strong>阶数最小</strong>的多项式相乘，即可将复杂度控制在 $O(m\log^2 n)$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">100005</span>, MAXM = <span class="hljs-number">20005</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>, G = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) ret = ret * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        k &gt;&gt;= <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> FFT &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, r[MAXN &lt;&lt; <span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span><span class="hljs-params">(ll *a, <span class="hljs-keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; (<span class="hljs-number">1</span> &lt;&lt; k) &lt; n; ++k);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            r[i] = r[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span> | (i &amp; <span class="hljs-number">1</span>) &lt;&lt; (k - <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> m = l &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">            ll w = qpow(G, (MOD - <span class="hljs-number">1</span>) / l);</span><br><span class="line">            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">-1</span>) w = qpow(w, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += l) &#123;</span><br><span class="line">                ll wk = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j, wk = wk * w % MOD) &#123;</span><br><span class="line">                    ll p = a[i + j], q = wk * a[i + j + m] % MOD;</span><br><span class="line">                    a[i + j] = (p + q) % MOD;</span><br><span class="line">                    a[i + j + m] = (p - q + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IDFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">-1</span>);</span><br><span class="line">        ll inv = qpow(n, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i] = a[i] * inv % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> m, n, k;</span><br><span class="line"><span class="hljs-keyword">int</span> a[MAXM];</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;ll&gt; b[MAXM &lt;&lt; <span class="hljs-number">1</span>];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; q;</span><br><span class="line">ll x[MAXN &lt;&lt; <span class="hljs-number">1</span>], y[MAXN &lt;&lt; <span class="hljs-number">1</span>], ans;</span><br><span class="line">ll fac[MAXN], inv[MAXN], facinv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> fac[n] * facinv[k] % MOD * facinv[n - k] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    fac[<span class="hljs-number">0</span>] = facinv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    fac[<span class="hljs-number">1</span>] = inv[<span class="hljs-number">1</span>] = facinv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="hljs-number">1</span>] * i % MOD;</span><br><span class="line">        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">        facinv[i] = facinv[i - <span class="hljs-number">1</span>] * inv[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; a[i]; ++j)</span><br><span class="line">            b[i].push_back(C(a[i], j) * fac[a[i] - <span class="hljs-number">1</span>] % MOD * facinv[a[i] - j - <span class="hljs-number">1</span>] % MOD);</span><br><span class="line">        q.push(make_pair(-b[i].size(), i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> cnt = m;</span><br><span class="line">    <span class="hljs-keyword">while</span> (q.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> id1 = q.top().second, sz1 = -q.top().first;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="hljs-keyword">int</span> id2 = q.top().second, sz2 = -q.top().first;</span><br><span class="line">        q.pop();</span><br><span class="line">        FFT::n = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (FFT::n &lt;= sz1 + sz2) FFT::n &lt;&lt;= <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= FFT::n; ++i) x[i] = y[i] = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz1; ++i) x[i] = b[id1][i];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz2; ++i) y[i] = b[id2][i];</span><br><span class="line">        FFT::DFT(x), FFT::DFT(y);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= FFT::n; ++i) x[i] = x[i] * y[i] % MOD;</span><br><span class="line">        FFT::IDFT(x);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= sz1 + sz2 - <span class="hljs-number">2</span>; ++i)</span><br><span class="line">            b[cnt].push_back(x[i]);</span><br><span class="line">        q.push(make_pair(-b[cnt].size(), cnt));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> id = q.top().second, sz = -q.top().first;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; sz; ++i) &#123;</span><br><span class="line">        ll tmp = C(i, k) * fac[n - i] % MOD * b[id][i] % MOD;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((i - k) &amp; <span class="hljs-number">1</span>) ans = (ans - tmp + MOD) % MOD;</span><br><span class="line">        <span class="hljs-keyword">else</span> ans = (ans + tmp) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans = ans * qpow(fac[a[i]], MOD - <span class="hljs-number">2</span>) % MOD;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/6503&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#6503. 「雅礼集训 2018 Day4」Magic&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括征集中~&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
      <category term="雅礼集训" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="FFT/NTT" scheme="https://tth37.cn/tags/FFT-NTT/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
      <category term="生成函数" scheme="https://tth37.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="启发式合并" scheme="https://tth37.cn/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="容斥原理" scheme="https://tth37.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>「TJOI2019」唱、跳、rap 和篮球</title>
    <link href="https://tth37.cn/2019/11/22/solution-loj-3106/"/>
    <id>https://tth37.cn/2019/11/22/solution-loj-3106/</id>
    <published>2019-11-21T16:21:51.000Z</published>
    <updated>2019-11-28T15:39:30.512Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/3106" target="_blank" rel="noopener">#3106. 「TJOI2019」唱、跳、rap 和篮球</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>有 $n$ 个蔡徐坤，有 $m$ 个世界上最帅的欧阳，求总共有多少人。</p><p>$n,m\le1000000$</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>记连续的 4 个学生分别喜欢唱、跳、rap 和篮球为一组。考虑容斥，记 $f[i]$ 为保证至少存在 $i$ 组的序列方案数。根据题意，在此序列中最多只会存在 $m=\min\lbrace a,b,c,\lfloor\frac{n}{4}\rfloor\rbrace$ 组。最终答案即为 $\sum_{i=0}^{m}(-1)^{i}\times f[i]$。</p><p>考虑 $f[i]$ 的计算。由于保证至少存在 $i$ 组，可以将 $i$ 组随机插入到序列中，然后在剩下的位置插入任意学生并统计答案。</p><p>将 $i$ 个长度为 4 的组插入到长度为 $n$ 的序列中，共有 ${n-3i\choose i}$ 种方案。</p><p>将 $i_1$ 个喜欢唱、$i_2$ 个喜欢跳、$i_3$ 个喜欢 rap、$i_4$ 个喜欢篮球的学生放置在长度为 $n-4i$ 的序列中，如果保证 $i_1+i_2+i_3+i_4=n-4i$，则方案数为 $\frac{(n-4i)!}{i_1!\times i_2!\times i_3\times i_4!}$。</p><p>然而题目不保证剩余的 $a-i$、$b-i$、$c-i$、$d-i$ 个学生之和恰好为 $n-4i$，因此该部分的答案为：</p><script type="math/tex; mode=display">\sum_{i_1=0}^{a-i}\sum_{i_2=0}^{b-i}\sum_{i_3=0}^{c-i}\sum_{i_4=0}^{d-i}[i_1+i_2+i_3+i_4=n-4i]\frac{(n-4i)!}{i_1!\times i_2!\times i_3\times i_4!}</script><p>注意到这是一个四元卷积的形式，可以用生成函数 + NTT 暴力求解。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>, G = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) ret = ret * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        k &gt;&gt;= <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> FFT &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, r[<span class="hljs-number">10005</span>];</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span><span class="hljs-params">(ll *a, <span class="hljs-keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; (<span class="hljs-number">1</span> &lt;&lt; k) &lt; n; ++k);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            r[i] = r[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span> | (i &amp; <span class="hljs-number">1</span>) &lt;&lt; (k - <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> m = l &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">            ll w = qpow(G, (MOD - <span class="hljs-number">1</span>) / l);</span><br><span class="line">            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">-1</span>) w = qpow(w, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += l) &#123;</span><br><span class="line">                ll wk = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j, wk = wk * w % MOD) &#123;</span><br><span class="line">                    ll p = a[i + j], q = wk * a[i + j + m] % MOD;</span><br><span class="line">                    a[i + j] = (p + q) % MOD;</span><br><span class="line">                    a[i + j + m] = (p - q + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IDFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">-1</span>);</span><br><span class="line">        ll inv = qpow(n, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i] = a[i] * inv % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll f[<span class="hljs-number">1005</span>];</span><br><span class="line">ll fac[<span class="hljs-number">4005</span>], inv[<span class="hljs-number">4005</span>], facinv[<span class="hljs-number">4005</span>];</span><br><span class="line">ll x[<span class="hljs-number">4005</span>], y[<span class="hljs-number">4005</span>], z[<span class="hljs-number">4005</span>], w[<span class="hljs-number">4005</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> fac[n] * facinv[k] % MOD * facinv[n - k] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, a, b, c, d, m;</span><br><span class="line">ll ans = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="hljs-number">0</span>] = facinv[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    fac[<span class="hljs-number">1</span>] = inv[<span class="hljs-number">1</span>] = facinv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">4000</span>; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="hljs-number">1</span>] * <span class="hljs-number">1l</span>l * i % MOD;</span><br><span class="line">        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;</span><br><span class="line">        facinv[i] = facinv[i - <span class="hljs-number">1</span>] * inv[i] % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    m = min(min(min(min(n / <span class="hljs-number">4</span>, a), b), c), d);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="hljs-built_in">memset</span>(x, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(x));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(y, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(y));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(z, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(z));</span><br><span class="line">        <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(w));</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= a - i; ++j) x[j] = facinv[j];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= b - i; ++j) y[j] = facinv[j];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= c - i; ++j) z[j] = facinv[j];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= d - i; ++j) w[j] = facinv[j];</span><br><span class="line">        FFT::n = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (FFT::n &lt;= a + b + c + d - <span class="hljs-number">4</span> * i) FFT::n &lt;&lt;= <span class="hljs-number">1</span>;</span><br><span class="line">        FFT::DFT(x), FFT::DFT(y), FFT::DFT(z), FFT::DFT(w);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; FFT::n; ++j)</span><br><span class="line">            x[j] = x[j] * y[j] % MOD * z[j] % MOD * w[j] % MOD;</span><br><span class="line">        FFT::IDFT(x);</span><br><span class="line">        f[i] = C(n - <span class="hljs-number">3</span> * i, i) * fac[n - <span class="hljs-number">4</span> * i] % MOD * x[n - <span class="hljs-number">4</span> * i] % MOD;</span><br><span class="line">        <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) ans = (ans - f[i] + MOD) % MOD;</span><br><span class="line">        <span class="hljs-keyword">else</span> ans = (ans + f[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/3106&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3106. 「TJOI2019」唱、跳、rap 和篮球&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;有 $n$ 个蔡徐坤，有 $m$ 个世界上最帅的欧阳，求总共有多少人。&lt;/p&gt;
&lt;p&gt;$n,m\le1000000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
    
      <category term="FFT/NTT" scheme="https://tth37.cn/tags/FFT-NTT/"/>
    
      <category term="组合计数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
    
      <category term="生成函数" scheme="https://tth37.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>快速傅里叶变换（FFT）快速数论变换（NTT）</title>
    <link href="https://tth37.cn/2019/11/20/algorithm-fftntt/"/>
    <id>https://tth37.cn/2019/11/20/algorithm-fftntt/</id>
    <published>2019-11-20T15:38:26.000Z</published>
    <updated>2019-11-24T15:37:42.474Z</updated>
    
    <content type="html"><![CDATA[<p>离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT 的频域采样。</p><p>FFT 是一种 DFT 的高效算法，称为快速傅立叶变换（Fast Fourier transform）。</p><p> 快速数论变换 (NTT) 是快速傅里叶变换（FFT）在数论基础上的实现。 </p><a id="more"></a><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">5000005</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll MOD = <span class="hljs-number">998244353</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ll G = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll k)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) ret = ret * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        k &gt;&gt;= <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> qpow(a, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">namespace</span> FFT &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, r[MAXN];</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NTT</span><span class="hljs-params">(ll *a, <span class="hljs-keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; (<span class="hljs-number">1</span> &lt;&lt; k) &lt; n; ++k);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            r[i] = r[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span> | (i &amp; <span class="hljs-number">1</span>) &lt;&lt; (k - <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> m = l &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">            ll w = qpow(G, (MOD - <span class="hljs-number">1</span>) / l);</span><br><span class="line">            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">-1</span>) w = inv(w);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += l) &#123;</span><br><span class="line">                ll wk = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j, wk = wk * w % MOD) &#123;</span><br><span class="line">                    ll p = a[i + j], q = wk * a[i + j + m] % MOD;</span><br><span class="line">                    a[i + j] = (p + q) % MOD;</span><br><span class="line">                    a[i + j + m] = (p - q + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IDFT</span><span class="hljs-params">(ll *a)</span> </span>&#123;</span><br><span class="line">        NTT(a, <span class="hljs-number">-1</span>);</span><br><span class="line">        ll inv = qpow(n, MOD - <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i] = a[i] * inv % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT 的频域采样。&lt;/p&gt;
&lt;p&gt;FFT 是一种 DFT 的高效算法，称为快速傅立叶变换（Fast Fourier transform）。&lt;/p&gt;
&lt;p&gt; 快速数论变换 (NTT) 是快速傅里叶变换（FFT）在数论基础上的实现。 &lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FFT/NTT" scheme="https://tth37.cn/tags/FFT-NTT/"/>
    
  </entry>
  
  <entry>
    <title>「雅礼集训 2017 Day7」蛐蛐国的修墙方案</title>
    <link href="https://tth37.cn/2019/11/14/solution-loj-6043/"/>
    <id>https://tth37.cn/2019/11/14/solution-loj-6043/</id>
    <published>2019-11-14T14:46:15.000Z</published>
    <updated>2019-11-24T15:39:41.131Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/problem/6043" target="_blank" rel="noopener">#6043. 「雅礼集训 2017 Day7」蛐蛐国的修墙方案</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括征集中~</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>CSP-S RP++!</p><p>赛前再做几个搜索 / 模拟，<del>为暴力骗分做准备，</del>顺便填一下雅礼集训的坑。</p><h4 id="Part1-暴搜"><a href="#Part1-暴搜" class="headerlink" title="Part1: 暴搜"></a>Part1: 暴搜</h4><p>观察题意得出，第 $i$ 个位置和第 $P_i$ 个位置上，必须填一个左括号和一个右括号。从左向右填写，每次判断是否可以填左 / 右括号即可。</p><p>得分 81 pts 。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-keyword">int</span> ans[<span class="hljs-number">105</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> p[<span class="hljs-number">105</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> force_right[<span class="hljs-number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dep, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (dep == n + <span class="hljs-number">1</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) </span><br><span class="line"><span class="hljs-built_in">putchar</span>(<span class="hljs-string">'('</span> + ans[i]);</span><br><span class="line"><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (cnt &lt; n / <span class="hljs-number">2</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (force_right[dep] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (p[dep] &lt; dep) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ans[p[dep]] == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">ans[dep] = <span class="hljs-number">0</span>;</span><br><span class="line">dfs(dep + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>);</span><br><span class="line">ans[dep] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">force_right[p[dep]] = <span class="hljs-number">1</span>;</span><br><span class="line">dfs(dep + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>);</span><br><span class="line">force_right[p[dep]] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">if</span> (dep - cnt &lt;= cnt) &#123;</span><br><span class="line">ans[dep] = <span class="hljs-number">1</span>;</span><br><span class="line">dfs(dep + <span class="hljs-number">1</span>, cnt);</span><br><span class="line">ans[dep] = <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;p[i]);</span><br><span class="line">dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part2-观察性质"><a href="#Part2-观察性质" class="headerlink" title="Part2: 观察性质"></a>Part2: 观察性质</h4><p>将排列 $P$ 视作置换函数，则 $P$ 必定可以分解为若干个长度为偶数的循环。（若不然，必定无解）对于每个循环都只有 2 种填法，即 0,1,0,1… 或 1,0,1,0…。特判长度为 2 的循环，则剩余的循环最多有 $100 / 4 = 25$ 个。复杂度约为 $2^{25}$ 级别。</p><p>得分 100 pts。</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, p[<span class="hljs-number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; circ[<span class="hljs-number">105</span>];</span><br><span class="line"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">105</span>], ans[<span class="hljs-number">105</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cnt1 += (ans[i] == <span class="hljs-number">0</span>), cnt2 += ans[i];</span><br><span class="line"><span class="hljs-keyword">if</span> (cnt1 &lt; cnt2) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (u == cnt + <span class="hljs-number">1</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (check()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="hljs-built_in">putchar</span>(<span class="hljs-string">'('</span> + ans[i]);</span><br><span class="line"><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> len = circ[u].size();</span><br><span class="line"><span class="hljs-keyword">if</span> (!(len ^ <span class="hljs-number">2</span>)) &#123;</span><br><span class="line">ans[circ[u][<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>, ans[circ[u][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;</span><br><span class="line">dfs(u + <span class="hljs-number">1</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i ^ len; ++i) ans[circ[u][i]] = i &amp; <span class="hljs-number">1</span>;</span><br><span class="line">dfs(u + <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i ^ len; ++i) ans[circ[u][i]] = !(i &amp; <span class="hljs-number">1</span>);</span><br><span class="line">dfs(u + <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) </span><br><span class="line"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;p[i]);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (vis[i] == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">cnt += <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> cur = i;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">circ[cnt].push_back(cur);</span><br><span class="line">vis[cur] = <span class="hljs-number">1</span>;</span><br><span class="line">cur = p[cur];</span><br><span class="line">&#125; <span class="hljs-keyword">while</span> (cur != i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/6043&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#6043. 「雅礼集训 2017 Day7」蛐蛐国的修墙方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括征集中~&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="LibreOJ" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/"/>
    
      <category term="雅礼集训" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/LibreOJ/%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="搜索" scheme="https://tth37.cn/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>咕咕树</title>
    <link href="https://tth37.cn/2019/11/04/solution-jsk-4596B/"/>
    <id>https://tth37.cn/2019/11/04/solution-jsk-4596B/</id>
    <published>2019-11-04T14:19:03.000Z</published>
    <updated>2019-11-25T15:59:25.169Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/42087" target="_blank" rel="noopener">4596B 咕咕树</a></p><h3 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h3><p>题目概括咕咕</p><a id="more"></a><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>高压下的代码实现能力堪忧。比赛 1 小时没敲出来，订正 10 分钟满分。</p><p>官方题解给的是树形背包，但并不是特别好实现。</p><p>定义状态 $f[u][i]$ 表示以 $u$ 为根的子树，有一条以 $u$ 为起点且长度恰好为 $i$ 的链，最少花费的代价。</p><p>考虑状态转移： $f[u][0]$ 显然是切断当前节点后，再将每个子树切断；$f[u][1]$ 即为切出一条长度为 $i$ 的链，对其余子树的链长度进行讨论。</p><script type="math/tex; mode=display">f[u][0]=a[u]+\sum_{v\in son(u)}\min_{j=0}^{l-1}\lbrace f[v][j]\rbrace\\f[u][1]=f[s][i-1]+\sum_{v\in son(u),v\not= s}\min_{j=0}^{\min(i-1,l-i-1)}\lbrace f[v][j]\rbrace</script><p>考虑优化。对所有 $f[u][0..l-1]$ 做前缀最小值，并记 $g[u][i]=\sum_{v\in son(u)}f[v][j]$，则转移方程简化为：</p><script type="math/tex; mode=display">f[u][0]=a[u]+g[u][l-1]\\f[u][1]=f[s][i-1]-f[s][\min(i-1,l-i-1)]+g[u][\min(i-1,l-i-1)]</script><p>注意叶节点的 $f[u][1]$ 应赋值为 $0$。</p><p>时间复杂度 $O(n^2)$。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> n, l;</span><br><span class="line"><span class="hljs-keyword">int</span> a[MAXN];</span><br><span class="line"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="hljs-keyword">int</span> g[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> v = *it;</span><br><span class="line">        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l; ++i)</span><br><span class="line">            g[u][i] += f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> v = *it;</span><br><span class="line">        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            f[u][i] = min(f[u][i], g[u][min(i - <span class="hljs-number">1</span>, l - i - <span class="hljs-number">1</span>)] - f[v][min(i - <span class="hljs-number">1</span>, l - i - <span class="hljs-number">1</span>)] + f[v][i - <span class="hljs-number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="hljs-number">0</span>] = a[u] + g[u][l - <span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">if</span> (u != <span class="hljs-number">1</span> &amp;&amp; G[u].size() == <span class="hljs-number">1</span>) f[u][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; l; ++i)</span><br><span class="line">        f[u][i] = min(f[u][i], f[u][i - <span class="hljs-number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(f));</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;l);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i]), sum += a[i];</span><br><span class="line">    <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, sum), <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> u, v;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, f[<span class="hljs-number">1</span>][l - <span class="hljs-number">1</span>]);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/42087&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;4596B 咕咕树&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Summarize&quot;&gt;&lt;a href=&quot;#Summarize&quot; class=&quot;headerlink&quot; title=&quot;Summarize&quot;&gt;&lt;/a&gt;Summarize&lt;/h3&gt;&lt;p&gt;题目概括咕咕&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="计蒜客" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/%E8%AE%A1%E8%92%9C%E5%AE%A2/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
</feed>
