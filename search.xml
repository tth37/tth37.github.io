<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解-LibreOJ-6029市场]]></title>
    <url>%2F2019%2F10%2F21%2Fsolution-loj-6029%2F</url>
    <content type="text"><![CDATA[题目链接(LibreOJ) 维护一个数据结构，支持区间加减、区间除法（下取整）、区间查询最值、区间查询总和操作。 $n \le 100000, q \le 100000$ 线段树区间除法模板题。可以玄学分析复杂度。 观察到对某个区间进行除法操作后，其区间内的权值整体减小某个值，当且仅当该区间的最大元素与最小元素减小的值相等。因此区间除法可以转化为区间减法，只需判断是否满足区间减的条件即可。 注意 '/' 运算符对数字进行向零取整，并不是向下取整 实现非常简单。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define lson(u) node[u].l#define rson(u) node[u].r#define tag(u) node[u].tag#define maxx(u) node[u].maxx#define minn(u) node[u].minn#define sum(u) node[u].sumconst int maxn = 100005;const int inf = 0x3f3f3f3f;struct Node &#123; int l, r, tag, minn, maxx; ll sum;&#125;node[maxn &lt;&lt; 1];int cnt;int N, Q, R;int a[maxn];inline void pushdown(int u, int l, int r) &#123; if (tag(u)) &#123; int mid = (l + r) &gt;&gt; 1; int llen = mid - l + 1, rlen = r - mid; sum(lson(u)) += 1ll * tag(u) * llen, sum(rson(u)) += 1ll * tag(u) * rlen; minn(lson(u)) += tag(u), minn(rson(u)) += tag(u); maxx(lson(u)) += tag(u), maxx(rson(u)) += tag(u); tag(lson(u)) += tag(u), tag(rson(u)) += tag(u); tag(u) = 0; &#125;&#125;inline void pushup(int u) &#123; sum(u) = sum(lson(u)) + sum(rson(u)); minn(u) = min(minn(lson(u)), minn(rson(u))); maxx(u) = max(maxx(lson(u)), maxx(rson(u)));&#125;void build(int&amp; u, int l, int r) &#123; u = ++cnt; sum(u) = 0, minn(u) = inf, maxx(u) = -inf; if (l == r) &#123; sum(u) = minn(u) = maxx(u) = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(u), l, mid), build(rson(u), mid + 1, r); pushup(u);&#125;void modify_range_add(int u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; tag(u) += val; sum(u) += 1ll * val * (r - l + 1); minn(u) += val; maxx(u) += val; return; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify_range_add(lson(u), l, mid, ql, qr, val); if (mid &lt; qr) modify_range_add(rson(u), mid + 1, r, ql, qr, val); pushup(u);&#125;void modify_range_divide(int u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; int dmin = minn(u) - floor(1.0 * minn(u) / val), dmax = maxx(u) - floor(1.0 * maxx(u) / val); if (dmin == dmax) &#123; tag(u) -= dmin; sum(u) -= 1ll * dmin * (r - l + 1); minn(u) -= dmin; maxx(u) -= dmin; return; &#125; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify_range_divide(lson(u), l, mid, ql, qr, val); if (mid &lt; qr) modify_range_divide(rson(u), mid + 1, r, ql, qr, val); pushup(u);&#125;int query_range_min(int u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return minn(u); pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1, ret = inf; if (ql &lt;= mid) ret = min(ret, query_range_min(lson(u), l, mid, ql, qr)); if (mid &lt; qr) ret = min(ret, query_range_min(rson(u), mid + 1, r, ql, qr)); return ret;&#125;ll query_range_sum(int u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return sum(u); pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; ll ret = 0; if (ql &lt;= mid) ret += query_range_sum(lson(u), l, mid, ql, qr); if (mid &lt; qr) ret += query_range_sum(rson(u), mid + 1, r, ql, qr); return ret;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;Q); for (int i = 0; i &lt; N; ++i) scanf("%d", &amp;a[i]); build(R, 0, N - 1); for (int i = 1; i &lt;= Q; ++i) &#123; int op, l, r, x; scanf("%d%d%d", &amp;op, &amp;l, &amp;r); if (op == 1) scanf("%d", &amp;x), modify_range_add(R, 0, N - 1, l, r, x); else if (op == 2) scanf("%d", &amp;x), modify_range_divide(R, 0, N - 1, l, r, x); else if (op == 3) printf("%d\n", query_range_min(R, 0, N - 1, l, r)); else printf("%lld\n", query_range_sum(R, 0, N - 1, l, r)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CSP-S复习计划]]></title>
    <url>%2F2019%2F10%2F21%2Fschedule-2019-CSP%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. 85c490abb01fc09fd54333ab009c43f46b526a149e95e2c3ce3e781391f278370e49dee44988ca64a1b4e562f6e357e69344ae949d20c43c313436d3389e7cd1c27cd0b32553ba0acec8c64a5304fe472f51b258d1a325eaa3084c733821e698ac22423c3f05397b809b41dfa828027c1e5c01db7cacb8d0e52b7b1fdea332f34dec290364164cdb74bebc02358b219e8a7a5e963049d7513b6e69b9ba631d6ae93fe4d416dbb9f0373ce1cfd626fd76206fecd98093a47dfbec4bc646116382369845811f18e529f7df21a31ad90ba96fbfefb067db8744ffdb637a09cf47fcca0c8bc656a5fb0bdb31bcbe4734d79fc52486126afab5b8fecb8c1e0f6d995a5af08802a2e1b6e15b4e630852db4f83ab6380f3d074a8934414cb3f9710f3ddebb967ad7bbdf443e012e9eec6ed4379d649c9ec889dfa5952851330118c492474c77de213942a87b33d40b60ecf44d4e40d6e6f696a17f614b3d98be4575d0a97d69a8287fad8d514de7a5453a91f618a46b79f646324ca9da1b16d1bb885f19d65dac68ca57e47e3d70bd7d94abed2143a60f4141e16e4274d78fee8c6c744e078e96dba68d2855567952670277fb185b5c3c1be201f123f03ee3e937d6cf6bc7b8f95a02a7d2feebb090d5507c3ed5ed947d4841f72630401dcb49e0240f9dbce98d2211431d7a2a2f5e9eea2e803c694f95d8288ade8cee9db9829ab0a688c0cb485da4f19e12b4d5624bfd381e012c6bc94b512ce5f625dcf2b5abfe2e5f9720f5c2e4396e3dd72753ea18a5413d1cc1326b466874b432c71da26eb8a8222f5b98b6f2be15b224fb646493e4ec5481851240ab62b19ddf0851388eb1bcd598ee08fb83dbb98211a00abd9a8d31b4b27273a38216249da4775c0f35e2ae119dae2a4c74fef29fa4dd946f3f95d5c2c77085179a353ae244b79e32ce9005772c3e08537692e8ba6339e31d519be8b825d59a4d7884a5f999d9b233780c8389cc23dc3a802c42119fd2229f194edae6f66fb00d7f9df392500856a8ae01d97506685f317f1b65fa344c89d08997c253ec89ef9d3efc201f15aa2a69f3c2bf03c8f0d69672c72887fd01f3c9880aea7ee876eb35df92d1e10b73515d6c12225009c61297d009976d39531026a3eb7e3d8626b2faef2b1a272886b51bd2df749cfb9e63f970d19ccdc3e2d0fccc0b8e6fd86f144830009a31e3ea09477f3b428de939cbdbe50ffd3fc1f6a0b27984b957618b27b97c8d56021ece0d5ab485382c7378c9b9435d9f6241ab271eefc4a79e4e8965836270950e4fe1f0549fc13b31c8ec3df5d81ae1e1dec38674f42b73681e7b7fa5a5a155e5204a2d1ec95c749af73339d14b6b84399c179b32d4f983559698456bad402bf1835b280d2e4d867c55041107080efe2c9baa58ec1fe72023245965656adc3a3ac054c05264cce5a523fc95c3f2633c9f630831ad5ab9715b1920cd67d4c48d55fefe04da6b4f91ec58b6bebf9c36d744da2857ac8f2a90dabe18f661fbaf16077a9f7f3304ba73139b49ddfdc9841007b904a0dd45ba30f8c3f88e0cacbc1ae02a6e011ee32243f454f1ab27aea44b7e1b3dcec7c25c8e330b4e26a4008747d1ecfdcb429a5c5825999ca7dc90dc4ba9a0b292723344cda4900b94d38497c79489b4c56415d9a0567bf224a2ba1d76b84b985e92ac37d6486d843275bb13c343f81faa2e83c305d51a76f0d9f058531d6e8e1c35db98b42c35569d4db24b39b419b0c7cbaa64b4afa30821ba835a6d8de2794d81a29b30b59fbc75de8d796abf9e353066cca2e57be19472ec4120215b07ab5095281fe5f468658caf8516e21190323df22b598916c6fbfd0bb1d3f60a67808ad155eab7cf8de522f8728cafd43dc3e37465e14384c1283d8c07c4c149c96b7d499892f70b5cf4743ad8aaa58fbaa90eb5bcf634302a713d41c71ed377277491ffad55ccfa907b594d4508c4c9dbe2952e4c6b7860b0dccc0ceece1e54bc7e27cb6baca07bc465c5247aed6deae1d5af21951091fd51cf5adf4d01e93b613c7e95158ecb4bc21dac09ea9ce7603931389bcb2485b8f27990f03674457c899ac02ef3fdfa53dcb15e2bf33b5bbcaa4a1940f5e3a5ade8230d3f692df02f5ac691d1c9733ac55ddb40b3a6de78d886f7479e503610e920d9547dd887a010e566ffa8ca9900ab8de0d1095868bdb0d6b2cdd28caff7a1626e8c35b487f72979ac00a453db8cf138c87cdbf81ad65ca9f12211da497d868531410c461c41d271c961b9a26451a4f95894e8946c60aa9af875b9bffdf546d55b0d021cc4bf2ca4fd6b267e5bf998cc64589c050fa1a4ba8297d8b9da5d18ad30e60a36832e23793649e9f187e2d04e88523e0269a2c14cd245b297661a19eee3f9a3de87a69f7e38462d907946ad3abce2e8b8f08eff79443d12a9e96dbc46f7c16e41ba3f16ed47a7dd35fa9896149ed8e4c318dbc1b6ad55f2e8d5a9244d38dc358b3b0d1d8c7d93f4f6684a169803809487cbfe657cbecaa6c6dd9ee0456122a8e61fe9f70ae2dd281126fc810da9f25a29741d04c2dae3719bd8aac798abcb5b2c3478ab1b4871081649f756abb5e6028f909a0ce62c7ff38271d6dfee610fee1f00ebd0dfa3b057083c212b1bac824876d4138fa5cc7154c114e07c30393266b691efbc5171b723a45d4eb2e17399f6531235d8f9bcfc877023c5cd39a06345f13ed28fd89992ce214529a2bbf269051d0040e3473a8397ad49510ff64a742b2dd58cf189f34daa3c17288313773a16b5a2d8e00fc1e8f087d9fe6a0138e15d899066e03558fda049f32591312591ecb5d3d41c5b0cdeae66c28069c772a6ea9441d6775ff90671acc8f7c65f9248cc6e8856824cb69cfa4572485a1b10c4c7c8ef989b6af54c6d503cc63b175a4c3537e395c1f90749969035f85e254c1c79b464271f6df4039f4c3cbee9e401af073f36cea61d73b92786e74ee60cc911e2802b731d4791942839743278d23a518518303454bf66e1d5e66897ff9638ff8b7ebb2534a64a87c5453410bb8451b728f17d7fc20b11ea461e93cc624541ce9f11af510028bbe3541ba80366a59476afd26f7449a45132d3db720be]]></content>
      <categories>
        <category>计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板库]]></title>
    <url>%2F2019%2F10%2F21%2Ftemplates%2F</url>
    <content type="text"><![CDATA[Hey, password is required here. 98121eb8c2612220489dbf02f23ee94e]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6495树]]></title>
    <url>%2F2019%2F10%2F19%2Fsolution-loj-6495%2F</url>
    <content type="text"><![CDATA[题目链接(LibreOJ) 题目概括征集中~ 重金（5 RMB）征集状压 dp 解法~ @所有人 这题也太巧妙了叭！ ——Mr.G Solution 1 : $O(n^4)$注意到节点 2 的父节点一定为 1；因此可以将以 2 为根的子树与剩余部分分开讨论。 定义状态 $f[i][j]$ 表示有 $i$ 个节点，深度为 $j$ 的方案数。 设以 2 为根的子树中共有 $x$ 个节点。情况一：子树 2 的深度恰好为 $j-1$，剩余部分的深度任意；情况二：子树 2 的深度任意，剩余部分的深度恰好为 $j$。 由于两棵子树的节点编号为 $3…i$ 间的任意整数，所以求出方案数之后需乘上标号的方案数。 f[i][j]=\sum_{x=1}^{i-1}[\sum_{k=1}^{j}f[x][j-1]\times f[i-x][k]\times {i-2\choose x-1}+\sum_{k=1}^{j-2}f[x][k]\times f[i-x][j]\times{i-2\choose x-1}]对于期望，只需将 $\sum_{i=1}^n f[n][i]\times i$ 除以 $(n-1)!$ 即可。 对于四舍五入，可打表。（正经） 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 30;const int tb[] = &#123;0, 1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6&#125;;ll n, p;ll fac[maxn], inv[maxn], facinv[maxn];inline int C(int n, int m) &#123; return fac[n] * facinv[n - m] % p * facinv[m] % p;&#125;ll f[maxn][maxn];ll ans = 0;int main() &#123; cin &gt;&gt; n &gt;&gt; p; fac[0] = fac[1] = inv[1] = facinv[0] = facinv[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; inv[i] = (p - p / i) * inv[p % i] % p; fac[i] = fac[i - 1] * i % p; facinv[i] = facinv[i - 1] * inv[i] % p; &#125; f[1][1] = 1, f[2][2] = 1; for (int i = 3; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int x = 1; x &lt;= i - 1; ++x) &#123; int t1 = 0, t2 = 0; for (int k = 1; k &lt;= j; ++k) t1 = (t1 + f[x][j - 1] * f[i - x][k] % p * C(i - 2, x - 1) % p) % p; for (int k = 1; k &lt;= j - 2; ++k) t2 = (t2 + f[x][k] * f[i - x][j] % p * C(i - 2, x - 1) % p) % p; f[i][j] = (f[i][j] + t1 + t2) % p; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[n][i] * i) % p; for (int i = 1; i &lt;= n - 1; ++i) ans = (ans * inv[i]) % p; cout &lt;&lt; tb[n] &lt;&lt; endl &lt;&lt; ans; return 0;&#125; Solution 2 : $O(2^n*n^2)$状压 dp 解法]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数dp</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6513足球大战]]></title>
    <url>%2F2019%2F10%2F19%2Fsolution-loj-6513%2F</url>
    <content type="text"><![CDATA[题目链接(LibreOJ) 足球比赛共 $n$ 秒中，主队每秒进球概率为 $p$，客队每秒进球概率为 $q$，求主队获胜概率。 $n \le 10000000$ 记 $f(i,j)$ 表示 $n$ 秒种后，主队进 $i$ 个球，客队进 $j$ 个球的概率。则有： f(i,j)={n \choose i}\times p^i\times (1-p)^{n-i} \times {n\choose j}\times q^j \times (1-q)^{n-j}要使得 $i&gt;j$ ，即求： \sum_{i=1}^n\sum_{j=0}^{i-1}{n\choose i}\times p^i\times (1-p)^{n-i}\times {n\choose j}\times q^j \times (1-q)^{n-j}化简，得： \sum_{i=1}^n {n\choose i}\times p^i\times (1-p)^{n-i}\times(\sum_{j=0}^{i-1}{n\choose j}\times q^j \times (1-q)^{n-j})$O(n)$ 预处理逆元与 $p$、$q$ 的 $n$ 次方即可。组合数可以递推计算以卡常。 注意实现细节，本题还是挺水的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000005;const int mod = 1e9 + 7;inline int qpow(int a, int b) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1ll * ret * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;int inv[maxn];int n, ans;int p, q, p2, q2;int invp2, invq2;int pa, pb, qa, qb;int powp, powq;int powp2, powq2;int sq;int C;int main() &#123; scanf("%d", &amp;n); scanf("%d%d", &amp;pa, &amp;pb); p = 1ll * pa * qpow(pb, mod - 2) % mod; p2 = (1 - p + mod) % mod; scanf("%d%d", &amp;qa, &amp;qb); q = 1ll * qa * qpow(qb, mod - 2) % mod; q2 = (1 - q + mod) % mod; if (p == 1) return printf("%d", (1 - qpow(q, n) + mod) % mod), 0; inv[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod; &#125; C = 1; powp = 1, powq = 1; powp2 = qpow(p2, n), powq2 = qpow(q2, n); invp2 = qpow(p2, mod - 2), invq2 = qpow(q2, mod - 2); int tp = 1ll * powp * powp2 % mod, tq = 1ll * powq * powq2 % mod; int mp = 1ll * p * invp2 % mod, mq = 1ll * q * invq2 % mod; sq = powq2; for (int i = 1; i &lt;= n; ++i) &#123; C = 1ll * C * (n - i + 1) % mod * inv[i] % mod; tp = 1ll * tp * mp % mod; tq = 1ll * tq * mq % mod; ans = (ans + 1ll * tp % mod * sq % mod * C) % mod; sq = (sq + 1ll * tq % mod * C) % mod; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6498农民]]></title>
    <url>%2F2019%2F10%2F16%2Fsolution-loj-6498%2F</url>
    <content type="text"><![CDATA[题目链接(LibreOJ) 题目概括征集中~ @oy么么哒 神仙码量题。 观察题意，进行问题转化。对于树上每一条边，可以通过它的肥料权值必定是一段区间：若这条边连接父节点与左儿子，则对应区间为 $(-\infty,a[\text{fa}])$；反之，则为 $(a[\text{fa}], \infty)$。 因此，我们需要维护一棵线段树，每个节点存储状态值 0/1 以及权值 val 。需要支持以下操作： 单点权值修改 区间状态值翻转 区间查询状态为 0/1 的最值 具体地，在线段树的每个节点上维护 max0, min0, max1, min1 。区间状态值翻转则只需交换 max0, max1 和 min0, min1。区间查询与单点修改不再赘述。 对二叉树进行树链剖分，每次查询只需查找该节点到根节点的限制范围；若该节点权值在范围之内，则可以吸收到肥料，反之不能。 注意：线段树的 max、min需要赋极值作为初值；交换时需理清变量所代表的意义 代码实现细节极多，尤其是线段树异常毒瘤。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;using namespace std;#define lson(u) node[u].l#define rson(u) node[u].r#define val(u) node[u].val#define tag(u) node[u].tagconst int maxn = 100005;const int inf = 0x3f3f3f3f;struct Node &#123; int l, r, val[2][2]; int tag;&#125;node[maxn * 3];int cnt = 0, R;pair&lt;int, int&gt; t[maxn];inline void pushdown(int u) &#123; if (tag(u)) &#123; swap(val(lson(u))[0][0], val(lson(u))[1][0]); swap(val(lson(u))[0][1], val(lson(u))[1][1]); swap(val(rson(u))[0][0], val(rson(u))[1][0]); swap(val(rson(u))[0][1], val(rson(u))[1][1]); tag(lson(u)) ^= 1, tag(rson(u)) ^= 1; tag(u) = 0; &#125;&#125;inline void pushup(int u) &#123; val(u)[0][0] = min(val(lson(u))[0][0], val(rson(u))[0][0]); val(u)[0][1] = max(val(lson(u))[0][1], val(rson(u))[0][1]); val(u)[1][0] = min(val(lson(u))[1][0], val(rson(u))[1][0]); val(u)[1][1] = max(val(lson(u))[1][1], val(rson(u))[1][1]);&#125;void build(int&amp; u, int l, int r) &#123; u = ++cnt; val(u)[0][0] = val(u)[1][0] = inf; val(u)[0][1] = val(u)[1][1] = -inf; if (l == r) &#123; int d = t[l].first, w = t[l].second; val(u)[d][0] = val(u)[d][1] = w; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson(u), l, mid); build(rson(u), mid + 1, r); pushup(u);&#125;void modify_range_reverse(int u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; swap(val(u)[0][0], val(u)[1][0]); swap(val(u)[0][1], val(u)[1][1]); tag(u) ^= 1; return; &#125; pushdown(u); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify_range_reverse(lson(u), l, mid, ql, qr); if (mid &lt; qr) modify_range_reverse(rson(u), mid + 1, r, ql, qr); pushup(u);&#125;void modify_point(int u, int l, int r, int p, int val) &#123; if (l == r) &#123; if (val(u)[0][0] != inf) val(u)[0][0] = val(u)[0][1] = val; else val(u)[1][0] = val(u)[1][1] = val; return; &#125; pushdown(u); int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) modify_point(lson(u), l, mid, p, val); else modify_point(rson(u), mid + 1, r, p, val); pushup(u);&#125;pair&lt;int, int&gt; query_range(int u, int l, int r, int ql, int qr) &#123; // first: 1:max // second: 0:min if (ql &lt;= l &amp;&amp; r &lt;= qr) return make_pair(val(u)[1][1], val(u)[0][0]); pushdown(u); int mid = (l + r) &gt;&gt; 1; int first = -inf, second = inf; if (ql &lt;= mid) &#123; pair&lt;int, int&gt; t = query_range(lson(u), l, mid, ql, qr); first = max(first, t.first); second = min(second, t.second); &#125; if (mid &lt; qr) &#123; pair&lt;int, int&gt; t = query_range(rson(u), mid + 1, r, ql, qr); first = max(first, t.first); second = min(second, t.second); &#125; return make_pair(first, second);&#125;int N, M;vector&lt;int&gt; G[maxn];int fa[maxn];int dir[maxn], w[maxn];int dep[maxn], size[maxn], son[maxn];int top[maxn], dfn[maxn], dfn_idx;void dfs1(int u) &#123; dep[u] = dep[fa[u]] + 1; size[u] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; dfs1(v); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int topc) &#123; dfn[u] = ++dfn_idx; t[dfn[u]] = make_pair(dir[u], w[fa[u]]); top[u] = topc; if (son[u]) dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == son[u]) continue; dfs2(v, v); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (int i = 1; i &lt;= N; ++i) &#123; int x, y; scanf("%d%d%d", &amp;w[i], &amp;x, &amp;y); dir[x] = 0, dir[y] = 1; fa[x] = fa[y] = i; if (x) G[i].push_back(x); if (y) G[i].push_back(y); &#125; dfs1(1); dfs2(1, 1); build(R, 1, N); while (M--) &#123; int op, x, y; scanf("%d%d", &amp;op, &amp;x); if (op == 1) &#123; scanf("%d", &amp;y); for (vector&lt;int&gt;::iterator it = G[x].begin(); it != G[x].end(); it++) &#123; int v = *it; modify_point(R, 1, N, dfn[v], y); &#125; w[x] = y; &#125; else if (op == 2) &#123; modify_range_reverse(R, 1, N, dfn[x], dfn[x] + size[x] - 1); modify_range_reverse(R, 1, N, dfn[x], dfn[x]); &#125; else &#123; int val = w[x]; int first = -inf, second = inf; while (top[x] != 1) &#123; pair&lt;int, int&gt; t = query_range(R, 1, N, dfn[top[x]], dfn[x]); first = max(first, t.first); second = min(second, t.second); x = fa[top[x]]; &#125; if (x != 1) &#123; pair&lt;int, int&gt; t = query_range(R, 1, N, 2, dfn[x]); first = max(first, t.first); second = min(second, t.second); &#125; if (val &gt; first &amp;&amp; val &lt; second) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6515贪玩蓝月]]></title>
    <url>%2F2019%2F10%2F14%2Fsolution-loj-6515%2F</url>
    <content type="text"><![CDATA[题目链接(LibreOJ) 题目概括大力征集中~ 提示：动态背包 一道神仙题。 Solution 1: 在线类似动态 dp，本题要求对双端队列操作的同时进行若干次 01 背包处理。 考虑到双端队列的性质，我们可以维护两个栈，用来模拟双端队列。需要注意的是，如果在一个栈执行多次删除操作后该栈为空，则需将另一个栈中所有元素取出进行暴力重构。通过均摊复杂度分析可得复杂度仍为线性。 均摊复杂度证明？ 记录动态规划数组 $f1[i][j]$ 和 $f2[i][j]$ ，分别表示取第 1/2 个栈中的前 $i$ 件物品得到的最有价值。该数组在栈中插入元素时需要暴力计算。 考虑如何统计答案。假设在左右栈中取出特征值总和分别为 $x,y$，则 $(x+y)\mod p\in [l,r]$。不难发现，在确定 $x,y$ 中的一个之后，另一个所在的范围即为一个区间。将对应的 $f$ 数组做一次单调队列统计答案即可。 注意：暴力重构栈时，若需要重构的栈长度为 1 ，则必须将该元素移动至另一个栈；否则会导致删除元素时出现问题 代码异常毒瘤，尤其是单调队列部分，强烈建议手推一遍。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 50005;const ll inf = 1ll * 50005 * 1000000000;int TestCase;int M;ll P;pair&lt;int, ll&gt; s1[maxn], s2[maxn];pair&lt;int, ll&gt; t[maxn];ll f1[maxn][505], f2[maxn][505];int len1, len2;ll q[maxn], l, r;inline void Add1(pair&lt;int, ll&gt; t) &#123; s1[++len1] = t; int w = t.first; ll v = t.second; for (int i = 0; i &lt; P; ++i) &#123; f1[len1][i] = max(f1[len1 - 1][i], f1[len1 - 1][(i - w + P) % P] + v); &#125;&#125;inline void Add2(pair&lt;int, ll&gt; t) &#123; s2[++len2] = t; int w = t.first; ll v = t.second; for (int i = 0; i &lt; P; ++i) &#123; f2[len2][i] = max(f2[len2 - 1][i], f2[len2 - 1][(i - w + P) % P] + v); &#125;&#125;inline void Rebuild1() &#123; int cnt = 0; for (int i = 1; i &lt;= len1; ++i) t[++cnt] = s1[i]; int mid = cnt &gt;&gt; 1; mid++; for (int i = mid; i &gt;= 1; --i) Add2(t[i]); len1 = 0; for (int i = mid + 1; i &lt;= cnt; ++i) Add1(t[i]);&#125;inline void Rebuild2() &#123; int cnt = 0; for (int i = 1; i &lt;= len2; ++i) t[++cnt] = s2[i]; int mid = cnt &gt;&gt; 1; mid++; for (int i = mid; i &gt;= 1; --i) Add1(t[i]); len2 = 0; for (int i = mid + 1; i &lt;= cnt; ++i) Add2(t[i]);&#125;inline void Solve(int ql, int qr) &#123; ll *x = f1[len1], *y = f2[len2]; ll ans = -1; l = 0, r = 0, q[0] = 0; for (int i = P - qr + ql; i &lt; P; ++i) &#123; while (l &lt; r &amp;&amp; x[(q[r - 1] + P) % P] &lt;= x[i]) r--; q[r++] = i - P; &#125; for (int i = 0; i &lt; P; ++i) &#123; while (l &lt; r &amp;&amp; q[l] &lt; i - qr + ql) l++; while (l &lt; r &amp;&amp; x[(q[r - 1] + P) % P] &lt;= x[i]) r--; q[r++] = i; ans = max(ans, x[(q[l] + P) % P] + y[(qr - i + P) % P]); &#125; printf("%lld\n", ans);&#125;int main() &#123; scanf("%d", &amp;TestCase); scanf("%d%lld", &amp;M, &amp;P); for (int i = 1; i &lt; P; ++i) f1[0][i] = f2[0][i] = -inf; while (M--) &#123; string op; cin &gt;&gt; op; if (op == "IF") &#123; int w; ll v; scanf("%d%lld", &amp;w, &amp;v), w %= P; Add1(make_pair(w, v)); &#125; else if (op == "IG") &#123; int w; ll v; scanf("%d%lld", &amp;w, &amp;v), w %= P; Add2(make_pair(w, v)); &#125; else if (op == "DF") &#123; if (len1 == 0) Rebuild2(); len1--; &#125; else if (op == "DG") &#123; if (len2 == 0) Rebuild1(); len2--; &#125; else if (op == "QU") &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); Solve(l, r); &#125; &#125; return 0;&#125; #### Solution 2: 离线 离线解法]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-2128数字串拆分]]></title>
    <url>%2F2019%2F10%2F12%2Fsolution-loj-2128%2F</url>
    <content type="text"><![CDATA[题目链接(Luogu) 题目链接(LibreOJ) 题目概括大力征集中~ 一道神仙题。对矩阵初学者极不友好。 $f$ 函数的计算非常简单，递推公式如下： f(i)=f(i-1)+f(i-2)+..+f(i-m)容易看出， $f(i)$ 可以使用矩阵加速递推。以 $m=3$ 为例，构造矩阵 A=\left[ \begin{matrix} 1 & 1 & 1 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \end{matrix} \right]那么 $f(n)$ 即为 $(A^n)_{1,1}$ 。 但我们要求的是 $g(S)$ 。考虑将 $g(S)$ 表示为矩阵的形式，最终答案为矩阵的第 $[1,1]$ 项。 考虑 $g(123)$ 的推导。 \begin{align*} g(123) &= f(1+2+3)+f(12+3)+f(1+23)+f(123) \\ &= A^{1+2+3}+A^{12+3}+A^{1+23}+A^{123} \\ &= A^1\times A^2\times A^3+A^{12}\times A^3+A^1\times A^{23}+A^{123} \end{align*}转化为以上形式后，记 $g’(n)$ 为将数字 $S$ 的前 $n$ 项分解后得到的矩阵；在本例中，$g’(3)=g(123)$ 。 可以得到 $g’(i)$ 的递推公式： g'(i)=g'(i-1)\times A^{\text{num[i,i]}}+g'(i-2)\times A^{\text{num[i-1,i]}}+..+g'(0)\times A^{\text{num[1,i]}}其中 $\text{num[l,r]}$ 表示字符串中 $[l,r]$ 区间所对应的数字。例如当 $S=”12345”$ ，$\text{num[2,4]}=234$ 。 考虑 $A^{\text{num[l,r]}}$ 的计算。可以通过预处理加速计算。记 P[i][j]=A^{i*10^j}使用该数组，可以在 $O(n)$ 时间复杂度内计算 $A^{\text{num[l,r]}}$ 。 至此，算法骨架已经成型；时间复杂度为 $O(n*m^3+n^2*m^3)$ 。实现时需要注意细节优化（如计算 $g’$ 时使用恰当的循环顺序）。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 998244353;struct Matrix &#123; int m, n; ll g[6][6];&#125;;Matrix mul(Matrix a, Matrix b) &#123; Matrix ret; ret.m = a.m, ret.n = b.n; for (int i = 1; i &lt;= ret.n; ++i) &#123; for (int j = 1; j &lt;= ret.m; ++j) &#123; ret.g[i][j] = 0; for (int k = 1; k &lt;= a.n; ++k) ret.g[i][j] = (ret.g[i][j] + a.g[i][k] * b.g[k][j]) % mod; &#125; &#125; return ret;&#125;Matrix add(Matrix a, Matrix b) &#123; Matrix ret; ret.m = a.m, ret.n = a.n; for (int i = 1; i &lt;= a.n; ++i) for (int j = 1; j &lt;= a.m; ++j) ret.g[i][j] = (a.g[i][j] + b.g[i][j]) % mod; return ret;&#125;Matrix power10(Matrix a) &#123; Matrix ret = a; ret = mul(ret, ret); ret = mul(ret, ret); ret = mul(ret, a); ret = mul(ret, ret); return ret;&#125;void Init_Unit_Matrix(Matrix&amp; a, int n) &#123; a.m = a.n = n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a.g[i][j] = (i == j) ? 1 : 0;&#125;void Init_Empty_Matrix(Matrix&amp; a, int n) &#123; a.m = a.n = n; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a.g[i][j] = 0;&#125;char s[505];int N, M;Matrix A;Matrix P[10][505];Matrix Q[505];Matrix f[505];int main() &#123; cin &gt;&gt; (s + 1); N = strlen(s + 1); cin &gt;&gt; M; Init_Unit_Matrix(P[0][0], M); A.n = A.m = M; for (int i = 1; i &lt;= M; ++i) &#123; for (int j = 1; j &lt;= M; ++j) &#123; A.g[i][j] = 0; if (i == 1) A.g[i][j] = 1; if (i - 1 == j) A.g[i][j] = 1; &#125; &#125; for (int i = 1; i &lt;= 9; ++i) &#123; P[i][0] = mul(P[i - 1][0], A); &#125; for (int j = 1; j &lt;= N; ++j) &#123; for (int i = 0; i &lt;= 9; ++i) &#123; P[i][j] = power10(P[i][j - 1]); &#125; &#125; Init_Unit_Matrix(f[0], M); for (int i = 1; i &lt;= N; ++i) &#123; Init_Empty_Matrix(f[i], M); Matrix t; Init_Unit_Matrix(t, M); for (int j = i, c = 0; j &gt;= 1; --j, ++c) &#123; t = mul(t, P[s[j] - '0'][c]); f[i] = add(f[i], mul(f[j - 1], t)); &#125; &#125; cout &lt;&lt; f[N].g[1][1]; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解题报告-NOIP2016提高组初赛]]></title>
    <url>%2F2019%2F10%2F11%2Fsolution-noip2016pre%2F</url>
    <content type="text"><![CDATA[NOIP 2016 提高组初赛试题 不完全解读！ 完结~ 第 4 题 与二进制小数 0.1 相等的八进进制数是（ ）。 A. 0.8 B. 0.4 C. 0.2 D. 0.1 二进制与八进制、十六进制之间可以使用技巧进行转化 第 5 题 以比较作为基本运算，在 N 个数中找最小数的最少运算次数为（ ）。 A. N B. N−1 C. N^2 D. logN 第二个数至第 N 个数依次比较 第 6 题 表达式 a*(b+c)-d 的后缀表达形式为（ ）。 A. abcd*+- B. abc+*d- C. abc*+d- D. -+*abcd 中缀表达式对应二叉树的中序遍历；后缀表达式对应后根遍历 第 8 题 G 是一个非连通简单无向图，共有 28 条边，则该图至少有（ ）个顶点。 A. 10 B. 9 C. 8 D. 7 对于连通的简单无向图，点数为 n，则最多有 n(n-1)/2 条边。 对于本题，构造 8 个节点的完全图再附带一个节点即可 第 9 题 某计算机的 CPU 和内存之间的地址总线宽度是 32 位（bit），这台计算机最多可以使用（ ）的内存。 A. 2GB B. 4GB C. 8GB D. 16GB 可以寻址的最大地址为 2^32 B。 2^32 B = 2 ^ 22 KB = 2 ^ 12 MB = 4 GB 第 11 题 有 7 个一模一样的苹果，放到 3 个一样的盘子中，一共有（ ）种放法。 A. 7 B. 8 C. 21 D. 3^7 暴力枚举 第 13 题 周末小明和爸爸妈妈三个人一起想动手做三道菜。小明负责洗菜、爸爸负责切菜、妈妈负责炒菜。假设做每道菜的顺序都是：先洗菜 10 分钟，然后切 菜 10 分钟，最后炒菜 10 分钟。那么做一道菜需要 30 分钟。注意：两道不同的菜的相同步骤不可以同时进行。例如第一道菜和第二道的菜不能同时洗，也不能同时切。那么做完三道菜的最短时间需要（ ）分钟。 A. 90 B. 60 C. 50 D. 40 问题转化，求拓扑排序最长路 第 16 题 以下属于无线通信技术的有（ ）。 A. 蓝牙 B. WiFi C. GPRS D. 以太网 GPRS: 通用分组无线服务（英语：General Packet Radio Service，缩写：GPRS）是GSM移动电话用户可以使用的一种移动数据业务/技术。它经常被描述成“2.5G”，意指这项技术介于第二代（2G）与第三代（3G）移动通讯技术之间。它是利用GSM网络中未使用的TDMA信道，提供中速的数据传输服务。起初有人想通过扩展GPRS来覆盖其他标准，只是这些网络都正在转而使用GSM标准，这样GSM就成了GPRS唯一能够使用的网络。GPRS在Release 97之后被集成进GSM标准，起先它是由ETSI标准化，但是现在已经移交3GPP负责。——中文维基百科 以太网（英语：Ethernet）是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是当前应用最普遍的局域网技术，取代了其他局域网标准如令牌环、FDDI和ARCNET。 以太网的标准拓扑结构为总线型拓扑，但当前的快速以太网（100BASE-T、1000BASE-T标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型；但在逻辑上，以太网仍然使用总线型拓扑和CSMA/CD（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。 ——中文维基百科 第 21 题 一个 1×8 的方格图形（不可旋转）用黑、白两种颜色填涂每个方格。如果每个方格只能填涂一种颜色，且不允许两个黑格相邻，共有_种填涂方案。 $f[i][0/1]$ 表示前 $i$ 个方格，最后一个方格为 黑/白 的方案数。 化简状态转移方程发现 $f[i][0]$ 为斐波那契数列。 第 24 题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; using namespace std;int main()&#123; char a[100][100], b[100][100]; string c[100]; string tmp; int n, i = 0, j = 0, k = 0, total_len[100], length[100][3]; cin &gt;&gt; n; getline(cin, tmp); for (i = 0; i &lt; n; i++) &#123; getline(cin, c[i]); total_len[i] = c[i].size(); &#125; for (i = 0; i &lt; n; i++) &#123; j = 0; while (c[i][j] != ':') &#123; a[i][k] = c[i][j]; k = k + 1; j++; &#125; length[i][1] = k - 1; a[i][k] = 0; k = 0; for (j = j + 1; j &lt; total_len[i]; j++) &#123; b[i][k] = c[i][j]; k = k + 1; &#125; length[i][2] = k - 1; b[i][k] = 0; k = 0; &#125; for (i = 0; i &lt; n; i++) &#123; if (length[i][1] &gt;= length[i][2]) cout &lt;&lt; "NO,"; else &#123; k = 0; for (j = 0; j &lt; length[i][2]; j++) &#123; if (a[i][k] == b[i][j]) k = k + 1; if (k &gt; length[i][1]) break; &#125; if (j == length[i][2]) cout &lt;&lt; "NO,"; else cout &lt;&lt; "YES,"; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 输入：3AB:ACDEbFBkBDAR:ACDBrTSARS:Severe Atypical Respiratory Syndrome输出：_ （注：输入各行前后均无空格） 观察程序，操作目的为判断冒号前的内容是否依次在冒号后的字符串中出现 第 25 题 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int lps(string seq, int i, int j)&#123; int len1, len2; if (i == j) return 1; if (i &gt; j) return 0; if (seq[i] == seq[j]) return lps(seq, i + 1, j - 1) + 2; len1 = lps(seq, i, j - 1); len2 = lps(seq, i + 1, j); if (len1 &gt; len2) return len1; return len2;&#125;int main()&#123; string seq = "acmerandacm"; int n = seq.size(); cout &lt;&lt; lps(seq, 0, n - 1) &lt;&lt; endl; return 0;&#125; 输出：_ 观察程序。找出最多的形如 axxxbxxxcxxxcxxxbxxxa中出现的字符 第 26 题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int map[100][100];int sum[100], weight[100];int visit[100];int n;void dfs(int node)&#123; visit[node] = 1; sum[node] = 1; int v, maxw = 0; for (v = 1; v &lt;= n; v++) &#123; if (!map[node][v] || visit[v]) continue; dfs(v); sum[node] += sum[v]; if (sum[v] &gt; maxw) maxw = sum[v]; &#125; if (n - sum[node] &gt; maxw) maxw = n - sum[node]; weight[node] = maxw;&#125;int main()&#123; memset(map, 0, sizeof(map)); memset(sum, 0, sizeof(sum)); memset(weight, 0, sizeof(weight)); memset(visit, 0, sizeof(visit)); cin &gt;&gt; n; int i, x, y; for (i = 1; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; map[x][y] = 1; map[y][x] = 1; &#125; dfs(1); int ans = n, ansN = 0; for (i = 1; i &lt;= n; i++) if (weight[i] &lt; ans) &#123; ans = weight[i]; ansN = i; &#125; cout &lt;&lt; ansN &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 输入：111 21 32 42 52 63 77 87 116 99 10输出：_ 求树的重心。 第 28 题 (交通中断）有一个小国家，国家内有 n 座城市和 m 条双向的道路，每条道路连接着两座不同的城市。其中 1 号城市为国家的首都。由于地震频繁可能导致某一个城市与外界交通全部中断。这个国家的首脑想知道，如果只有第i(i&gt;1)个城市因地震而导致交通中断时，首都到多少个城市的最短路径长度会发生改变。如果因为无法通过第 i 个城市而导致从首都出发无法到达某个城市，也认为到达该城市的最短路径长度改变。 对于每一个城市 i，假定只有第 i 个城市与外界交通中断，输出有多少个 城市会因此导致到首都的最短路径长度改变。 我们采用邻接表的方式存储图的信息，其中 head[x]表示顶点 x 的第一条 边的编号，next[i]表示第 i 条边的下一条边的编号，point[i]表示第 i 条边的终点，weight[i]表示第 i 条边的长度。（第一空 2 分，其余 3 分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAXN 6000#define MAXM 100000#define infinity 2147483647int head[MAXN], next[MAXM], point[MAXM], weight[MAXM];int queue[MAXN], dist[MAXN], visit[MAXN];int n, m, x, y, z, total = 0, answer;void link(int x, int y, int z)&#123; total++; next[total] = head[x]; head[x] = total; point[total] = y; weight[total] = z; total++; next[total] = head[y]; head[y] = total; point[total] = x; weight[total] = z;&#125;int main()&#123; int i, j, s, t; cin &gt;&gt; n &gt;&gt; m; for (i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; link(x, y, z); &#125; for (i = 1; i &lt;= n; i++) dist[i] = infinity; (1); queue[1] = 1; visit[1] = 1; s = 1; t = 1; // 使用 SPFA 求出第一个点到其余各点的最短路长度 while (s &lt;= t) &#123; x = queue[s % MAXN]; j = head[x]; while (j != 0) &#123; if ((2)) &#123; dist[point[j]] = dist[x] + weight[j]; if (visit[point[j]] == 0) &#123; t++; queue[t % MAXN] = point[j]; visit[point[j]] = 1; &#125; &#125; j = next[j]; &#125; (3); s++; &#125; for (i = 2; i &lt;= n; i++) &#123; queue[1] = 1; memset(visit, 0, sizeof(visit)); visit[1] = 1; s = 1; t = 1; while (s &lt;= t) &#123; // 判断最短路长度是否不变 x = queue[s]; j = head[x]; while (j != 0) &#123; if (point[j] != i &amp;&amp; (4) &amp;&amp; visit[point[j]] == 0) &#123; (5); t++; queue[t] = point[j]; &#125; j = next[j]; &#125; s++; &#125; answer = 0; for (j = 1; j &lt;= n; j++) answer += 1 - visit[j]; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; answer - 1 &lt;&lt; endl; &#125; return 0;&#125; 第 5 空：如果被断掉的边在最短路上 即 dis[u]+weight=dis[v] 则最短路长度发生改变]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6514文明]]></title>
    <url>%2F2019%2F10%2F11%2Fsolution-loj-6514%2F</url>
    <content type="text"><![CDATA[题目链接 题目概括大力征集中~ 首先感谢 这篇文章 让我学会了换根树链剖分的相关操作。 首先考虑查询次数为 1 的解法。将黈力所在的国家作为根节点，求出其他所有国家与根节点的中点。不难发现，求出的中点及其子树会被其他国家所占领。求出所有中点后，从根节点开始 dfs 整棵树，注意不能访问被标记出的中点。被访问到的节点总数即为所求。 考虑优化。用 “ dfs 序 + 线段树” 维护一个支持子树修改、子树查询的树形数据结构。每求出一个中点，就将中点及其子树的权值改为 1 。所有操作结束后，节点总数 $N$ 减去所有节点的权值总和即为所求。 对于查询次数不为 1 的数据，可以在上述数据结构中加上“换根”操作。具体实现可以参考 这篇文章 及我的代码。 略有点毒瘤。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;#define lson(u) node[u].l#define rson(u) node[u].r#define sum(u) node[u].sum#define tag(u) node[u].tagconst int maxn = 500005;struct Node &#123; int sum, l, r, tag;&#125;node[maxn * 3];int R, cnt;void build(int&amp; u, int l, int r) &#123; u = ++cnt; tag(u) = -1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson(u), l, mid); build(rson(u), mid + 1, r);&#125;inline void pushdown(int u, int l, int r) &#123; int mid = (l + r) &gt;&gt; 1; int llen = mid - l + 1, rlen = r - mid; if (tag(u) != -1) &#123; sum(lson(u)) = llen * tag(u); sum(rson(u)) = rlen * tag(u); tag(lson(u)) = tag(u); tag(rson(u)) = tag(u); tag(u) = -1; &#125;&#125;void modify(int u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; sum(u) = (r - l + 1) * val; tag(u) = val; return; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify(lson(u), l, mid, ql, qr, val); if (mid &lt; qr) modify(rson(u), mid + 1, r, ql, qr, val); sum(u) = sum(lson(u)) + sum(rson(u));&#125;int query(int u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return sum(u); pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1, ret = 0; if (ql &lt;= mid) ret += query(lson(u), l, mid, ql, qr); if (mid &lt; qr) ret += query(rson(u), mid + 1, r, ql, qr); return ret;&#125;int N, Q, K, root;vector&lt;int&gt; G[maxn];int f[maxn][20], dep[maxn];int dfn[maxn], dfn_idx, size[maxn];int p[maxn];void dfs(int u, int fa) &#123; size[u] = 1; dfn[u] = ++dfn_idx; dep[u] = dep[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt;= 19; ++i) f[u][i] = f[f[u][i - 1]][i - 1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs(v, u); size[u] += size[v]; &#125;&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (int i = 19; ~i; --i) if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; if (u == v) return u; for (int i = 19; ~i; --i) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];&#125;inline int Jump(int u, int d) &#123; for (int i = 19; ~i; --i) if (d - (1 &lt;&lt; i) &gt;= 0) u = f[u][i], d -= (1 &lt;&lt; i); return u;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;Q); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); build(R, 1, N); while (Q--) &#123; scanf("%d", &amp;K); for (register int i = 1; i &lt;= K; ++i) scanf("%d", &amp;p[i]); root = p[1]; for (register int i = 2; i &lt;= K; ++i) &#123; int t = p[i]; int lca = Lca(root, t); int dis = dep[t] + dep[root] - 2 * dep[lca]; if (dis &amp; 1) dis = (dis &gt;&gt; 1); else dis = (dis &gt;&gt; 1) - 1; int dis_root = dep[root] - dep[lca]; int dis_t = dep[t] - dep[lca]; int u = 0; // Get Middle Point if (dis &lt;= dis_t) &#123; u = Jump(t, dis); &#125; else u = Jump(root, dis_root + dis_t - dis); if (Lca(root, u) != u) // Situation II modify(R, 1, N, dfn[u], dfn[u] + size[u] - 1, 1); else &#123; // Situation III int v = Jump(root, dep[root] - dep[u] - 1); // * Find the nearest node * if (dfn[v] - 1 &gt;= 1) modify(R, 1, N, 1, dfn[v] - 1, 1); if (dfn[v] + size[v] &lt;= N) modify(R, 1, N, dfn[v] + size[v], N, 1); &#125; &#125; printf("%d\n", N - query(R, 1, N, 1, N)); modify(R, 1, N, 1, N, 0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>dfs序</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-2072独特的树叶]]></title>
    <url>%2F2019%2F10%2F10%2Fsolution-loj-2072%2F</url>
    <content type="text"><![CDATA[题目链接(Luogu) 题目链接(LibreOJ) 给定两棵树 $A$ 和 $B$，在 $B$ 中删除一个叶子节点后满足 $A$ 与 $B’$ 同构；求满足条件的编号最小的叶子节点。 $n \le 100000$ 感谢 @tth37 的贡献 这道题我们需要判断树是否同构。这需要借助 树哈希 。 一千个 OIer 中有一万种哈希写法。这里采用基于异或的树哈希。 \text{hash[u]}=\bigoplus_{v\in \text{son(u)}}\text{hash[v]}*\text{seed}+\text{size[v]}我们可以首先将 $A$ 上每个点作为根节点时的哈希值求出来，并扔到一个 map 里。然后在 $B$ 上枚举删除每个叶子节点后对应的哈希值，如果对应的哈希值出现过，则表明删去该叶子节点后可以形成同构。 该算法复杂度瓶颈在于求出 $A$ 对应的 $n$ 个哈希值。根据异或的相消性质，可以设计出类似树形 dp 的二次扫描与换根法在 $O(n)$ 时间复杂度求出所有哈希值。 听着简单，代码还是挺难写的。 代码如下：（极丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 100005;const ull seed = 1000000007;ull H[maxn], H2[maxn];ull size[maxn];vector&lt;int&gt; G1[maxn], G2[maxn];map&lt;ull, bool&gt; mp;int N, R;int ans = maxn;void dfs1(int u, int fa) &#123; H[u] = size[u] = 1; for (vector&lt;int&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); size[u] += size[v]; H[u] ^= (H[v] * seed + size[v]); &#125;&#125;void dfs2(int u, int fa) &#123; if (u != R) &#123; H2[u] = H[u] ^ ((H2[fa] ^ (H[u] * seed + size[u])) * seed + ((ull)N - size[u])); &#125; else H2[u] = H[u]; for (vector&lt;int&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs2(v, u); &#125;&#125;void dfs3(int u, int fa) &#123; H[u] = size[u] = 1; for (vector&lt;int&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs3(v, u); size[u] += size[v]; H[u] ^= (H[v] * seed + size[v]); &#125;&#125;void dfs4(int u, int fa) &#123; if (u != R) &#123; H2[u] = H[u] ^ ((H2[fa] ^ (H[u] * seed + size[u])) * seed + ((ull)N + 1 - size[u])); &#125; else H2[u] = H[u]; for (vector&lt;int&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs4(v, u); &#125;&#125;int main() &#123; scanf("%d", &amp;N); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G1[u].push_back(v); G1[v].push_back(u); &#125; R = 1; dfs1(1, 0); dfs2(1, 0); for (register int i = 1; i &lt;= N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G2[u].push_back(v); G2[v].push_back(u); &#125; for (register int i = 1; i &lt;= N; ++i) mp[H2[i]] = 1; R = 2; dfs3(2, 0); dfs4(2, 0); for (register int i = 1; i &lt;= 1; ++i) &#123; if ((int)G2[i].size() == 1) &#123; ull w = H2[G2[i][0]] ^ (H[i] * seed + 1); if (mp[w]) return printf("%d", i), 0; &#125; &#125; R = 1; dfs3(1, 0); dfs4(1, 0); for (register int i = 2; i &lt;= N + 1; ++i) &#123; if ((int)G2[i].size() == 1) &#123; ull w = H2[G2[i][0]] ^ (H[i] * seed + 1); if (mp[w]) return printf("%d", i), 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
        <tag>哈希(hash)</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1792种树]]></title>
    <url>%2F2019%2F10%2F04%2Fsolution-luogu-p1792%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个环，环上有 $n$ 个节点。选出 $m$ 个互不相邻的节点，使得选出节点的权值总和最大。 $n\le 200000$ 比较巧妙的贪心。 引理：如果 $A[i]$ 最大，在最终的方案中不可能只选 $A[i-1],A[i+1]$ 中的一个。 假设最终方案中只选了 $A[i-1]$，那么将 $A[i-1]$ 替换为 $A[i]$ 会导致答案更优。 因此，在取出节点 $i$ 之后，应该设置一个反悔的机会：将节点 $i$ 的权值改为 $A[i-1]+A[i+1]-A[i]$，表示放弃节点 $i$，并同时在 $i-1$、$i+1$ 位置种树。节点的相对位置关系可以用链表维护。 可删堆可以用两个普通的大根堆实现。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define pre(u) node[u].l#define nxt(u) node[u].r#define val(u) node[u].valusing namespace std;const int maxn = 200005;struct Node &#123; int l, r, val;&#125;node[maxn];struct Heap &#123; priority_queue&lt;pair&lt;int, int&gt; &gt; a, b; inline void push(pair&lt;int, int&gt; t) &#123;a.push(t);&#125; inline void pop() &#123; while (b.size() &amp;&amp; a.top() == b.top()) a.pop(), b.pop(); a.pop(); &#125; inline void erase(pair&lt;int, int&gt; t) &#123;b.push(t);&#125; inline pair&lt;int, int&gt; top() &#123; while (b.size() &amp;&amp; a.top() == b.top()) a.pop(), b.pop(); return a.top(); &#125;&#125;q;inline void del(int p) &#123; nxt(pre(p)) = nxt(p); pre(nxt(p)) = pre(p);&#125;int N, M;int main() &#123; scanf("%d%d", &amp;N, &amp;M); if (M * 2 &gt; N) return puts("Error!"), 0; for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;node[i].val), node[i].l = i - 1, node[i].r = i + 1, q.push(make_pair(node[i].val, i)); node[1].l = N, node[N].r = 1; int ans = 0; for (register int i = 1; i &lt;= M; ++i) &#123; ans += q.top().first; int p = q.top().second; q.pop(); val(p) = val(pre(p)) + val(nxt(p)) - val(p); q.erase(make_pair(val(pre(p)), pre(p))), q.erase(make_pair(val(nxt(p)), nxt(p))); q.push(make_pair(val(p), p)); del(pre(p)), del(nxt(p)); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-3166魔法树]]></title>
    <url>%2F2019%2F10%2F03%2Fsolution-loj-3166%2F</url>
    <content type="text"><![CDATA[题目链接 给定$n$个节点的树有，每个时间点$d$可以砍下一些边，可以收获得所有与根不连通且$d_i=d$的点的权值$w_i$，求获得的最大权值和。 $2 \le n \le 10^5$ 感谢@oy的贡献 这是一道非常漂亮的题！ 定义状态： $f[u][i]$ 表示在第 $i$ 天砍掉 $u-&gt;fa[u]$ 的一条边，所能获得的最多果汁数量。 状态转移方程： f[u][i]=\sum_{v\in son(u)}{(\max_{j=1}^{i}f[v][j])}解法一：用动态开点权值线段树维护 $f[u]$，转移时在线段树上操作即可。码量较大，常数较大。 解法二：不难发现 $f[u][1]$ 到 $f[u][k]$ 是单调不下降的，因此设 $g[u][i]=\max_{j=1}^i f[u][j]$。用差分数组维护 $g[u]$，观察到差分数组中非零元素个数不超过 $size[u]$，可以用集合（stl::map) 记录差分数组中的所有非零元素。 在集合合并时，采取 dsu on tree，复杂度 $O(n\log^2 n)$。本题的关键点在于如果当前位置有果实，那么还需要对差分数组进行一些修改：将差分数组的 $d[u]$ 位置加上 $w[u]$，在 $d[u]$ 之后的部分则需依次减掉此次操作的值。 码量较小，常数较小。 代码如下：（自带大常数） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100005;vector&lt;int&gt; G[maxn];map&lt;int, ll&gt; mp[maxn];int d[maxn];ll w[maxn];int N, M, K;void dfs(int u) &#123; for (auto v: G[u]) &#123; dfs(v); if (mp[u].size() &lt; mp[v].size()) swap(mp[u], mp[v]); for (auto it: mp[v]) &#123; mp[u][it.first] += it.second; &#125; &#125; if (d[u]) &#123; mp[u][d[u]] += w[u]; for (auto it = mp[u].upper_bound(d[u]); it != mp[u].end();) &#123; if (it-&gt;second &gt; w[u]) &#123; it-&gt;second -= w[u]; break; &#125; w[u] -= it-&gt;second; it-&gt;second = 0; mp[u].erase(it++); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;K); for (register int i = 2; i &lt;= N; ++i) &#123; int p; scanf("%d", &amp;p); G[p].push_back(i); &#125; for (register int i = 1; i &lt;= M; ++i) &#123; int v; scanf("%d", &amp;v); scanf("%d%I64d", &amp;d[v], &amp;w[v]); &#125; dfs(1); ll ans = 0; for (auto it: mp[1]) ans += it.second; printf("%I64d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>std::map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-2071最佳团体]]></title>
    <url>%2F2019%2F10%2F02%2Fsolution-loj-2071%2F</url>
    <content type="text"><![CDATA[题目链接(Luogu) 题目链接(LibreOJ) 题目概括重金征集中~ 0/1 分数规划的基本模型：给定整数 $a_1,a_2,…,a_n$ 以及 $b_1,b_2,…,b_n$，求一组解 $x_i$（$x_i$ 的取值为 0 或 1），使下式最大化： \frac{\Sigma a_i*x_i}{\Sigma b_i*x_i}在本题中，${a_n}$ 对应着战斗值， ${b_n}$ 对应着招募费用。题目要求从中选出若干名选手（即将相应的 $x_i$ 赋为 1），使得上式最大化。 值得注意的是，在本题中 $x_i$ 的取值同样有限制：如果 $x_i=1$，则一定有 $x_{R[i]}=1$ 或$R[i]=0$。 接下来考虑上式的计算。我么们不妨任意猜测一个值 $mid$ ，如果 $\frac{\Sigma a_i*x_i}{\Sigma b_i*x_i} \ge mid$ ，即 $mid$ 比我们要求的最大值要小，则可以推出 $\Sigma (a_i-mid*b_i)*x_i\ge 0$。因此，我们只需判定 $\Sigma (a_i-mid*b_i)*x_i$ 是否大于等于 0，即可进一步缩小 $mid$ 的范围。 综上所述，我们可以二分答案（实数）。当二分的值为 $mid$ 时，计算 $\Sigma (a_i-mid*b_i)*x_i$ 的最大值，检查最大值是否非负。若非负，则令 $l=mid$；否则令 $r=mid$。当二分停止时，就得到了 0/1 分数规划问题的解。 本题的另一关键点在于计算 $\Sigma (a_i-mid*b_i)*x_i$ 的最大值。本题可以采用背包类树形 DP 实现，具体内容不再赘述。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const float eps = 1e-4;struct Edge &#123; int v, nxt;&#125;edge[2505];int cnt, head[2505];inline void AddEdge(int u, int v) &#123; edge[++cnt].v = v; edge[cnt].nxt = head[u]; head[u] = cnt;&#125;int K, N;int a[2505], b[2505];float f[2505][2505];int size[2505];float delta;inline void dfs(int u) &#123; size[u] = 1; for (int i = head[u]; i; i = edge[i].nxt) &#123; dfs(edge[i].v); size[u] += size[edge[i].v]; &#125;&#125;inline void dp(int u) &#123; float w = 1.0 * a[u] - 1.0 * delta * b[u]; for (int i = 1; i &lt;= K; ++i) f[u][i] = -1e9; for (int i = head[u]; i; i = edge[i].nxt) &#123; int v = edge[i].v; dp(v); for (int i = min(K, size[u]); i &gt;= 1; --i) for (int j = 0; j &lt;= min(size[v], i); ++j) f[u][i] = max(f[u][i], f[u][i - j] + f[v][j]); &#125; if (u != 0) &#123; for (int i = min(K, size[u]); i &gt;= 1; --i) f[u][i] = f[u][i - 1] + w; f[u][1] = w; &#125;&#125;int main() &#123; scanf("%d%d", &amp;K, &amp;N); for (register int i = 1; i &lt;= N; ++i) &#123; int r; scanf("%d%d%d", &amp;b[i], &amp;a[i], &amp;r); AddEdge(r, i); &#125; dfs(0); float l = 0, r = 10000; while (r - l &gt; eps) &#123; float mid = (l + r) / 2; delta = mid; dp(0); if (f[0][K] &lt; 0) r = mid; else l = mid; &#125; printf("%.3f", l); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
        <tag>0/1分数规划</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解题报告-NOIP2017提高组初赛]]></title>
    <url>%2F2019%2F09%2F29%2Fsolution-noip2017pre%2F</url>
    <content type="text"><![CDATA[NOIP 2017 提高组初赛试题 完全解读！ 第 1 题 从（ ）年开始，NOIP 竞赛将不再支持 Pascal 语言。 A. 2020 B. 2021 C. 2022 D. 2023 送命题。 第 2 题 在 8 位二进制补码中，10101011 表示的数是十进制下的（ ）。 A. 43 B. -85 C. -43 D. -84 原码 补码 反码 正数 符号(0)+数值表示法 原码 原码 负数 符号(1)+数值表示法 符号位之外各位取反 符号位之外各位取反，最低位加1 [x]_{补}=10101011 [x]_{反}=10101010 [x]_{原}=11010101 x=-85 第 3 题 分辨率为 1600x900、16 位色的位图，存储图像信息所需的空间为（ ）。 A. 2812.5KB B. 4218.75KB C. 4320KB D. 2880KB 8 \ \text{bit}= 1\ \text{byte(B)}\\ 1024\ \text{B}=1\ \text{KB}\\ 1024\ \text{KB}=1\ \text{MB}\\ 1024\ \text{MB}=1\ \text{GB} 第 4 题 2017 年 10 月 1 日是星期日，1949 年 10 月 1 日是（ ）。 A. 星期三 B. 星期日 C. 星期六 D. 星期二 2017-&gt;2016：星期日-&gt;星期六 2016-&gt;2015：星期六-&gt;星期四 2015-&gt;2014：星期四-&gt;星期三 …… 1950-&gt;1949：星期日-&gt;星期六 第 5 题 设 G 是有 n 个结点、m 条边（n ≤ m）的连通图，必须删去 G 的（ ）条边， 才能使得 G 变成一棵树。 A. m – n + 1 B. m - n C. m + n + 1 D. n – m + 1 树有 n - 1 条边 第 6 题 若某算法的计算时间表示为递推关系式：T(N) = 2T(N / 2) + N log NT(1) = 1则该算法的时间复杂度为（ ）。 A. O(N) B. O(NlogN) C. O(Nlog^2N) D. O(N^2) $T$ 共有 $\log N$ 次递归调用，每次复杂度为 $O(N\log N)$ 第 7 题 表达式 a * (b + c) * d 的后缀形式是（ ）。 A. a b c d * + * B. a b c + * d * C. a * b c + * d D. b + c * a * d 普通表达式为中序遍历，后缀表达式为可能的后序遍历 第 8 题 由四个不同的点构成的简单无向连通图的个数是（ ）。 A. 32 B. 35 C. 38 D. 41 由四个点构成的简单无向连通图，它们之间只可能有 6 条不同的边。将四个点按序排列，这 6 条边可分为纵横向及斜向两种边。 纵横边有 1 条 该情况下，无向图有 4 种摆放位置。要使得图连通，斜向边只有 1 种摆法。 ans += 4 * 1 纵横边有 2 条 两纵/两横 ans += 2 * 3 一纵一横 ans += 4 * 2 纵横边有 3 条 ans += 4 * 4 纵横边有 4 条 ans += 1 * 4 第 9 题 将 7 个名额分给 4 个不同的班级，允许有的班级没有名额，有（ ）种不 同的分配方案。 A. 60 B. 84 C. 96 D. 120 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 插板法。考虑在七个名额间插入 3 个板子，将它们隔成 4 份。插板的方案数即为分配方案数。 C_{8+3-1}^{3}=120 第 10 题 若 f[0] = 0, f[1] = 1, f[n + 1] = (f[n] + f[n - 1]) / 2，则随着 i 的增大，f[i]将接近于( )。 A. 1/2 B. 2/3 C. (√5 − 1)/2 D. 1 还是不会 第 11 题 设 A 和 B 是两个长为 n 的有序数组，现在需要将 A 和 B 合并成一个排好序的 数组，请问任何以元素比较作为基本运算的归并算法最坏情况下至少要做 （ ）次比较。 A. n^2 B. nlogn C. 2n D. 2n-1 构造 A、B 分别为 [1,3,5,7…] [2,4,6,8,…] 此时需要 2n-1 次比较 第 12 题 在 n（n ≥ 3）枚硬币中有一枚质量不合格的硬币（质量过轻或质量过重）,如果只有一架天平可以用来称重且称重的硬币数没有限制，下面是找出这枚不合格的硬币的算法。请把 a-c 三行代码补全到算法中。a. A ← X ∪ Yb. A ← Zc. n ← |A| 12345678910算法 Coin(A, n)k ← ⌊n/3⌋将 A 中硬币分成 X，Y，Z 三个集合，使得|X| = |Y| = k,|Z| = n - 2kif W(X) ≠ W(Y) //W(X), W(Y)分别为 X 或 Y 的重量then _____else __________if n&gt;2 then goto 1if n=2 then 任取 A 中1枚硬币与拿走硬币比较，若不等，则它不合格； 若相等，则 A 中剩下的硬币不合格if n=1 then A 中硬币不合格 正确的填空顺序是（ ）。 A. b, c, a B. c, b, a C. c, a, b D. a, b, c 如果 X 和 Y 重量不等，则不合格的硬币在 X ∪ Y 中；否则在 Z 中。 第 13 题 有正实数构成的数字三角形排列形式如图所示。第一行的数为 a11；第二行的数从左到右依次为 a21, a22；… 第 n 行的数为 an1, an2, …, ann。从 a11 开始，每一行的数 aij 只有两条边可以分别通向 下一行的两个数 a(i+1)j 和 a(i+1)(j+1)。用动态规划算 法找出一条从 a11 向下通到 an1, an2, …, ann 中某个数的路径，使得该路径上的数之和达到最大。 令 C[i,j]是从 a11 到 aij 的路径上的数的最大和，并且 C[i,0]=C[0,j]=0, 则 C[i,j]=（ ）。 A. max{C[i-1,j-1], C[i-1,j]} + aij B. C[i-1,j-1] + C[i-1,j] C. max{C[i-1,j-1], C[i-1,j]} + 1 D. max{C[i,j-1],C[i-1,j]} + aij 数字三角形动态规划。 $f[i][j]=max(f[i-1][j],f[i-1][j-1])+a[i][j]$ 第 14 题 小明要去南美洲旅游，一共乘坐三趟航班才能到达目的地，其中第 1 个航班 准点的概率是 0.9，第 2 个航班准点的概率为 0.8, 第 3 个航班准点的概率为 0.9。如果存在第 i 个（i=1,2）航班晚点，第 i+1 个航班准点，则小明将赶不 上第 i+1 个航班，旅行失败；除了这种情况，其他情况下旅行都能成功。请 问小明此次旅行成功的概率是（ ）。 A. 0.5 B. 0.648 C. 0.72 D. 0.74 航班1 航班2 航班3 准点 0.9 0.8 0.9 晚点 0.1 0.2 0.1 枚举。共 8 种情况。 第 15 题 欢乐喷球：儿童游乐场有个游戏叫“欢乐喷球”，正方形场地中心能不断喷出彩色乒乓球，以场地中心为圆心还有一 个圆形轨道，轨道上有一列小火车在匀速运动，火车有六节车厢。假设乒乓球等概率落到正方形场地的每个地点，包括火车车厢。小朋友玩这个游戏时，只能坐在同一个火车车厢里，可以在自己的车厢里捡落在该车厢内的所有乒乓球，每个人每次游戏有三分钟时间，则一个小朋友独自玩一次游戏期望可以得到（ ）个乒乓球。假设乒乓球喷出的速度为 2 个/秒，每节车厢的面积是整个场地面积的 1/20。 A. 60 B. 108 C. 18 D. 20 2*3*60/20=18 第 16 题 以下排序算法在最坏情况下时间复杂度最优的有（ ）。 A. 冒泡排序 B. 快速排序 C. 归并排序 D. 堆排 期望复杂度 最劣复杂度 最优复杂度 是否稳定 冒泡排序 / $O(n^2)$ $O(n^2)$ 稳定 插入排序 / $O(n^2)$ $O(n)$ 稳定 选择排序 / $O(n^2)$ $O(n^2)$ 不稳定 快速排序 $O(n\log n)$ $O(n^2)$ / 不稳定 归并排序 / $O(n\log n)$ $O(n\log n)$ 稳定 堆排序 / $O(n\log n)$ $O(n\log n)$ 不稳定 基数排序 / $O(nd)$ $O(nd)$ 稳定 希尔排序 / $O(n\log^2 n)$ $O(n^{3/2})$ 不稳定 第 17 题 对于入栈顺序为 a, b, c, d, e, f, g 的序列，下列（ ）不可能是合法的出栈序 列。 A. a, b, c, d, e, f, g B. a, d, c, b, e, g, f C. a, d, b, c, g, f, e D. g, f, e, d, c, b, a 略 第 18 题 下列算法中，（ ）是稳定的排序算法。 A. 快速排序 B. 堆排序 C. 希尔排序 D. 插入排序 见 第 16 题 第 19 题 以下是面向对象的高级语言的有（ ）。 A. 汇编语言 B. C++ C. Fortran D. Java 面向对象语言：simula 67, Smalltalk, EIFFEL, C++, Java, C# 等 第 20 题 以下和计算机领域密切相关的奖项有（ ）。 A. 奥斯卡奖 B. 图灵奖 C. 诺贝尔奖 D. 王选奖 图灵奖（英语：ACM A.M. Turing Award），又译杜林奖、A.M.图灵奖，是计算机协会（ACM）于1966年设立的奖项，专门奖励对计算机事业作出重要贡献的个人。其名称取自世界计算机科学的先驱、英国科学家、曼彻斯特大学教授艾伦·图灵（A.M. Turing），这个奖设立目的之一是纪念这位现代计算机科学的奠基者。获奖者必须是在计算机领域具有持久而重大的先进性的技术贡献。大多数获奖者是计算机科学家。是计算机界最负盛名的奖项，有“计算机界诺贝尔奖”之称。——中文维基百科 中国计算机学会王选奖 是中国计算机学会于2005年起设立的奖项。该奖项最初名为中国计算机学会创新奖，2006年起更为现名，以纪念著名计算机科学家王选。——中文维基百科 第 21 题 如右图所示，共有 13 个格子。对任何一个格子进行一 次操作，会使得它自己以及与它上下左右相邻的格子中 的数字改变（由 1 变 0，或由 0 变 1）。现在要使得所 有的格子中的数字都变为 0，至少需要_次操作。 模拟即可。略 第 22 题 如下图所示，A 到 B 是连通的。假设删除一条细的边的代价是 1，删除一条粗的边的代价是 2，要让 A、B 不连通，最小代价是( )（2 分），最小代价的不同方案数是( )（3 分）。（只要有一条删除的边不同，就是不同的方案） 最小割=最大流，易得最大流为 4。 模拟，共 9 种不同的方案。 第 23 题 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; int g(int m, int n, int x) &#123; int ans = 0; int i; if (n == 1) return 1; for (i = x; i &lt;= m / n; i++) ans += g(m - i, n - 1, i); return ans; &#125; int main() &#123; int t, m, n; cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; g(m, n, 0) &lt;&lt; endl; return 0; &#125; 输入：8 4输出：_ 大 模 拟 推出来 15 第 24 题 12345678910111213141516171819202122232425262728#include &lt;iostream&gt; using namespace std; int main() &#123; int n, i, j, x, y, nx, ny; int a[40][40]; for (i = 0; i &lt; 40; i++) for (j = 0; j &lt; 40; j++) a[i][j] = 0; cin &gt;&gt; n; y = 0; x = n - 1; n = 2 * n - 1; for (i = 1; i &lt;= n * n; i++) &#123; a[y][x] = i; ny = (y - 1 + n) % n; nx = (x + 1) % n; if ((y == 0 &amp;&amp; x == n - 1) || a[ny][nx] != 0) y = y + 1; else &#123; y = ny; x = nx; &#125; &#125; for (j = 0; j &lt; n; j++) cout &lt;&lt; a[0][j] &lt;&lt; " "; cout &lt;&lt; endl; return 0; &#125; 输入：3输出：____ 小套路题。构造数字幻方，并输出最上方一行。 第 25 题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;int n, s, a[100005], t[100005], i;void mergesort(int l, int r)&#123; if (l == r) return; int mid = (l + r) / 2; int p = l; int i = l; int j = mid + 1; mergesort(l, mid); mergesort(mid + 1, r); while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[j] &lt; a[i]) &#123; s += mid - i + 1; t[p] = a[j]; p++; j++; &#125; else &#123; t[p] = a[i]; p++; i++; &#125; &#125; while (i &lt;= mid) &#123; t[p] = a[i]; p++; i++; &#125; while (j &lt;= r) &#123; t[p] = a[j]; p++; j++; &#125; for (i = l; i &lt;= r; i++) a[i] = t[i];&#125;int main()&#123; cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; mergesort(1, n); cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 输入：62 6 3 4 5 1输出：_ 小套路题。归并排序求逆序对。 第 26 题 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int x = 1; int y = 1; int dx = 1; int dy = 1; int cnt = 0; while (cnt != 2) &#123; cnt = 0; x = x + dx; y = y + dy; if (x == 1 || x == n) &#123; ++cnt; dx = -dx; &#125; if (y == 1 || y == m) &#123; ++cnt; dy = -dy; &#125; &#125; cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl; return 0;&#125; 输入 1：4 3输出 1：（2 分）输入 2：2017 1014输出 2：（3 分）输入 3：987 321输出 3：____（3 分） 样例 1：构造两个数列 [1,2,3,4,3,2,1,2,3,4,3,2,1,…], [1,2,3,2,1,2,3,2,1,…]。求这两个数列最靠前的位置，使得 $a_i=1,b_i=1$或$a_i=x,b_i=1$或$a_i=1,b_i=x$或$a_i=x,b_i=y$。 第 27 题 （大整数除法）给定两个正整数p和q，其中p不超过10100， q不超过100000， 求 p 除以 q 的商和余数。（第一空 2 分，其余 3 分） 输入：第一行是 p 的位数 n，第二行是正整数 p，第三行是正整数 q。 输出：两行，分别是 p 除以 q 的商和余数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int p[100];int n, i, q, rest;char c;int main()&#123; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c; p[i] = c - '0'; &#125; cin &gt;&gt; q; rest = (1); i = 1; while ((2) &amp;&amp; i &lt; n) &#123; rest = rest * 10 + p[i]; i++; &#125; if (rest &lt; q) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; cout &lt;&lt; (3); while (i &lt; n) &#123; rest = (4); i++; cout &lt;&lt; rest / q; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; (5) &lt;&lt; endl; return 0;&#125; ​ 第 28 题 （最长路径）给定一个有向无环图，每条边长度为 1，求图中的最长路径长度。（第五空 2 分，其余 3 分） 输入：第一行是结点数 n（不超过 100）和边数 m，接下来 m 行，每行两个整数 a， b，表示从结点 a 到结点 b 有一条有向边。结点标号从 0 到(n-1)。 输出：最长路径长度。 提示：先进行拓扑排序，然后按照拓扑序计算最长路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;using namespace std;int n, m, i, j, a, b, head, tail, ans;int graph[100][100]; // 用邻接矩阵存储图int degree[100]; // 记录每个结点的入度int len[100]; // 记录以各结点为终点的最长路径长度int queue[100]; // 存放拓扑排序结果int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) graph[i][j] = 0; for (i = 0; i &lt; n; i++) degree[i] = 0; for (i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; graph[a][b] = 1; (1); &#125; tail = 0; for (i = 0; i &lt; n; i++) if ((2)) &#123; queue[tail] = i; tail++; &#125; head = 0; while (tail &lt; n - 1) &#123; for (i = 0; i &lt; n; i++) if (graph[queue[head]][i] == 1) &#123; (3); if (degree[i] == 0) &#123; queue[tail] = i; tail++; &#125; &#125; (4); &#125; ans = 0; for (i = 0; i &lt; n; i++) &#123; a = queue[i]; len[a] = 1; for (j = 0; j &lt; n; j++) if (graph[j][a] == 1 &amp;&amp; len[j] + 1 &gt; len[a]) len[a] = len[j] + 1; if ((5)) ans = len[a]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; DAG 上的动态规划。 \text{len[u]}=\max\{\text{len[v]}+1\},(v,u)\in E]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-LibreOJ-6032水箱]]></title>
    <url>%2F2019%2F09%2F28%2Fsolution-loj-6032%2F</url>
    <content type="text"><![CDATA[题目链接 题目概括重金征集中~ 比较毒瘤的一道题。 注意到每个条件只有“有水”限制和“没水”限制。问题在于如何统计最多能满足多少条件。假定所有的“没水”条件都能满足，在 DP 中如果在“没水”限制的格子中填入了水，则对答案的贡献减一；如果在“有水”限制的格子中填入了水，则对答案的贡献加一。 根据以上方法，可以定义状态：$f[i][j]$ 表示在从左往右第 $i$ 个格子中，高度为 $j$ 的地方有水时对答案产生的最大贡献。注意：此时假定第 $i$ 个格子的右侧挡板为无限高。 显然，如果 $j$ 小于等于其左侧挡板的高度，上一格的水的高度可以为 $1-h[i]$ 的任意值；如果 $j$ 大于其左侧挡板的高度，那么上一格的水的高度必须同样为 $j$。 状态转移方程如下： f[i][j]= \begin{cases} \sum_{k=1}^{j} w[i][k]+\max_{k=1}^{h[i]}\lbrace f[i-1][k]\rbrace,\ j\le h[i] \\ \sum_{k-1}^{j} w[i][k]+f[i-1][j],\ j>h[i] \end{cases}不难发现可以使用滚动数组优化空间；并且注意到，每个新的 $f[i][j]$ 要么是被修改成某个值，要么是在原来的基础上加上了某些东西。 在本题中，每个格子中限制条件的分布是相对稀疏的。那么，在同一格子的不同高度处，只要其对答案的贡献前缀和相等，则可以作为区间进行快速处理。 具体来说，可以使用线段树维护 $f[1]-f[L]$，并在其中用滚动数组的操作进行状态转移。这棵线段树需要支持区间修改（替换），区间修改（增加），区间查询最大值。 注意需要对高度进行离散化处理。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;bits/stdc++.h&gt;#define lson(u) node[u].l#define rson(u) node[u].r#define val(u) node[u].val#define tag1(u) node[u].tag1#define tag2(u) node[u].tag2#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) b[x]using namespace std;const int MAXN = 400005;const int inf = 0x3f3f3f3f;struct Node &#123; int l, r, val, tag1, tag2; // val: max // tag1: replace // tag2: add&#125;node[MAXN * 3];int cnt;struct Limit &#123; int x, y, k;&#125;limit[MAXN];int T, N, M;int R, L;int b[MAXN], h[MAXN];inline void build(int&amp; u, int l, int r) &#123; u = ++cnt; tag1(u) = -inf; tag2(u) = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lson(u), l, mid); build(rson(u), mid + 1, r);&#125;inline void pushdown(int u) &#123; if (tag1(u) != -inf) &#123; val(lson(u)) = val(rson(u)) = tag1(u); tag1(lson(u)) = tag1(rson(u)) = tag1(u); tag2(lson(u)) = tag2(rson(u)) = 0; tag1(u) = -inf; &#125; if (tag2(u) != 0) &#123; val(lson(u)) += tag2(u); val(rson(u)) += tag2(u); tag2(lson(u)) += tag2(u); tag2(rson(u)) += tag2(u); tag2(u) = 0; &#125;&#125;inline void pushup(int u) &#123; val(u) = max(val(lson(u)), val(rson(u)));&#125;inline void modify_replace(int u, int l, int r, int ql, int qr, int val) &#123; if (ql &gt; qr) return; pushdown(u); if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; val(u) = val; tag1(u) = val; return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify_replace(lson(u), l, mid, ql, qr, val); if (mid &lt; qr) modify_replace(rson(u), mid + 1, r, ql, qr, val); pushup(u);&#125;inline void modify_add(int u, int l, int r, int ql, int qr, int val) &#123; if (ql &gt; qr) return; pushdown(u); if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; val(u) += val; tag2(u) = val; return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify_add(lson(u), l, mid, ql, qr, val); if (mid &lt; qr) modify_add(rson(u), mid + 1, r, ql, qr, val); pushup(u);&#125;inline int query_max(int u, int l, int r, int ql, int qr) &#123; pushdown(u); if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return val(u); &#125; int mid = (l + r) &gt;&gt; 1, ret = -inf; if (ql &lt;= mid) ret = max(ret, query_max(lson(u), l, mid, ql, qr)); if (mid &lt; qr) ret = max(ret, query_max(rson(u), mid + 1, r, ql, qr)); return ret;&#125;inline bool cmp(Limit a, Limit b) &#123; if (a.x != b.x) return a.x &lt; b.x; if (a.y != b.y) return a.y &lt; b.y; return a.k &lt; b.k;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; memset(node, 0, sizeof(node)); cnt = 0, L = 0, R = 0; int ans1 = 0; scanf("%d%d", &amp;N, &amp;M); for (register int i = 2; i &lt;= N; ++i) &#123; scanf("%d", &amp;h[i]); b[++L] = h[i]; &#125; for (register int i = 1; i &lt;= M; ++i) &#123; scanf("%d%d%d", &amp;limit[i].x, &amp;limit[i].y, &amp;limit[i].k); limit[i].y++; if (limit[i].k == 0) limit[i].k = -1, ans1++; b[++L] = limit[i].y; b[++L] = limit[i].y - 1; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; h[1] = L; build(R, 1, L); for (register int i = 2; i &lt;= N; ++i) h[i] = id(h[i]); for (register int i = 1; i &lt;= M; ++i) limit[i].y = id(limit[i].y); sort(limit + 1, limit + M + 1, cmp); int cur = 1; for (register int i = 1; i &lt;= N; ++i) &#123; int height = 1, s = 0; int tmp = query_max(R, 1, L, 1, h[i]); while (limit[cur].x == i &amp;&amp; limit[cur].y &lt;= h[i]) &#123; int w = limit[cur].k; while (limit[cur].x == limit[cur + 1].x &amp;&amp; limit[cur].y == limit[cur + 1].y) &#123; w += limit[++cur].k; &#125; modify_replace(R, 1, L, height, id(rid(limit[cur].y) - 1), s + tmp); height = limit[cur].y; s += w; cur++; &#125; if (height &lt;= h[i]) modify_replace(R, 1, L, height, h[i], s + tmp); height = h[i] + 1; while (limit[cur].x == i) &#123; int w = limit[cur].k; while (limit[cur].x == limit[cur + 1].x &amp;&amp; limit[cur].y == limit[cur + 1].y) &#123; w += limit[++cur].k; &#125; modify_add(R, 1, L, height, id(rid(limit[cur].y) - 1), s); height = limit[cur].y; s += w; cur++; &#125; if (height &lt;= L) modify_add(R, 1, L, height, L, s); &#125; printf("%d\n", ans1 + query_max(R, 1, L, 1, L)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3960列队]]></title>
    <url>%2F2019%2F09%2F24%2Fsolution-luogu-p3960%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个$n \times m$的矩阵，每个点编号为$(i - 1) \times m + j$每次抽取一个点，然后让队列先向左再向前，最后将这个点放在$(n,m)$的位置，告知每次离队点的位置，求离队点的编号 $1 \le n,m,q \le 3 \times 10^5$ 感谢@oy的贡献 一道非常有意思的题。 假设我们有一个神奇的数据结构，它可以动态地维护一个长度为 $n$ 的队列，其初始元素为 $1,2,…,n$ 。该队列可以支持两种操作，第一种为删除队列的第 $k$ 项元素，执行“向前看齐”操作，并在队列的末尾补充 $n+1$ （以此类推）。第二种为查询队列的第 $k$ 项元素的数值。 拥有这样一个数据结构，本题就简单多了；观察到“向前看齐”命令只对最后一列产生影响，我们可以在每一行维护一个动态队列，最后一列用另一个动态队列单独处理。 如果出列的同学位于最后一列，则只需对最后一列进行一次删除操作即可；如果出列的同学不在最后一列，则需要对出列同学所在的那一行与最后一列同时进行操作。实现细节不再赘述。 现在我们来考虑一下如何实现神奇的动态队列。在本题的情况中，假设每个动态队列最多有 $Q$ 次删除操作，那么动态队列的时空复杂度必须只与 $Q$ 相关，否则 $O(n^2)$ 的时空复杂度无法承受。似乎这里可以用平衡树实现，而我采用了较为好写的动态开点权值线段树来维护动态队列。 初始状态，权值线段树下标为 $1,2,…,n$ 的节点大小均为 $1$ 。对于删除操作，我们只需将对应的权值大小减一，并在权值 $n+1$ 的大小加一即可。对于查询操作，只需在权值线段树中查询第 $k$ 小元素即为对应数值。实现细节同样不再赘述。 记得开 long long 。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define lson(u) (node[u].l)#define rson(u) (node[u].r)#define sum(u) (node[u].sum)using namespace std;typedef long long ll;const int MAXN = 300005;struct Node &#123; int l, r, sum;&#125;node[MAXN * 42];int cnt;int root[MAXN], size[MAXN];vector&lt;ll&gt; ins[MAXN];int N, M, Q, T;void modify(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; if (l == r) &#123; sum(u) += val; return; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) modify(lson(u), l, mid, p, val); else modify(rson(u), mid + 1, r, p, val); sum(u) = sum(lson(u)) + sum(rson(u));&#125;int query(int u, int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; int lsum = sum(lson(u)); if (l &lt;= T) &#123; lsum += (mid &gt; T) ? T - l + 1 : mid - l + 1; &#125; if (k &lt;= lsum) return query(lson(u), l, mid, k); else return query(rson(u), mid + 1, r, k - lsum);&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;Q); int Case = Q; while (Case--) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); ll ans = 0, tmp = 0; if (y == M) &#123; T = N; ans = query(root[N + 1], 1, N + Q, x); modify(root[N + 1], 1, N + Q, ans, -1); modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1); if (ans &lt;= N) ans = ans * (ll)M; else ans = ins[N + 1][ans - N - 1]; ins[N + 1].push_back(ans); printf("%lld\n", ans); &#125; else &#123; T = M - 1; ans = query(root[x], 1, M + Q, y); modify(root[x], 1, M + Q, ans, -1); modify(root[x], 1, M + Q, M - 1 + (++size[x]), 1); if (ans &lt;= M - 1) ans += (ll)(x - 1) * M; else ans = ins[x][ans - M]; T = N; tmp = query(root[N + 1], 1, N + Q, x); modify(root[N + 1], 1, N + Q, tmp, -1); modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1); if (tmp &lt;= N) tmp = tmp * (ll)M; else tmp = ins[N + 1][tmp - N - 1]; ins[N + 1].push_back(ans); ins[x].push_back(tmp); printf("%lld\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2680运输计划(Beta)]]></title>
    <url>%2F2019%2F09%2F20%2Fsolution-luogu-p2680%2F</url>
    <content type="text"><![CDATA[题目链接 证明及优化树上路径求交算法后 将会在洛谷博客上发布 这是一道暑假集训被劝退的神仙题 在今天的信息课上奇迹般地一遍过 根据题意，将某一条边的边权从 $w$ 改为 $0$，即为将经过该条边的路径总长度减去 $w$。而我们要做的，就是改造树上的某一条边，使得最长的路径长度最短。 题目乍一看可以二分，但在这篇题解中采用贪心策略。 首先将所有路径按照长度降序排序。不难发现，只有在“改造”操作能够同时减小前 $x$ 条路径的长度，该操作才是有意义的，否则不会对答案产生贡献。 那么如何使“改造”操作同时减小前 $x$ 条路径的长度呢？显然，此时选取的边一定属于前 $x$ 条路径的交。路径的交一定仍是路径，根据贪心，只需在路径的交上选取最大的边权，将这条边的边权改为 $0$，然后更新答案即可。 仅剩的问题在于如何快速求出前 $x$ 条路径的交。这里介绍一种 tth37 算法。（开始口胡） 引理：路径 $p(u1,v1)$ 与 $p(u2,v2)$ 如果存在交，则路径的交的端点一定为 $lca(u1,u2),lca(u1,v2),lca(v1,u2),lca(v1,v2)$ 中同时属于两条路径的最远点对。 尚未证明。未完待续。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1941飞扬的小鸟]]></title>
    <url>%2F2019%2F09%2F19%2Fsolution-luogu-p1941%2F</url>
    <content type="text"><![CDATA[题目链接 给定 $n*m$ 的游戏界面，求是否可以通过操作使小鸟通过所有管道以及最少操作次数。 $n\le 10000,m\le 1000$ 这篇博客不会在洛谷发表，所以内容可能比较放飞自我。 神仙shiwt巨佬早在去年的这个时候就已经切掉了这个神仙题。 记 $f[i][j]$ 表示从起点飞到坐标 $(i,j)$ 所需的最小步数。考虑 $f[i][j]$ 的转移。它要么是从 $(i-1,j+Y)$ 那里掉下来的，也有可能是从 $(i-1,j-kX)$ 那里升上来的。 考虑优化。 $(i-1,j-kX)$ 的枚举较为啰嗦；不难发现如果小鸟🐦可以飞到 $(i,j-X)$ ，那么它再飞一下不就到 $(i,j)$ 了吗？ 状态转移方程如下： f[i][j]=\min \{f[i-1][j+Y],f[i][j-X]+1,f[i-1][j-X]+1\}不妨写个滚动数组。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10005;const int MAXM = 1005;const int INF = 0x3f3f3f3f;int N, M, K;int X[MAXN], Y[MAXN];int L[MAXN], R[MAXN];int f[2][MAXM * 2];int cnt, minn;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;K); for (register int i = 1; i &lt;= N; ++i) scanf("%d%d", &amp;X[i], &amp;Y[i]); for (register int i = 1; i &lt;= K; ++i) &#123; int p, l, h; scanf("%d%d%d", &amp;p, &amp;l, &amp;h); L[p] = l, R[p] = h; &#125; for (register int i = 1; i &lt;= N; ++i) &#123; int cur = i &amp; 1; minn = INF; for (register int j = 0; j &lt;= M + X[i]; ++j) f[cur][j] = INF; for (register int j = X[i]; j &lt;= M + X[i]; ++j) f[cur][j] = min(f[cur][j], min(f[cur ^ 1][j - X[i]] + 1, f[cur][j - X[i]] + 1)); for (register int j = M + 1; j &lt;= M + X[i]; ++j) f[cur][M] = min(f[cur][M], f[cur][j]); for (register int j = 0; j &lt;= M - Y[i]; ++j) f[cur][j] = min(f[cur][j], f[cur ^ 1][j + Y[i]]); if (L[i] || R[i]) &#123; for (register int j = 0; j &lt;= L[i]; ++j) f[cur][j] = INF; for (register int j = R[i]; j &lt;= M; ++j) f[cur][j] = INF; &#125; f[cur][0] = INF; for (register int j = 0; j &lt;= M; ++j) minn = min(minn, f[cur][j]); if (minn == INF) &#123; puts("0"); printf("%d", cnt); return 0; &#125; cnt += L[i] || R[i]; &#125; puts("1"); printf("%d", minn); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1979华容道]]></title>
    <url>%2F2019%2F09%2F18%2Fsolution-luogu-p1979%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个 $n * m$ 的棋盘，共 $q$ 次询问，每次询问在华容道游戏中将目标块移动到目标位置的最少步数 $n,m\le 30, q\le 300$ 本题的正解比较难想，正常人看到这题可能都会在搜索剪枝的不归路上越走越远。 如果采用搜索的策略，每次需要记录下棋盘的完整状态，状态数量和转移数量过于庞大，以致于无法在规定时间内求解。 观察到棋盘中的非障碍位置只可能有空格、普通棋子或目标棋子三种可能，因此我们只需确定目标棋子和空格的位置，就可以将整张棋盘的状态确定下来。 显然，如果想要挪动目标棋子，则目标棋子的上下左右四个方向之一必须为空格。可以定义状态为三元组 $(x,y,d)$ ，表示目标棋子位于 $(x,y)$ ，并且其 $d(0\le d\le 3)$ 方向为空格。 假设位于 $(x1,y1)$ 的目标棋子向 $d1$ 方向移动一个单位后到达 $(x2,y2)$ ，不难发现状态 $(x1,y1,d1)$ 可以转移到状态 $(x2,y2,d2)$。而此次转移需要的代价，即为将空格从原始位置移动到 $(x2,y2)$ 的 $d2$ 方向所需的最小步数。这里可以用 bfs 求解。（注意障碍方块和 $(x2,y2)$ 位置是不可以经过的） 将每个状态 $(x,y,d)$ 抽象为节点，可以转移的状态之间连一条有向边，边权即为转移的最小步数。对于每次询问，计算出抽象后的图中最短路径即可。 代码如下：（略丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x, y, d) ((x - 1) * M + y) + N * M * (d)const int INF = 0x3f3f3f3f;struct Edge &#123; int v, w; Edge(int v, int w): v(v), w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; G[35 * 35 * 5];int nx[] = &#123;0, -1, 0, 1&#125;;int ny[] = &#123;-1, 0, 1, 0&#125;;int N, M, Q;int h[35][35];int t[35][35];bool vis[35][35];void getdis(int x, int y, int px, int py) &#123; memset(t, 0x3f, sizeof(t)); memset(vis, 0, sizeof(vis)); if (h[x][y] == 0) return; queue&lt;pair&lt;int, int&gt; &gt; q; t[x][y] = 1, vis[x][y] = 1; q.push(make_pair(x, y)); while (q.size()) &#123; int ux = q.front().first, uy = q.front().second; q.pop(); for (int d = 0; d &lt;= 3; ++d) &#123; int tx = ux + nx[d], ty = uy + ny[d]; if (tx &lt; 1 || tx &gt; N || ty &lt; 1 || ty &gt; M) continue; if (tx == px &amp;&amp; ty == py) continue; if (h[tx][ty] == 0 || vis[tx][ty]) continue; t[tx][ty] = t[ux][uy] + 1; q.push(make_pair(tx, ty)); vis[tx][ty] = 1; &#125; &#125;&#125;inline void AddEdge(int u, int v, int w) &#123; G[u].push_back(Edge(v, w));&#125;bool v[35 * 35 * 5];int d[35 * 35 * 5];void Dijkstra(int S) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); d[S] = 0; priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(0, S)); while (q.size()) &#123; int u = q.top().second; q.pop(); if (v[u]) continue; v[u] = 1; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it-&gt;v, w = it-&gt;w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; q.push(make_pair(-d[v], v)); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= M; ++j) scanf("%d", &amp;h[i][j]); for (int x = 1; x &lt;= N; ++x) &#123; for (int y = 1; y &lt;= M; ++y) &#123; if (h[x][y] == 0) continue; for (int d = 0; d &lt;= 3; ++d) &#123; int tx = x + nx[d], ty = y + ny[d]; if (tx &lt; 1 || tx &gt; N || ty &lt; 1 || ty &gt; M) continue; if (h[tx][ty] == 0) continue; getdis(x, y, tx, ty); for (int d2 = 0; d2 &lt;= 3; ++d2) &#123; int tx2 = tx + nx[d2], ty2 = ty + ny[d2]; if (tx2 &lt; 1 || tx2 &gt; N || ty2 &lt; 1 || ty2 &gt; M) continue; if (t[tx2][ty2] &gt;= INF) continue; AddEdge(id(x, y, d), id(tx, ty, d2), t[tx2][ty2]); &#125; &#125; &#125; &#125; while (Q--) &#123; int ex, ey, sx, sy, tx, ty; scanf("%d%d%d%d%d%d", &amp;ex, &amp;ey, &amp;sx, &amp;sy, &amp;tx, &amp;ty); if (sx == tx &amp;&amp; sy == ty) &#123; puts("0"); continue; &#125; getdis(ex, ey, sx, sy); int ans = INF; for (int d1 = 0; d1 &lt;= 3; ++d1) &#123; int fx = sx + nx[d1], fy = sy + ny[d1]; if (fx &lt; 1 || fx &gt; N || fy &lt; 1 || fy &gt; M) continue; if (t[fx][fy] &gt;= INF) continue; int cur = INF; Dijkstra(id(sx, sy, d1)); for (int d2 = 0; d2 &lt;= 3; ++d2) cur = min(cur, d[id(tx, ty, d2)]); cur += t[fx][fy] - 1; ans = min(ans, cur); &#125; if (ans &gt;= INF) puts("-1"); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5290春节十二响]]></title>
    <url>%2F2019%2F09%2F12%2Fsolution-luogu-p5290%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵有 $n$ 个节点的树，将树上所有节点分为若干组，其中每一组中的任意两个节点不能存在祖先-后代关系，每一组的权值为该组中所有节点权值的最大值，求所有组的权值总和最小值。 $1 \le n \le 200000$ 我感谢我自己 首先考虑树退化为链的情况。树根最多有两棵子树，树根需要被单独分为一段，其余段中不能出现同一棵子树内的两个点。 这时我们需要将左子树中的节点与右子树中的节点配对。可以证明，将左子树中的最大值与右子树中的最大值、左子树中的次大值与右子树中的次大值以此类推两两配对，可以使所有段的权值总和最小。 如此一来，两条链实则被合并成为一条链。同理，多条链也可以使用类似的方式合并为一条链。 因此，我们可以维护每个节点到叶子节点的一条等效链，并且要求高效地将两条链合并为一条新链。 不难看出，由于我们需要取最大值的性质，可以使用堆来维护链信息。即，在每个节点上建立一个堆，堆中存储从当前节点到叶子节点的等效链上所有权值信息。 接下来需要解决的即为链的合并即堆的合并问题。假设需要合并堆 $q1$ ，$q2$ 。 如果 $q1.size()&gt;q2.size()$，那么只需取出 $q1$ 的前 $q2.size()$ 项，并将它们与 $q2$ 中的所有元素取最大值即可。时间复杂度 $O(q2.size()\log q2.size())$ 。 如果 $q1.size()&lt;q2.size()$，那么不仅需要取出 $q1$ 的所有项，并将它们与 $q2$ 中的前 $q1.size()$ 项取最大值，还需将 $q2$ 中剩余的元素插入 $q1$ 中。时间复杂度 $O(q2.size()\log q2.size())$ 。 不难看出，将大堆合并进入小堆，时间复杂度在 $O(max(q1.size(),q2.size()))$ 级别。但如果换一种思路，将小堆合并进入大堆，时间复杂度就降到 $O(min(q1.size(),q2.size()))$ 级别。此方法与并查集的按秩合并有异曲同工之妙，被成为启发式合并。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;vector&lt;int&gt; G[200005];int M[200005];priority_queue&lt;int&gt; q[200005];int tmp[200005], cnt;void dfs(int u) &#123; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; dfs(v); cnt = 0; if (q[u].size() &lt; q[v].size()) swap(q[u], q[v]); while(q[v].size()) &#123; tmp[++cnt] = max(q[u].top(), q[v].top()); q[u].pop(), q[v].pop(); &#125; for (int i = 1; i &lt;= cnt; ++i) q[u].push(tmp[i]); &#125; q[u].push(M[u]);&#125;int main() &#123; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;M[i]); for (register int i = 2; i &lt;= N; ++i) &#123; int f; scanf("%d", &amp;f); G[f].push_back(i); &#125; dfs(1); ll ans = 0; while (q[1].size()) ans += q[1].top(), q[1].pop(); printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-点分治&动态点分治]]></title>
    <url>%2F2019%2F09%2F11%2Falgorithm-treedivide%2F</url>
    <content type="text"><![CDATA[点分治概述点分治适合处理大规模的树上路径信息问题。 点分治的实现基于以下结论：一棵子树上的任意一条路径，要么经过树根，要么被完全包含在树根的一棵子树中。 定义 $solve()$ 函数，对每棵子树进行分值处理，并保证 $O(n\log n)$ 的时间复杂度。 模板这么简单还要模板？ 动态点分治（点分树）概述在树上的每个节点上建立数据结构，存储其控制范围内所有点与之的距离信息。在进行修改或查询操作时，只需访问当前节点的所有祖先（最多 $O(\log n)$ 个）即可。 模板代码过于毒瘤 不贴了]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1311选择客栈]]></title>
    <url>%2F2019%2F09%2F09%2Fsolution-luogu-p1311%2F</url>
    <content type="text"><![CDATA[题目链接 现在我随机@一个人 这个人必须帮我写题目概括 @gzn7264 这篇题解就不在洛谷博客上发布了。 首先枚举点对的右端点。显而易见，合法的左端点必须满足： 左端点与右端点颜色相同 左端点到右端点之间必须存在至少一个客栈，使得其费用小于等于 $P$ 第二个条件有点麻烦，我们可以稍微转化一下。记 $l_i$ 为客栈 $i$ 的左侧第一个费用小于等于 $P$ 的客栈编号。那么，以 $i$ 为右端点的情况下，左端点的可选位置即为 $1-l_i$ 种所有颜色与客栈 $i$ 相同的客栈个数。 由于本题卡空间，必须采用滚动数组。数组 $s_i$ 记录颜色 $i$ 的出现次数，数组 $c_i$ 记录颜色 $i$ 的可选左端点个数。每次更新答案时，加上 $c_{color}$ 即可。 在示例代码中，可选的左端点包括其本身，因此当 $money\le P$ 时存在重复计算，答案减一。 代码如下： 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;long long ans;int N, K, P;int c[50], s[50];int main() &#123; scanf("%d%d%d", &amp;N, &amp;K, &amp;P); for (register int i = 1; i &lt;= N; ++i) &#123; int color, money; scanf("%d%d", &amp;color, &amp;money); s[color]++; if (money &lt;= P) for (register int j = 0; j &lt; K; ++j) c[j] = s[j]; ans += c[color] - (money &lt;= P); &#125; printf("%I64d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2495消耗战]]></title>
    <url>%2F2019%2F08%2F30%2Fsolution-luogu-p2495%2F</url>
    <content type="text"><![CDATA[题目链接 现在我随机@一个人 这个人必须帮我写题目概括 @xj 这是一篇虚树入门题解。 考虑题目中 $m=1$ 的情况。树上动规，定义状态 $f[u]$ 表示切断节点 $u$ 与该子树内所有关键点的路径，最小总代价。状态转移方程如下： f[u]= \begin{equation} \begin{cases} w(u,v) \ \texttt{if h[v]=1} \\ \min(w(u,v),f[v])\ \texttt{if h[v]=0} \end{cases} \end{equation}动态规划部分不再赘述。该算法复杂度为 $O(n)$ 。 考虑题目中 $m\not= 1$ 的情况。如果对于每一次查询，都进行一次 $O(n)$ 复杂度的遍历显然无法接受。观察到题目中 $\Sigma{k}$ 的取值不大，可以考虑针对没个询问，舍弃树上的一些非关键点，仅保留一棵包含原树上部分节点的虚树，并在虚树上进行动态规划。 那么，在虚树上应该保留原树上的哪些点呢？ 首先，每次讯问中给出的 $k$ 个关键点（资源丰富的岛屿）显然应该包含在虚树中。其次，任意两个关键点的最近公共祖先也应该包含在虚树中；因为在本题中，切断一条边可以同时切断根节点与多个关键点间的路径，最近公共祖先的存在为动态规划提供了这种状态转移。最后为了方便，我们可以将 $1$ 号节点（即根节点）也加入到虚树中。 构造虚树的方法很多，在这里介绍一种用栈建树的算法流程。 令 $1$ 号节点为虚树的根。 将所有关键点按照其在原树中的 dfs 序升序排序。假设当前正在处理的关键点为 $u$ 。 维护一个栈，使得栈底到栈顶的元素依次为虚树上从根节点到节点 $u$ 的一条链。 这里为什么要维护一个栈呢？ 如图：在处理完 $3$ 号关键点后，虚树中只有 $1$ 、 $3$ 两个节点，栈中的元素依次为 $1$ 、 $3$ 。但是这条链是不完整的，可以观察到在处理 $4$ 号关键点时，还需要将 $2$ 号节点添加到虚树中。利用栈的性质，我们可以动态维护一条虚树上的链，并在必要的时候添加节点。 回到刚才的叙述，当前正在处理关键点 $u$ 。根据栈的定义，上一个处理的关键点一定为 $stack.top()$ 。 由于进行过排序，即节点 $u$ 的 dfs 序大于上一个关键点的 dfs 序，因此节点 $u$ 要么是上一个关键点的后代，要么与其没有祖先-后代的关系。 显然，如果节点 $u$ 是 $stack.top()$ 的后代，那么只需将节点 $u$ 入栈即可，因为 $u$ 在虚树中，一定是上一个关键点的儿子。 但是如果节点 $u$ 与 $stack.top()$ 没有祖先-后代的关系，那么此时的讨论将比较复杂。 可以结合上图观察，假设当前正在处理 $4$ 号关键点。我们可以首先将栈顶弹出，因为 $stack.top()$ 一定不在根节点到节点 $u$ 的链上。此时，栈中剩余的元素只有 $1$ 。然而， $3$ 与 $4$ 的最近公共祖先 $2$ 号节点还不在栈中；因此我们需要把 $2$ 号节点入栈，并将刚刚弹出的节点与新的栈顶在虚树中连边。处理结束后，将 $4$ 入栈。 接下来处理 $5$ 号关键点，此时栈中的元素依次为 $1$ 、$2$ 、$4$ 。首先将栈顶弹出，但由于我们接下来需要维护的链为 $1-&gt;5$ ，栈中仍然有节点 $2$ ，因此我们需要将 $2$ 和刚刚弹出的节点 $4$ 连边，并且重复以上操作。将新的栈顶 $2$ 弹出后，栈中只剩下节点 $1$ 。这时发现 $1$ 号节点恰好为 $5$ 与上一次处理的关键点 $4$ 的最近公共祖先，因此将 $1$ 与 $2$ 连边后，弹栈可以中止了。处理结束后，将 $5$ 入栈。 此时我们已经处理完了所有关键点，但是栈中的元素间还没有连边。将栈中的节点依次连边后，虚树的构建就完成了。 伪代码如下： 123456789101112131415将关键点按照 dfs 序排序stack.push(1)for u = 1 ~ k: // 假设当前正在处理节点 u lca = Lca(u, stack.top()) while stack.top() != lca: tmp = stack.top() stack.pop() if dfn[stack.top()] &lt; dfn[lca] stack.push(lca) AddEdge(stack.top(), tmp) stack.push(u)while stack.top() != 1: tmp = stack.top() stack.pop() AddEdge(stack.top(), tmp) 可以证明，对于本题，虚树上的边权一定对应原树上两节点之间边权的最小值。证明不再赘述。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge &#123;int v;ll w;Edge(int a, ll b) &#123;v = a, w = b;&#125;&#125;;struct Key &#123;int u, dfn;&#125;keys[250005];int keys_cnt;inline bool cmp(Key a, Key b) &#123; return a.dfn &lt; b.dfn;&#125;int N, M;vector&lt;Edge&gt; G[250005], VT[250005];int f[250005][19], g[250005][19], dep[250005];ll d[250005];bool h[250005];int dfn[250005], dfn_idx;int lg[250005];void dfs(int u, int fa, ll w) &#123; dep[u] = dep[fa] + 1; dfn[u] = ++dfn_idx; f[u][0] = fa, g[u][0] = w; for (int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i - 1]][i - 1], g[u][i] = min(g[f[u][i - 1]][i - 1], g[u][i - 1]); for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v; ll w = it -&gt; w; if (v == fa) continue; dfs(v, u, w); &#125;&#125;void dp(int u) &#123; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v; ll w = it -&gt; w; dp(v); if (h[v]) d[u] += w; else d[u] += min(w, d[v]); h[v] = 0; d[v] = 0; &#125; VT[u].clear();&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] &gt; dep[v]) &#123; u = f[u][lg[dep[u] - dep[v]]]; &#125; if (u == v) return u; for (int i = lg[dep[u]]; i &gt;= 0; --i) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];&#125;inline int query(int u, int v) &#123; int ans = 0x3f3f3f3f; while (dep[u] &gt; dep[v]) &#123; ans = min(ans, g[u][lg[dep[u] - dep[v]]]); u = f[u][lg[dep[u] - dep[v]]]; &#125; return ans;&#125;inline void AddEdge(int u, int v) &#123; int w = query(v, u); VT[u].push_back(Edge(v, w));&#125;int main() &#123; for (register int i = 2; i &lt;= 250000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; memset(g, 0x3f, sizeof(g)); scanf("%d", &amp;N); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; ll w; scanf("%d%d%lld", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); G[v].push_back(Edge(u, w)); &#125; dfs(1, 0, 0); scanf("%d", &amp;M); while (M--) &#123; int k; keys_cnt = 0; scanf("%d", &amp;k); for (register int i = 1; i &lt;= k; ++i) &#123; scanf("%d", &amp;keys[++keys_cnt].u); h[keys[keys_cnt].u] = 1; keys[keys_cnt].dfn = dfn[keys[keys_cnt].u]; &#125; stack&lt;int&gt; s; sort(keys + 1, keys + keys_cnt + 1); s.push(1); for (register int i = 1; i &lt;= keys_cnt; ++i) &#123; int u = keys[i].u; int lca = Lca(u, s.top()); while (s.top() != lca) &#123; int tmp = s.top(); s.pop(); if (dfn[s.top()] &lt; dfn[lca]) s.push(lca); AddEdge(s.top(), tmp); &#125; s.push(u); &#125; while (s.top() != 1) &#123; int tmp = s.top(); s.pop(); AddEdge(s.top(), tmp); &#125; dp(1); printf("%lld\n", d[1]); d[1] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>虚树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4103大工程]]></title>
    <url>%2F2019%2F08%2F30%2Fsolution-luogu-p4103%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵有 $n$ 个节点的树，边权为 $1$ 。共有 $q$ 次询问，每次给出 $k$ 个节点，求： $k$ 个节点间两两距离之总和；最短距离；最长距离。 $1\le n \le 1000000,1 \le q \le 1000000, \Sigma{k}\le 2 * n$ 感谢@tth37 的贡献 本题用到了一些点分治的思想。 考虑 $q=1$ 的情况。一种朴素的做法是：枚举当前节点的所有子节点，并计算子树间关键点形成的路径、更新答案。但是本题与一般点分治题目略有不同，我们可以通过预处理子树信息来优化点分治过程。 稍加观察可以发现，只需预处理每个子树中树根到关键点的最小距离、最大距离，以及子树中关键点的个数、所有关键点到树根的距离总和即可完成点分治全部过程，时间复杂度 $O(n)$ 。 对于 $q\not=1$ 的情况，观察到 $\Sigma{k}$ 与 $n$ 同阶，可以对每次查询建立一棵虚树，在虚树上点分治即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000005;typedef long long ll;struct Edge &#123;int v, w; Edge(int a, int b) &#123;v = a, w = b;&#125;&#125;;struct Key &#123;int u, dfn;&#125;keys[MAXN];bool cmp(Key a, Key b) &#123;return a.dfn &lt; b.dfn;&#125;vector&lt;Edge&gt; G[MAXN], VT[MAXN];int N, Q, K;int f[MAXN][21], dep[MAXN], dfn[MAXN], dfn_idx;int lg[MAXN];bool h[MAXN];ll g[MAXN];int m[MAXN], n[MAXN];int c[MAXN];ll ans1;int ans2, ans3;inline void dfs0(int u, int fa) &#123; dfn[u] = ++dfn_idx; dep[u] = dep[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt;= lg[dep[u]]; ++i) f[u][i] = f[f[u][i - 1]][i - 1]; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v; if (v == fa) continue; dfs0(v, u); &#125;&#125;void dfs1(int u) &#123; g[u] = 0; c[u] = h[u]; m[u] = 0x3f3f3f3f; n[u] = -0x3f3f3f3f; if (h[u]) m[u] = n[u] = 0; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; dfs1(v); c[u] += c[v]; g[u] += g[v] + 1ll * w * c[v]; m[u] = min(m[u], w + m[v]); n[u] = max(n[u], w + n[v]); &#125;&#125;void dfs2(int u) &#123; ll sum = 0; int cnt = h[u]; int minn = 0x3f3f3f3f, maxx = -0x3f3f3f3f; if (h[u]) minn = maxx = 0; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; ans1 += 1ll * sum * c[v] + 1ll * w * cnt * c[v] + 1ll * g[v] * cnt; ans2 = min(ans2, minn + w + m[v]); ans3 = max(ans3, maxx + w + n[v]); sum += g[v] + 1ll * c[v] * w; cnt += c[v]; minn = min(minn, w + m[v]); maxx = max(maxx, w + n[v]); dfs2(v); &#125; h[u] = 0; VT[u].clear();&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] &gt; dep[v]) u = f[u][lg[dep[u] - dep[v]]]; if (u == v) return u; for (int i = lg[dep[u]]; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main() &#123; for (register int i = 2; i &lt;= 1000000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; scanf("%d", &amp;N); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(Edge(v, 1)); G[v].push_back(Edge(u, 1)); &#125; dfs0(1, 0); scanf("%d", &amp;Q); while (Q--) &#123; scanf("%d", &amp;K); for (register int i = 1; i &lt;= K; ++i) &#123; int u; scanf("%d", &amp;u); h[u] = 1; keys[i].u = u, keys[i].dfn = dfn[u]; &#125; sort(keys + 1, keys + K + 1, cmp); stack&lt;int&gt; s; s.push(1); for (register int i = 1; i &lt;= K; ++i) &#123; int u = keys[i].u; if (u == 1) continue; int lca = Lca(u, s.top()); while (s.top() != lca) &#123; int tmp = s.top(); s.pop(); if (dfn[s.top()] &lt; lca) s.push(lca); VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()])); &#125; s.push(u); &#125; while (s.top() != 1) &#123; int tmp = s.top(); s.pop(); VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()])); &#125; dfs1(1); ans1 = ans3 = 0; ans2 = 0x3f3f3f3f; dfs2(1); printf("%lld %d %d\n", ans1, ans2, ans3); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>点分治</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-虚树]]></title>
    <url>%2F2019%2F08%2F29%2Falgorithm-virtualtree%2F</url>
    <content type="text"><![CDATA[概述在处理某些树上问题时，并非树上的所有节点都起作用；这时可以借助虚树，将树上重要的点构造成一棵树，在虚树上处理问题，优化时间复杂度。 模板用栈来维护虚树上的一条从根到 $u$ 的链。如果 $u$ 是栈顶节点的儿子，则入栈；否则将栈中 dfn 值大于 $lca(u,s.top())$ 的元素出栈。 伪代码1234567891011将树上所有关键点按照 dfs 序排序stack.push(1)for u = 1 ~ n: //假设当前正在处理节点 u lca = Lca(u, stack.top()) while stack.top != lca: tmp = stack.top() stack.pop() if (dfn[stack.top()] &lt; dfn[lca]): stack.push(lca) AddEdge(stack.top(), tmp) stack.push(u)]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-10-1 国庆节]]></title>
    <url>%2F2019%2F08%2F27%2FNationalDay%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1314聪明的质监员]]></title>
    <url>%2F2019%2F08%2F27%2Fsolution-luogu-p1314%2F</url>
    <content type="text"><![CDATA[题目链接 咕咕咕 本题难度不大，第一眼就能看出需要用二分答案或倍增答案解决。 需要解决的第一个问题是如何根据一个猜测的参数 $W$ ，快速计算出检验结果 $Y$ 。由于只有 $w_j \ge W$ 的矿石才会对检验结果做出贡献，因此我们可以将 $w_j &lt; W$ 的矿石忽略并预处理前缀和，并且回答 $M$ 个询问即可。 接下来应该考虑如何计算猜测值 $W$ 。观察到 $Y(W)$ 是单调不增的，我们可以用倍增求出满足 $Y \ge S$ 的最大 $W$ 值，那么满足 $Y&lt;S$ 的最小 $W$ 值一定为 $W+1$ 。 最终答案即为 $\min\lbrace |Y(W)-S|,|Y(W+1)-S|\rbrace$ 。 代码如下： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, M, ans = 1; ll S;int w[200005], v[200005], l[200005], r[200005]; ll s1[200005], s2[200005];inline ll Y(int W) &#123; for (register int i = 1; i &lt;= N; ++i) s1[i] = w[i] &gt;= W ? s1[i - 1] + 1 : s1[i - 1], s2[i] = w[i] &gt;= W ? s2[i - 1] + v[i] : s2[i - 1]; ll ret = 0; for (register int i = 1; i &lt;= M; ++i) ret += (s1[r[i]] - s1[l[i] - 1]) * (s2[r[i]] - s2[l[i] - 1]); return ret;&#125;int main() &#123; scanf("%d%d%lld", &amp;N, &amp;M, &amp;S); for (register int i = 1; i &lt;= N; ++i) scanf("%d%d", &amp;w[i], &amp;v[i]); for (register int i = 1; i &lt;= M; ++i) scanf("%d%d", &amp;l[i], &amp;r[i]); for (register int i = 17; i &gt;= 0; --i) ans += Y(ans + (1 &lt;&lt; i)) &gt;= S ? (1 &lt;&lt; i) : 0; printf("%lld", min(Y(ans) - S, S - Y(ans + 1)));&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>前缀和</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5503灯塔]]></title>
    <url>%2F2019%2F08%2F26%2Fsolution-luogu-p5503%2F</url>
    <content type="text"><![CDATA[题目链接 咕咕咕 由于根号的存在，本题并没有什么明显的单调性，不能通过二分或单调队列实现。 本题的关键在于问题转化。记 $l_i$ 表示在山峰 $i$ 上建灯塔，并使得山峰 $1…i$ 全部被照亮的最小高度。 h_j\le h_i+l_i - \sqrt{i-j} (1\le j\le i) h_j+\sqrt{i-j}-h_i\le l_i(1\le j\le i) l_i=\max_{1\le j\le i}\lbrace h_j+\lceil (\sqrt{i-j}) \rceil \rbrace-h_i这样 ${l}$ 数组的求解即转化为区间求解最值问题，然而 $\max$ 函数中的 $\lceil (\sqrt{i-j}) \rceil$ 似乎有些棘手。然而观察到当 $\lceil (\sqrt{i-j}) \rceil$ 相等时，只有该区间内最大的 $h_j$ 才会对答案产生贡献。因此我们可以枚举 $\lceil (\sqrt{i-j}) \rceil$ 的值，求出对应的 $j$ 区间内 $h_j$ 的最值作为 $l_i$ 的候选答案。 $r_i$ 的定义与 $l_i$ 类似，最终的 $p_i$ 即为 $\max \lbrace l_i,r_i\rbrace$ 。 求解区间最值可以用 ST 表实现。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int st[100005][18];int lg[100005];int power[320];int p[100005];int N;inline int query(int l, int r) &#123; int s = lg[r - l + 1]; return max(st[l][s], st[r - (1 &lt;&lt; s) + 1][s]);&#125;int main() &#123; lg[1] = 0; for (register int i = 2; i &lt;= 100000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; for (register int i = 1; i &lt;= 319; ++i) &#123; power[i] = i * i; &#125; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;st[i][0]); for (register int j = 1; j &lt;= lg[N]; ++j) for (register int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= N; ++i) st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for (register int i = 1; i &lt;= N; ++i) &#123; int delta = 0, l = i, r = i; while (l &gt;= 1) &#123; p[i] = max(p[i], query(l, r) + delta - st[i][0]); r = l - 1, l = i - power[++delta]; &#125; if (r &gt;= 1) p[i] = max(p[i], query(1, r) + delta - st[i][0]); &#125; for (register int i = N; i &gt;= 1; --i) &#123; int delta = 0, l = i, r = i; while (r &lt;= N) &#123; p[i] = max(p[i], query(l, r) + delta - st[i][0]); l = r + 1, r = i + power[++delta]; &#125; if (l &lt;= N) p[i] = max(p[i], query(l, N) + delta - st[i][0]); &#125; for (register int i = 1; i &lt;= N; ++i) printf("%d\n", p[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>ST算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板-常数优化]]></title>
    <url>%2F2019%2F08%2F26%2Ftemplate-optimization%2F</url>
    <content type="text"><![CDATA[实用技巧 减少函数参数传递，开全局变量 血的教训 memset 实在是太慢了！避免大数组的多次 memset，可以在程序的其他位置（如遍历）顺手将数组清空 血的教训 快速读入123456789void readint() &#123;&#125;template&lt;class T1, class ...T2&gt;void readint(T1 &amp;i, T2&amp;... rest)&#123; i=0;char c;bool f=false; while (!isdigit(c=getchar())) f=c=='-'; do i=(i&lt;&lt;3)+(i&lt;&lt;1)+c-'0'; while (isdigit(c=getchar())); if (f) i=-i; readint(rest...);&#125; 快速输出1暂无]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-8-26]]></title>
    <url>%2F2019%2F08%2F26%2Fbulletin-2019-8-26%2F</url>
    <content type="text"><![CDATA[上一篇公告 Hi~ 访问我网站的小崽子们~ 想在评论区发言的同时留下自己的个人头像吗？快快注册一个Github账号吧！学信息没个Github账号怎么行 我的网站与Github完全兼容，可以使用Github登录我的网站，并且在文章下方评论！ 可以在这里测试一下 虽然网站是国家顶级域名（*.cn），但是Github头像的更新是实时的，注册Github账号之后立刻可以到我的博客评论！ 谢谢资瓷！]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5502最大公约数]]></title>
    <url>%2F2019%2F08%2F23%2Fsolution-luogu-p5502%2F</url>
    <content type="text"><![CDATA[题目链接 咕咕咕 对于求解区间权值 $=value *length$ 的最值问题时，我们通常可以枚举区间左端点，然后高效地找出右端点更新答案。 朴素的想法是枚举右端点 $r\in [l,n]$ 。根据显然的贪心策略，如果右端点在某一区间移动时，$\gcd(a_l,a_{l+1},…,a_r)$ 保持不变，则右端点越大越好。 因此可以用倍增优化右端点的确定。但是在倍增的过程中，需要多次查询区间最大公约数；我们可以用ST表的思路对序列预处理，做到 $O(1)$ 复杂度查询。 但是，如果已经确定左端点 $l$ ，不同的右端点选取会对应许多不同的最大公约数值，那么该算法的复杂度将无法承受。 稍加观察，可以发现当左端点确定时，右端点右移一个单位，原子段的最大公约数要么维持不变；要么变为原最大公约数的一个约数。换言之，当左端点确定时，不同的右端点最多对应 $\log_2n$ 个不同的最大公约数值。算法复杂度得以控制在 $O(n(\log n)^2)$ 。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int T, N;ll ans;ll a[100005];ll st[100005][18];int lg[100005];inline ll query(int l, int r) &#123; int k = lg[r - l + 1]; return gcd(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);&#125;int main() &#123; lg[1] = 0; for (register int i = 2; i &lt;= 100000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%lld", &amp;st[i][0]); for (register int j = 1; j &lt;= lg[N]; ++j) for (register int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= N; ++i) st[i][j] = gcd(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for (register int l = 1; l &lt;= N; ++l) &#123; int r = l; while (r &lt;= N) &#123; ll cur = query(l, r); for (register int i = lg[N]; i &gt;= 0; --i) &#123; if (r + (1 &lt;&lt; i) &lt;= N &amp;&amp; query(l, r + (1 &lt;&lt; i)) == cur) r += (1 &lt;&lt; i); &#125; ans = max(ans, cur * (r - l + 1)); r += 1; &#125; &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>倍增</tag>
        <tag>ST算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-uva11021麻球繁衍]]></title>
    <url>%2F2019%2F08%2F23%2Fsolution-luogu-uva11021%2F</url>
    <content type="text"><![CDATA[题目链接 有 $k$ 只麻球，每只活一天就会死亡，临死前可能会生出一些新的麻球。具体来说，生 $i$ 只麻球的概率为 $P_i$ 。给定 $m$ ，求 $m$ 天后所有麻球均死亡的概率。 我感谢我自己 每只麻球均可视为一个独立的问题。设 $f[i]$ 表示第一天只有 $1$ 只麻球，在第 $i$ 天它及它的后代全部死亡的概率。由全概率公式，有 f[i]=P_0+P_1f[i-1]+P_2f[i-1]^2+P_3f[i-1]^3+...+P_{n-1}f[i-1]^{n-1}其中 $P_jf[i-j]^j$ 的含义是这个麻球生了 $j$ 个后代，并且它们在 $i-1$ 天后全部死亡的概率。由于一开始有 $k$ 只麻球，最终答案为 $f[m]^k$ 。 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int T;int N, K, M;double P[1005];double f[1005];int main() &#123; cin &gt;&gt; T; for (register int Case = 1; Case &lt;= T; ++Case) &#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; M; for (register int i = 0; i &lt; N; ++i) cin &gt;&gt; P[i]; f[0] = 0; for (register int i = 1; i &lt;= M; ++i) &#123; f[i] = 0; for (register int j = 0; j &lt; N; ++j) f[i] += P[j] * pow(f[i - 1], j); &#125; cout &lt;&lt; "Case #" &lt;&lt; Case &lt;&lt; ": "; cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; pow(f[M], K) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2279消防局的设立]]></title>
    <url>%2F2019%2F08%2F19%2Fsolution-luogu-p2279%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵有 $n$ 个节点的树，求至少需要标记多少个点使得树上任意两个点的距离均小于等于 $2$ $n \le 1000$ 感谢@oy的贡献 实际上就是这道题的简化版。 首先定义状态。$f[u][4]$ 表示节点 $u$ 的二级祖先（父亲的父亲）及以下节点被完全覆盖，所需的最小代价。$f[u][3]$ 表示节点 $u$ 的一级祖先及以下节点被完全覆盖所需最小代价。以此类推， $f[u][0]$ 表示节点 $u$ 的二级儿子（儿子的儿子）及以下节点被完全覆盖所需的最小代价。 考虑 $f[u][4]$ 的推导。由于每个节点被选中后只能覆盖到与其距离小于等于二的节点，要使 $u$ 的二级祖先被覆盖到，则节点 $u$ 必须被选取。对节点 $u$ 的各个儿子没有要求。因此，$f[u][4]=1+\Sigma f[v][0…4]$ 。 考虑 $f[u][3]$。由于只需要覆盖到节点 $u$ 的父亲，只需使节点 $u$ 的至少一个子节点可以覆盖到其二级祖先即可。同时，该子节点在覆盖到节点 $u$ 的二级祖先时，可以同时覆盖到节点 $u$ 的其他儿子，因此节点 $u$ 的其他儿子不必被覆盖。$f[u][3]=f[k][4]+\Sigma f[v][1…4]$。 $f[u][2]$ 的情况与 $f[u][3]$ 类似，只需保证一个儿子能将节点 $u$ 覆盖即可。 $f[u][2]=f[k][3]+\Sigma f[v][2…4]$ 。 $f[u][1]$ 与 $f[u][0]$ 的推导相对简单，因为各个子节点之间不会相互影响。 $f[u][1]=\Sigma f[v][2…4]$，$f[u][0]=\Sigma f[v][1…4]$。 对转移方程进行简单优化即可。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; G[1005];int N;int f[1005][10];void dp(int u, int fa) &#123; f[u][3] = 0x3f3f3f3f; f[u][2] = 0x3f3f3f3f; f[u][4] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dp(v, u); f[u][0] += f[v][1]; f[u][1] += f[v][2]; f[u][2] = min(f[u][2], f[v][3] - f[v][2]); f[u][3] = min(f[u][3], f[v][4] - f[v][1]); f[u][4] += f[v][0]; &#125; f[u][2] += f[u][1]; f[u][3] += f[u][0]; f[u][3] = min(f[u][3], f[u][4]); f[u][2] = min(f[u][2], f[u][3]); f[u][1] = min(f[u][1], f[u][2]); f[u][0] = min(f[u][0], f[u][1]); &#125;int main() &#123; scanf("%d", &amp;N); for (register int u = 2; u &lt;= N; ++u) &#123; int v; scanf("%d", &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); printf("%d", f[1][2]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-Pólya计数与Burnside引理]]></title>
    <url>%2F2019%2F08%2F13%2Falgorithm-polya%2F</url>
    <content type="text"><![CDATA[概述如果题目中定义一种等价关系，满足等价关系的元素被看成同一类，只统计一次；这样的问题称为等价类计数问题。一般的等价类计数问题可以用 Burnside 引理或 Pólya定理解决。 模板置换置换实际上就是一一映射，$f$ 可以看成定义域和值域为 $\lbrace 1,2,3,…,n\rbrace$ 的函数，其中 $f(1)=a_1$， $f(2)=a_2$ 等等。 f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)函数复合如果 f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)且 g=\left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)是 $\lbrace 1,2,3,…,n\rbrace$ 的两个置换，则他们的复合按照先 $f$ 后 $g$ 的顺序放置得到一个新置换： g\circ f= \left(\begin{array}{cccc} 1&2&...&n \\\ a_1&a_2&...&a_n \\ \end{array}\right) \circ \left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)循环为了处理方便，常常把置换分解成循环的乘积，其中每个循环代表一些元素“循环移位”。比如 $(1,4,3)$ 这个循环表示 $1\rightarrow 4$，$4\rightarrow 3$，$3\rightarrow 1$。 易证任意置换都可以分解为循环乘积的形式。 例题 在 2*2 方格中涂黑白两色，方格允许旋转，有几种方法？ 假设不考虑方格允许旋转，则共有 16 种上色方案。本题中“旋转后相同”即为一个等价关系，有了等价关系，所有元素会被分为若干个等价类，我们需要统计的即为等价类的个数。 对于一个置换 $f$ ，若一个着色方案 $s$ 经过置换后不变，称 $s$ 为 $f$ 的不动点。将 $f$ 的不动点数目记为 $C(f)$，则可以证明等价类数目为置换群中所有 $C(f)$ 的平均值。此结论称为 Burnside 引理。 一般地，如果置换 $f$ 被分解为 $m(f)$ 个循环的乘积，那么每个循环内所有位置的颜色必须相同，假设涂 $k$ 种颜色，则有 $C(f)=k^{m(f)}$。带入 Burnside 引理的表达式之后得到 Pólya 定理：等价类的个数等于置换群种所有置换 $f$ 的 $k^{m(f)}$ 的平均数。 将 $t$ 种颜色的 $n$ 个小球排成一个环，允许旋转和翻转，有几种方法？ 首先考虑旋转置换。记置换 $f_i$ 为将环形顺时针旋转 $i$ 个单位长度。显然，$m(f_i)=gcd(i,n)$ 。 其次考虑翻转置换。当 $n$ 为奇数时，$|G|=n$，且 $m(f)=(n-1)/2+1$；当 $n$ 为偶数时，$|G|=n$，且 $m(f)=n/2+1$。 记： a=\Sigma_{i=0}^{n-1} t^{gcd(i,n)}\\ b=\begin{cases} t^{(n-1)/2+1} , n=2k+1\\ t^{n/2+1},n=2k \end{cases}最终答案 $ans=(a+b)/2n$。]]></content>
      <tags>
        <tag>数论</tag>
        <tag>群论</tag>
        <tag>Pólya计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-KMP模式匹配]]></title>
    <url>%2F2019%2F08%2F07%2Falgorithm-kmp%2F</url>
    <content type="text"><![CDATA[概述给定一个文本 $A$ 和一个字符串 $B$ ，我们可以利用 KMP 算法尝试找到并展示 $B$ 在 $A$ 中的所有出现（occurrence）。 模板预处理前缀函数预处理出字符串 $B$ 的前缀函数 $next$ 数组，其中 $next[i]$ 为既是子串 $B[1…i]$ 的前缀同时也是该子串的后缀的最长真前缀长度。一个字符串的真前缀是其前缀但不等于该字符串本身。根据定义， $next[1]=0$ 。 算法流程 在循环中以 $i=2$ 到 $i=n$的顺序计算前缀函数 $next[i]$ 的值。（$next[1]$ 被赋值为0） 为了计算当前的前缀函数值 $next[i]$，我们令变量 $j$ 表示右端点位于 $i-1$ 的最长匹配前后缀的长度。初始时 $j=next[i-1]$ 。 通过比较 $B[j+1]$ 和 $B[i]$ 来检查长度为 $j+1$ 的后缀是否同时也是一个前缀。如果二者相等，那么置 $next[i]=j+1$，否则减少 $j$ 至 $next[j]$ 并重复该过程。 如果 $j=0$ 并且仍没有任何一次匹配，则置 $next[i]=0$ 并移至下一个下标 $i+1$ 。 F.A.Q算法流程中的步骤三，为什么要将 $j$ 减少至 $next[j]$ ？ 考虑我们正在计算的 $next[i]$ 。我们要使 $k$ 最大化，并且保证 $B[1…k]$ 与 $B[i-k+1…i]$ 相等。将其拆成两部分看，我们需要在 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等的同时，保证 $B[k]=B[i]$ ，且 $k$ 取到最大值。 不难发现，如果只需要最大化 $k-1$ 使得 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等，我们可以很快得出答案。回顾一下前缀函数的定义即可发现，记 $j$ 为 $next[i-1]$，则此时的 $j$ 即为我们需要最大化的 $k-1$ 的值。如果这时又恰好满足 $B[j+1]=B[i]$ ，则我们需要最大化的 $k$ 即为 $j+1$ 。 然而此时如果不能满足 $B[j+1]=B[i]$ ，我们就只能考虑减小 $j$ 的值。在减小 $j$ 值的同时，我们要始终保证减小后的 $j’$ 满足 $B[1…j’]=B[j-j’+1…j]$ 。 结合上图不难看出，要使得 $B[1…j’]=B[i-j’…i-1]$，即保证 $B[1…j’]=B[j-j’+1…j]$ 。而 $j’$ 的确定也十分简单，再次结合前缀函数的定义可得， $j’$ 的取值应为 $next[j]$ 。 代码实现123456next[1] = 0;for (int i = 2, j = 0; i &lt;= M; ++i) &#123; while (j &gt; 0 &amp;&amp; B[i] != B[j + 1]) j = next[j]; if (B[i] == B[j + 1]) j++; next[i] = j;&#125; 在目标串中查找子串计算出 $f$ 数组，其中 $f[i]$ 为既是子串 $B[1…i]$ 的前缀同时也是子串 $A[1…i]$ 的后缀的最长前缀长度。（注意这里不一定是真前缀）在预处理前缀函数的过程中，相当于 $B$ 串与自己本身做了一次模式匹配，因此此处的算法流程与上一个操作十分类似。 算法流程 在循环中以 $i=1$ 到 $i=n$的顺序计算 $f[i]$ 的值。 为了计算当前的 $f[i]$ ，我们令变量 $j$ 表示右端点位于 $i-1$ 的最长匹配前后缀的长度。初始时 $j=f[i-1]$ 。 通过比较 $B[j+1]$ 和 $A[i]$ 来检查 $B$ 串中长度为 $j+1$ 的前缀是否也是 $A$ 串中长度为 $j+1$ 的后缀。如果二者相等，那么置 $f[i]=j+1$，否则减少 $j$ 至 $next[j-1]$ 并重复该过程。 如果 $j=0$ 并且仍没有任何一次匹配，则置 $f[i]=0$ 并移至下一个下标 $i+1$ 。 如果 $j=M$，即找到 $B$ 在 $A$ 中的一次出现。 代码实现123456for (int i = 1, j = 0; i &lt;= N; ++i) &#123; while (j &gt; 0 &amp;&amp; A[i] != B[j + 1]) j = next[j]; if (A[i] == B[j + 1]) j++; f[i] = p; // if (f[i] == M) do something... &#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF游记-Codeforces Round]]></title>
    <url>%2F2019%2F08%2F01%2Fcodeforces-1199%2F</url>
    <content type="text"><![CDATA[比赛链接 人生第二次觉得CF的题还是可做的。目前只弄了5道，剩下一题咕着。 #A City Day简单模拟，开心的话可以写个单调队列。 #B Water Lily初中数学题，勾股定理。 (x+H)^2=x^2+L^2 \\ x=(L^2-H^2)/2H#C MP3既然硬盘的大小是固定的，那么 $K$ 应该尽可能大。为了让 $K$ 尽可能大， $k$ 也要尽可能大。 所以： k=\lfloor(I*8)/n\rfloor \\ K=2^k把 $K$ 求出来之后，我们实际上只需保留 $K$ 种不同的数字，并使删除的数字最少。 根据题意，我们只能删除最大的或最小的数。考虑对 $a$ 数组离散化，并用 $b$ 数组记录每个数值出现的次数。保留下来的数值一定是连续的$K$个，只需在 $b$数组上进行前缀和预处理，枚举保留的 $K$ 个数值位置即可。 #D Welfare State非主流警告⚠ 观察到只有一次查询，所以我们可以针对每个位置，求出当前位置在经过 $q$ 次操作后的值并输出。 先来看两个结论： 可以忽略对当前位置的最后一次一号操作之前的所有操作。 管你之前被改成什么了，经过一次一号操作就得重新来过。 对于连续的几次二号操作，只需保留 $x$ 最大的那一次操作。 废话。 本题中二号操作是针对整体的，所以考虑开数组 $s$ 记录所有二号操作的后缀最大值。在针对每一位置进行计算时，只需将最后一次一号操作之前的操作删除后，与二号操作的后缀最大值比较即可得出答案。 #E Matching vs Independent Set#F Rectangle Painting 1超水的一道 F 题！ $f[x1][y1][x2][y2]$表示将一个矩形全部涂成白色的最小费用，状态转移考虑由两个子矩形合并或将一整块上色即可。]]></content>
      <categories>
        <category>CF游记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习-splay伸展树]]></title>
    <url>%2F2019%2F07%2F24%2Falgorithm-splay%2F</url>
    <content type="text"><![CDATA[本文部分内容转载自 OI Wiki Splay $\LaTeX$ 就先咕着吧……有时间慢慢搞 概述Splay是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，它由 Daniel Sleator 和 Robert Tarjan 发明。 结构节点维护信息 root 根节点编号 cnt 节点个数 node[] 节点内部信息 fa 父亲 ch[0/1] 左右儿子编号 val 节点权值 cnt 权值出现次数 sum 子树大小 1234struct Node &#123; int fa, ch[2], val, cnt, sum;&#125;node[MAXN];int root, cnt; 基本操作 update(u) 在改变节点位置后，将节点u的sum值更新 identify(u) 判断节点u是父亲的左儿子还是右儿子 clear(u) 销毁节点u 123456789void update(int u) &#123; node[u].sum = node[u].cnt + node[node[u].ch[0]].sum + node[node[u].ch[1]].sum;&#125;bool identify(int u) &#123; return u == node[node[u].fa].ch[1];&#125;void clear(int u) &#123; node[u].fa = node[u].ch[0] = node[u].ch[1] = node[u].val = node[u].cnt = node[u].sum = 0;&#125; 连接操作 connect(u, f, p) 将u连接在f的下方，连接方向为p 1234void connect(int u, int f, int p) &#123; node[u].fa = f; node[f].ch[p] = u;&#125; 旋转操作分析咕咕咕 1234567891011void rotate(int x) &#123; int y = node[x].fa; int r = node[y].fa; int rp = identify(y); int yp = identify(x); int b = node[x].ch[yp ^ 1]; connect(b, y, yp); connect(y, x, yp ^ 1); connect(x, r, rp); update(y), update(x);&#125; 旋转需要保证： 平衡树的中序遍历不变（不能破坏BST的性质） 受影响的节点维护的信息依然正确有效 root必须指向旋转后的根节点 具体分析旋转步骤（假设需要旋转的节点为x，其父亲为y，以右旋为例）： 将y的左儿子指向x的右儿子，且x的右儿子的父亲指向y 将x的右儿子指向y，且y的父亲指向x 如果原来的y还有父亲z，那么把z的某个儿子（原来y所在的儿子位置）指向x，且x的父亲指向z 1234567891011void rotate(int x) &#123; int y = node[x].fa, z = node[y].fa, p = identify(x); node[y].ch[p] = node[x].ch[p ^ 1]; node[node[x].ch[p ^ 1]].fa = y; node[x].ch[p ^ 1] = y; node[y].fa = x; node[x].fa = z; if (z) node[z].ch[y == node[z].ch[1]] = x; update(y); update(x);&#125; Splay 操作Splay规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为6种情况讨论（其中x为需要旋转到根的节点） 分析咕咕咕 12345void splay(int x) &#123; for (int f = node[x].fa; f = node[x].fa, f; rotate(x)) if (node[f].fa &amp;&amp; identify(x) == identify(f)) rotate(f); root = x;&#125; 插入操作分析咕咕咕 123456789101112131415161718192021222324252627282930void insert(int val) &#123; if (root == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; root = cnt; update(root); return; &#125; int cur = root, f = 0; while (1) &#123; if (node[cur].val == val) &#123; node[cur].cnt++; update(cur); update(f); splay(cur); break; &#125; f = cur, cur = node[cur].ch[node[cur].val &lt; k]; if (cur == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; node[cnt].fa = f; node[f].ch[node[f].val &lt; k] = cnt; update(cnt); update(f); splay(cnt); break; &#125; &#125;&#125; 查询x的排名分析咕咕咕 123456789101112131415int queryid(int val) &#123; int ans = 0, cur = root; while (1) &#123; if (val &lt; node[cur].val) cur = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].sum; if (val == node[cur].val) &#123; splay(cur); return ans + 1; &#125; ans += node[cur].cnt; cur = node[cur].ch[1]; &#125; &#125;&#125; 查询排名为k的数分析咕咕咕 1234567891011int queryrid(int k) &#123; int cur = root; while (1) &#123; if (node[cur].ch[0] &amp;&amp; k &lt;= node[node[cur].ch[0]].sum) cur = node[cur].ch[0]; else &#123; k -= node[cur].cnt + node[node[cur].ch[0]].sum; if (k &lt;= 0) return node[cur].val; cur = node[cur].ch[1]; &#125; &#125;&#125; 查询前驱分析古古古 1234567int querypre(int val) &#123; insert(val); int cur = node[root].ch[0]; while (node[cur].ch[1]) cur = node[cur].ch[1]; delet(val); return cur;&#125; 查询后继1234567int querynxt(int val) &#123; insert(val); int cur = node[root].ch[1]; while (node[cur].ch[0]) cur = node[cur].ch[0]; delet(val); return cur;&#125; 删除元素1234567891011121314151617181920212223242526272829303132void delet(int val) &#123; queryid(val); if (node[root].cnt &gt; 1) &#123; node[root].cnt--; update(root); return; &#125; if (node[root].ch[0] == 0 &amp;&amp; node[root].ch[1] == 0) &#123; clear(root); root = 0; return; &#125; if (node[root].ch[1] == 0) &#123; int cur = root; root = node[root].ch[0]; node[root].fa = 0; clear(cur); return; &#125; if (node[root].ch[0] == 0) &#123; int cur = root; root = node[root].ch[1]; node[root].fa = 0; clear(cur); return; &#125; int u = querypre(val), cur = root; // ??? node[node[cur].ch[1]].fa = u; node[u].ch[1] = node[cur].ch[1]; clear(cur); update(root);&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3275糖果]]></title>
    <url>%2F2019%2F07%2F23%2Fsolution-luogu-p3275%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个长度为$n$的序列以及$k$个条件，每个条件要求序列当中一个点的权值大于/小于/不大于/不小于/等于另一个点。求这个序列总和的最小值 $1 \le k,n \le 100000$ 感谢@oy 的贡献 差分约束系统的模板题。 记 $d$ 数组为以 $S$ 为源点到各个节点的最长路。根据最长路的性质，如果存在一条边 $(u,v,w)$ ，则一定满足以下不等式： d[u]+w(u,v)\le d[v]我们可以将题目中给出的不等关系转化为图中的有向边，然后通过单源最长路求出的一组 $\lbrace d_n\rbrace$ 即为差分约束系统的一组解。 因此，在图中连一条边 $(u,v,w)$ 相当于对 $d[u]$ 和 $d[v]$ 的取值作出限制，我们只需在构造出一张有向图，并求出其单源最长路即为答案。 有向边的构造方式如下： 限制 $d[A]=d[B]$ d[A]=d[B] \Leftrightarrow (d[B]\le d[A])\wedge(d[A]\le d[B]) \Leftrightarrow (d[B]+0\le d[A])\wedge(d[A]+0\le d[B])连边：$(A,B,0)$，$(B,A,0)$ 限制 $d[A]&lt;d[B]$ d[A]d[B]\Leftrightarrow d[B]+1\le d[A] 连边：$(B,A,1)$ 限制 $d[A]\le d[B]$ 连边：$(A,B,0)$ 限制 $d[i]&gt;0$ 连边：$(S,i,1)$ 连完所有的边后，跑一遍单源最长路；如果存在正环则输出无解。 统计答案时记得开$long$ $long$。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define die &#123;puts("-1"); exit(0);&#125;typedef long long ll;const int MAXN = 100005;struct Edge &#123; int v, w; Edge(int v, int w) &#123; this -&gt; v = v, this -&gt; w = w; &#125;&#125;;vector&lt;Edge&gt; G[MAXN];int N, K;bool inq[MAXN];int d[MAXN], cnt[MAXN];inline void AddEdge(int u, int v, int w) &#123; G[u].push_back(Edge(v, w));&#125;void SPFA() &#123; queue&lt;int&gt; q; q.push(N + 1); d[N + 1] = 0; inq[N + 1] = 1; while (q.size()) &#123; int u = q.front(); q.pop(); if (cnt[u] &gt;= N) die cnt[u]++; inq[u] = 0; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (d[u] + w &gt; d[v]) &#123; d[v] = d[u] + w; if (inq[v] == 0) &#123; inq[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= K; ++i) &#123; int X, A, B; scanf("%d%d%d", &amp;X, &amp;A, &amp;B); switch (X) &#123; case 1: AddEdge(A, B, 0); AddEdge(B, A, 0); break; case 2: if (A == B) die AddEdge(A, B, 1); break; case 3: AddEdge(B, A, 0); break; case 4: if (A == B) die AddEdge(B, A, 1); break; case 5: AddEdge(A, B, 0); break; &#125; &#125; for (register int i = 1; i &lt;= N; ++i) AddEdge(N + 1, i, 1); SPFA(); ll ans = 0; for (register int i = 1; i &lt;= N; ++i) ans += d[i]; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4175网络管理]]></title>
    <url>%2F2019%2F07%2F21%2Fsolution-luogu-p4175%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵$n$个节点的树，进行$q$次操作：单点修改，或查询一条树链上的第$k$小值。 $n,q \le 80000,0 \le k \le n$ 感谢@oy的贡献 思路：树链剖分+树状数组套主席树 考虑到权值线段树自带buff——整体二分，不难想到对树链上的权值线段树求和，并在合并后的权值线段树上求第 $k$ 大即可愉快地解决本题。 在树链上的求和操作可以用树剖加线性数据结构进行维护。本题需要支持的操作只有单点修改和区间查询，所以可以用树状数组套主席树维护 dfs 序上的信息。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lson(x) (node[x].l)#define rson(x) (node[x].r)#define sum(x) (node[x].sum)#define lowbit(x) (x &amp; (-x))const int MAXN = 80005 * 2;vector&lt;int&gt; G[MAXN];struct opt &#123;int k, a, b;&#125; op[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125; node[MAXN * 80];int c[MAXN], cnt;int N, Q, L;int t[MAXN], b[MAXN];int q1[MAXN], q2[MAXN], len1, len2;int dep[MAXN], dfn[MAXN], f[MAXN], son[MAXN], top[MAXN], size[MAXN], dfn_idx;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; sum(u) += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(lson(u), l, mid, p, val); else insert(rson(u), mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void dfs1(int u, int fa) &#123; dep[u] = dep[fa] + 1; f[u] = fa; size[u] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); if (size[v] &gt; size[son[u]]) son[u] = v; size[u] += size[v]; &#125;&#125;void dfs2(int u, int topc) &#123; dfn[u] = ++dfn_idx; top[u] = topc; modify(dfn[u], t[u], 1); if (son[u]) dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == son[u] || v == f[u]) continue; dfs2(v, v); &#125;&#125;void pre_bin(int u, int* a, int&amp; len) &#123; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int pre(int u, int v) &#123; len1 = len2 = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[top[u]] - 1, q2, len2); u = f[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[v] - 1, q2, len2); return v;&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, rsum = 0; for (int i = 1; i &lt;= len1; ++i) rsum += sum(rson(q1[i])); for (int i = 1; i &lt;= len2; ++i) rsum -= sum(rson(q2[i])); if (k &lt;= rsum) &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = rson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = rson(q2[i]); return query(mid + 1, r, k); &#125; else &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = lson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = lson(q2[i]); return query(l, mid, k - rsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;Q); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;t[i]), b[++L] = t[i], c[i] = ++cnt; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (register int i = 1; i &lt;= Q; ++i) &#123; scanf("%d%d%d", &amp;op[i].k, &amp;op[i].a, &amp;op[i].b); if (op[i].k == 0) b[++L] = op[i].b; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) t[i] = id(t[i]); dfs1(1, 0); dfs2(1, 1); for (register int i = 1; i &lt;= Q; ++i) &#123; int k = op[i].k, a = op[i].a, b_ = op[i].b; if (k == 0) &#123; b_ = id(b_); modify(dfn[a], t[a], -1); t[a] = b_; modify(dfn[a], t[a], 1); &#125; else &#123; int lca = pre(a, b_); int maxk = dep[a] + dep[b_] - dep[lca] * 2 + 1; if (maxk &lt; k) &#123; puts("invalid request!"); continue; &#125; printf("%d\n", rid(query(1, L, k))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-树套树]]></title>
    <url>%2F2019%2F07%2F21%2Falgorithm-treeintree%2F</url>
    <content type="text"><![CDATA[本文部分内容转载自 OI Wiki 树状数组套主席树 概述普通数据结构维护单一维度信息，树套树维护多维度信息。 树状数组套权值线段树树状数组套权值线段树可以在 $O(n \log^2 n)$ 的时间复杂度解决动态区间 $k$ 小值问题。 如果用线段树套平衡树中所论述的，用线段树套平衡树，即对于线段树的每一个节点，对于其所表示的区间维护一个平衡树，然后用二分来查找 $k$ 小值。由于每次查询操作都要覆盖多个区间，即有多个节点，但是平衡树并不能多个值一起查找，所以时间复杂度是 $O(n\log^3 n)$，并不是最优的。 思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 线段树套主席树 。 说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为 动态开点权值线段树 更为确切。 思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。 在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过 $O(\log n)$ 个线段树上的节点，在动态开点权值线段树上一次修改操作是 $O(\log n)$ 的，所以修改操作的时间复杂度为 $O(\log^2 n)$ 。 由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 树状数组 实现。 给出一种代码实现：luogu-p2617 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lowbit(x) (x &amp; (-x))const int MAXN = 100005 * 2;struct op &#123; char opt; int i, j, k, t;&#125;ops[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125;node[MAXN * 80];int cnt, c[MAXN];int N, M, L;int a[MAXN], b[MAXN];int qr[MAXN], ql[MAXN], qrlen, qllen;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; node[u].sum += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(node[u].l, l, mid, p, val); else insert(node[u].r, mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void pre(int u, int* a, int&amp; len) &#123; len = 0; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, lsum = 0; for (int i = 1; i &lt;= qrlen; ++i) lsum += node[node[qr[i]].l].sum; for (int i = 1; i &lt;= qllen; ++i) lsum -= node[node[ql[i]].l].sum; if (lsum &gt;= k) &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].l; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].l; return query(l, mid, k); &#125; else &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].r; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].r; return query(mid + 1, r, k - lsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%d", &amp;a[i]), b[++L] = a[i], c[i] = ++cnt; &#125; for (register int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; ops[i].opt; if (ops[i].opt == 'Q') &#123; scanf("%d%d%d", &amp;ops[i].i, &amp;ops[i].j, &amp;ops[i].k); &#125; else &#123; scanf("%d%d", &amp;ops[i].i, &amp;ops[i].t); b[++L] = ops[i].t; &#125; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) &#123; a[i] = id(a[i]); modify(i, a[i], 1); &#125; for (register int i = 1; i &lt;= M; ++i) &#123; if (ops[i].opt == 'Q') &#123; pre(ops[i].j, qr, qrlen); pre(ops[i].i - 1, ql, qllen); printf("%d\n", rid(query(1, L, ops[i].k))); &#125; else &#123; modify(ops[i].i, a[ops[i].i], -1); a[ops[i].i] = id(ops[i].t); modify(ops[i].i, a[ops[i].i], 1); &#125; &#125; return 0;&#125; 未完待续……等我学完平衡树再接着弄]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-cf1195c Basketball Exercise]]></title>
    <url>%2F2019%2F07%2F18%2Fsolution-luogu-cf1195c%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个$2*n$的矩阵，从中选出若干数，且任意两个数不上下或左右相邻，求这些数的最大总和 $1\le n \le 100000,1 \le h_{i,j}\le 1000000000$ 很水的一道C题……目测难度在黄~绿左右。请各位切题者合理评分。 注意到可以选择的球员编号是严格递增的，因此可以把状态的第一维定义为球员编号，第二维描述编号同为 $i$ 的两名球员的选取情况。 定义状态：$f[i][0/1/2]$ 表示选取了编号在 $i$ 及以前的球员，所能得到的身高总和最大值。其中，第二维的 $0$ 表示编号为 $i$ 的球员一个都不选；$1$ 表示只选上面一个；$i$ 表示只选下面一个。（显然没有上下都选的情况） 状态转移方程： f[i][0]=max\lbrace f[i-1][0],f[i-1][1],f[i-1][2]\rbrace f[i][1]=max\lbrace f[i-1][0],f[i-1][2]\rbrace+height[i][1] f[i][2]=max\lbrace f[i-1][0],f[i-1][1]\rbrace+height[i][2]Update: 用贪心可以证明，在最优解中，不会出现连续两列一个不取的情况。因此， $f[i][0]$ 其实没有必要考虑来自 $f[i-1][0]$ 的状态转移。 代码如下：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;ll h[100005][3];ll f[100005][3];int main() &#123; cin &gt;&gt; N; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][1]; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][2]; f[1][0] = 0; f[1][1] = h[1][1]; f[1][2] = h[1][2]; for (register int i = 2; i &lt;= N; ++i) &#123; f[i][0] = max(f[i - 1][0], max(f[i - 1][1], f[i - 1][2])); f[i][1] = max(f[i - 1][0], f[i - 1][2]) + h[i][1]; f[i][2] = max(f[i - 1][0], f[i - 1][1]) + h[i][2]; &#125; cout &lt;&lt; max(f[N][0], max(f[N][1], f[N][2])); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-卡特兰数]]></title>
    <url>%2F2019%2F07%2F14%2Falgorithm-maths-catalan%2F</url>
    <content type="text"><![CDATA[咕咕咕~]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1641生成字符串]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p1641%2F</url>
    <content type="text"><![CDATA[题目链接 将$n$个$1$和$m$个$0$组成字符串，使得在任意的前$k$个字符中，$1$的个数不能少于$0$的个数。求满足条件的字符串共有多少个。 $1\le m \le n \le 1000000$ 本题是卡特兰数的一个简单变式。 回忆卡特兰数的推导过程，可以生成的所有字符串共有$C_{n+m}^n$个，其中不合法的字符串有$C_{n+m}^{n+1}$个。最终答案即为$C_{n+m}^{n}-C_{n+m}^{n+1}$。计算组合数前须预处理出阶乘逆元。 代码如下： 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int p = 20100403;int N, M;int inv[2000005], fac[2000005], facinv[2000005];int C(int n, int m) &#123; return (ll) fac[n] * facinv[m] % p * facinv[n - m] % p;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; inv[1] = 1; fac[0] = fac[1] = 1; facinv[1] = 1; for (register int i = 2; i &lt;= N + M; ++i) &#123; inv[i] = (ll) (p - p / i) * inv[p % i] % p; fac[i] = (ll) i * fac[i - 1] % p; facinv[i] = (ll) facinv[i - 1] * inv[i] % p; &#125; cout &lt;&lt; (C(N + M, N) - C(N + M, N + 1) + p) % p; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>卡特兰数</tag>
        <tag>数学</tag>
        <tag>逆元</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-乘法逆元]]></title>
    <url>%2F2019%2F07%2F13%2Falgorithm-maths-multiplicativeinversion%2F</url>
    <content type="text"><![CDATA[概述 乘法逆元定义：如果一个线性同余方程$ax\equiv 1 \mod b$，则$x$成为$a \mod b$的逆元，记作$a^{-1}$。 乘法逆元一般用于求$a\/b\mod p$的值（$p$通常为质数），是解决模意义下分数数值的必要手段。 对于$a\/b\mod p$，我们可以求出$b$在$\mod p$下的逆元，然后乘上$a$再$\mod p$，就是这个分数的值了。 求解逆元的方法扩展欧几里得法求解$ax\equiv 1 \mod b$ 等价于解不定方程 $ax+by=1$，求解出的$x$即为$a \mod b$的逆元。 12345678void exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125; 快速幂法 费马小定理 若$p$为质数，$a$为正整数，且$a$、$p$互质，则$a^{p-1}\equiv 1 (\mod p)$。 因为$ax\equiv 1\mod b$ 所以$ax\equiv a^{b-1}\mod b$ 所以$x\equiv a^{b-2}\mod b$ 然后可以使用快速幂求解逆元。 代码略。 线性求逆元假设现在要求$inv[i]$。 考虑带余除法，设$p=iq+r$，则有$iq+r\equiv 0\mod p$ 注意到$p$是质数，因此$r$不为$0$，$r$的逆元存在 等式两边乘$i^{-1}r^{-1}$，得到$qr^{-1}+i^{-1}\equiv 0\mod p$ 因此$i^{-1}\equiv -qr^{-1}\equiv -(p\/i)(p \mod i)^{-1}\mod p$ 12for (inv[1] = 1, i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p;]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5021赛道修建]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p5021%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个有$n$个节点的树，在其中选出$m$条没有公共边的路径，并使得$m$条路径中最短路径的长度尽可能大。输出这个最短路径的长度。 $2\le n \le 50000,1\le m\le n-1 $ 题目要求使$m$条赛道中最短赛道的长度尽可能大，不难想到二分最短赛道的长度$len$，并判定是否能修建出$m$条赛道。 定义$f[u]$为自节点$u$向下延伸的不作为赛道的最长链长度。假设已知所有的$f[v]+w(u,v) (v\in son(u))$（即自节点$u$向下延伸的所有链的长度），则我们应在保证这些链能组成最多赛道的前提下，使保留下来的$f[v]+w(u,v)$最大。 考虑贪心。对于$f[v]+w(u,v)\ge len$的情况，可以直接将其作为一条赛道。而剩余的链，只能将它们两两拼接成赛道。由于需要使保留下来的$f[v]+w(u,v)$取最大值，所以我们可以优先使较短的链得到匹配，在剩余的无法匹配的链中取最值作为新的$f[u]$。 贪心操作可以用$multiset$实现。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50005;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G[MAXN];int N, M, L, cnt;int f[MAXN];inline bool cmp(int a, int b) &#123;return a &gt; b;&#125;inline void dfs(int u, int fa) &#123; multiset&lt;int&gt; s; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (v == fa) continue; dfs(v, u); if (f[v] + w &gt;= L) cnt++; else s.insert(f[v] + w); &#125; while (!s.empty()) &#123; multiset&lt;int&gt;::iterator it = s.begin(); s.erase(it); multiset&lt;int&gt;::iterator it1 = s.lower_bound(L - *it); if (it1 == s.end()) f[u] = max(f[u], *it); else &#123; cnt++; s.erase(it1); &#125; &#125;&#125;inline bool check() &#123; memset(f, 0, sizeof(f)); cnt = 0; dfs(1, 0); if (cnt &gt;= M) return 1; return 0;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G[u].push_back((Edge)&#123;v, w&#125;); G[v].push_back((Edge)&#123;u, w&#125;); &#125; int l = 0, r = 500000000; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; L = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-树链剖分]]></title>
    <url>%2F2019%2F07%2F04%2Falgorithm-treechainsectioning%2F</url>
    <content type="text"><![CDATA[概述树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。 具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。 模板【实现过程】 第一个 DFS 记录每个结点的深度（deep）、子树大小（size）。 第二个 DFS 记录每个结点的重子结点（heavy-son）、重边优先遍历时的 DFN 序、所在链的链顶（top，且应初始化为结点本身）。 链上的 DFN 序是连续的，可以使用线段树，树状数组维护。 每次选择深度较大的链往上跳，直到两点在同一条链上。 在 DFS 搜索的时候，子树中的结点的 DFN 序是连续的。 每一个结点记录 bottom 表示所在子树连续区间末端的结点。 这样就把子树信息转化为连续的一段区间信息。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100005;vector&lt;int&gt; G[MAXN];int N, M, R, P;int w[MAXN], fa[MAXN], size[MAXN], son[MAXN], top[MAXN], dep[MAXN];int dfn[MAXN], dfn_index;struct Node &#123; int l, r, sum, tag;&#125;node[MAXN * 2];int cnt;int a[MAXN];inline void build(Node&amp; u, int l, int r) &#123; u.tag = 0; if (l == r) &#123; u.sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r); u.sum = (node[u.l].sum + node[u.r].sum);&#125;inline void pushdown(Node&amp; u, int l, int r) &#123; if (u.tag) &#123; int mid = (l + r) &gt;&gt; 1; node[u.l].sum = (node[u.l].sum + u.tag * (mid - l + 1)); node[u.r].sum = (node[u.r].sum + u.tag * (r - mid)); node[u.l].tag = (node[u.l].tag + u.tag); node[u.r].tag = (node[u.r].tag + u.tag); u.tag = 0; &#125;&#125;inline void modify(Node&amp; u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; u.tag = (u.tag + val) % P; u.sum = (u.sum + val * (r - l + 1)) % P; return; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify(node[u.l], l, mid, ql, qr, val); if (mid &lt; qr) modify(node[u.r], mid + 1, r, ql, qr, val); u.sum = (node[u.l].sum + node[u.r].sum) % P;&#125;inline int query(Node&amp; u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return u.sum; &#125; int mid = (l + r) &gt;&gt; 1, ans = 0; pushdown(u, l, r); if (ql &lt;= mid) ans = (ans + query(node[u.l], l, mid, ql, qr)) % P; if (mid &lt; qr) ans = (ans + query(node[u.r], mid + 1, r, ql, qr)) % P; return ans;&#125;inline void dfs1(int u, int fath) &#123; size[u] = 1; fa[u] = fath; dep[u] = dep[fath] + 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fath) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;inline void dfs2(int u, int topc) &#123; top[u] = topc; dfn[u] = ++dfn_index; a[dfn[u]] = w[u]; if (son[u] == 0) return; dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;inline void ModifySubtree(int u, int val) &#123; modify(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1, val);&#125;inline int QuerySubtree(int u) &#123; return query(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1);&#125;inline void ModifyChain(int u, int v, int val) &#123; val %= P; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); modify(node[0], 1, N, dfn[top[u]], dfn[u], val); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); modify(node[0], 1, N, dfn[v], dfn[u], val);&#125;inline int QueryChain(int u, int v) &#123; int ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[top[u]], dfn[u])) % P; u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[v], dfn[u])) % P; return ans;&#125;int main() &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;R, &amp;P); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;w[i]); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(R, 0); dfs2(R, R); build(node[0], 1, N); for (register int i = 1; i &lt;= M; ++i) &#123; int opt, x, y, z; scanf("%d", &amp;opt); if (opt == 1) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); ModifyChain(x, y, z); &#125; if (opt == 2) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", QueryChain(x, y)); &#125; if (opt == 3) &#123; scanf("%d%d", &amp;x, &amp;z); ModifySubtree(x, z); &#125; if (opt == 4) &#123; scanf("%d", &amp;x); printf("%d\n", QuerySubtree(x)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2831愤怒的小鸟]]></title>
    <url>%2F2019%2F07%2F03%2Fsolution-luogu-p2831%2F</url>
    <content type="text"><![CDATA[题目链接 在平面直角坐标系中给定$n$个位于第一象限的点，求至少需要从原点引出多少条开口向下的抛物线，使它们经过所有的点。 $ 1 \le n \le 18 $ 感谢@oy的贡献 一道并不是特别难的状压dp。 状态定义：$f[s]$表示将所有剩余的猪消灭至少需要多少只小鸟，其中$s$表示已经消灭的猪的集合。 考虑状态转移，发射一个小鸟可以消灭尚未被消灭的猪。记$curve[i][j]$为一个二进制集合，表示经过第$i$、$j$号猪的抛物线能消灭哪些猪。 即： f[s]=min\lbrace f[s|curve[i][j]]+1\rbrace可以用记忆化搜索实现，注意精度控制和触摸状态。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-7;int T;int N, M;double x[19], y[19];int curve[19][19];int f[524289];inline void equals(double&amp; a, double&amp; b, double x1, double y1, double x2, double y2) &#123; a = (y1 * x2 - x1 * y2) / (x1 * x1 * x2 - x2 * x2 * x1); b = (y1 - x1 * x1 * a) / x1;&#125;inline int dp(int s) &#123; if (f[s] != -1) return f[s]; if (s == (1 &lt;&lt; N) - 1) return f[s] = 0; f[s] = INF; for (register int i = 1; i &lt;= N; ++i) &#123; for (register int j = i; j &lt;= N; ++j) &#123; f[s] = min(f[s], dp(s | curve[i][j]) + 1); &#125; &#125; return f[s];&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; memset(curve, 0, sizeof(curve)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%lf%lf", &amp;x[i], &amp;y[i]); for (register int p1 = 1; p1 &lt;= N; ++p1) &#123; for (register int p2 = p1 + 1; p2 &lt;= N; ++p2) &#123; double a, b; equals(a, b, x[p1], y[p1], x[p2], y[p2]); if (a &gt;= 0) continue; for (register int i = 1; i &lt;= N; ++i) &#123; if (x[i] * x[i] * a + x[i] * b &gt;= y[i] - EPS &amp;&amp; x[i] * x[i] * a + x[i] * b &lt;= y[i] + EPS) &#123; curve[p1][p2] |= (1 &lt;&lt; (i - 1)); curve[p2][p1] |= (1 &lt;&lt; (i - 1)); &#125; &#125; &#125; &#125; for (register int p = 1; p &lt;= N; ++p) curve[p][p] = (1 &lt;&lt; (p - 1)); memset(f, -1, sizeof(f)); printf("%d\n", dp(0)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3959宝藏]]></title>
    <url>%2F2019%2F06%2F30%2Fsolution-luogu-p3959%2F</url>
    <content type="text"><![CDATA[题目链接 输入一个有$n$个点$m$条边的有权无向图。选定任意节点作为根节点。构造一棵生成树，使得树上所有真实边权的总和最小。真实边权的计算公式：$w(u,v)\times L$，其中$L$为根节点到$u$路径上的节点总数。 $1\le n \le 12,1 \le m \le 1000$ 感谢@oy的贡献 这道题做了很长时间，从一开始推出错误的状态转移方程，到埋头优化正确的状态转移，前后花了一个多星期…… 本题题解可以保证正确性（当然欢迎Hack），却在速度上略有欠缺。 状态定义：$f[s][u][d]$ $s$表示当前已联通的点集，$u$表示当前点集生成树的树根，$d$表示$u$到起点的距离。（注意：$u$不是起点） 状态转移：状态肯定是通过挖通道来转移的。如果将$u$和$v$之间挖通，则$u$所在的连通块和$v$所在的连通块将会合并。如果以$u$作为根，$u$到起点的距离为$d$，则$v$到起点的距离为$(d+1)$。方程如下： f[s][u][d]=min\lbrace f[s1][u][d]+f[s2][v][d+1]+w(u,v)*d\rbrace其中： s1 \cup s2=s,u\in s1,v\in s2,w(u,v)\not= \inf最终要求的答案即为$\min_{1\le i \le n}f[(1&lt;&lt;n)-1][i][1]$，采用记忆化搜索实现。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int N, M;int w[13][13];int f[1&lt;&lt;13][13][13];inline int dp(int s, int u, int d) &#123; if (f[s][u][d] != -1) return f[s][u][d]; if (s == (1 &lt;&lt; (u - 1))) return f[s][u][d] = 0; int&amp; ans = f[s][u][d] = INF; for (register int s1 = s; s1; s1 = (s1 - 1) &amp; s) &#123; if (!(s1 &amp; (1 &lt;&lt; (u - 1)))) continue; for (register int v = 1; v &lt;= N; ++v) &#123; if (!(s &amp; (1 &lt;&lt; (v - 1)))) continue; if (w[u][v] == INF) continue; int s2 = s ^ s1; ans = min(ans, dp(s1, u, d) + dp(s2, v, d + 1) + w[u][v] * d); &#125; &#125; return ans;&#125;int main() &#123; memset(w, 0x3f, sizeof(w)); memset(f, -1, sizeof(f)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, t; scanf("%d%d%d", &amp;u, &amp;v, &amp;t); w[u][v] = w[v][u] = min(w[u][v], t); &#125; int ans = INF; for (register int u = 1; u &lt;= N; ++u) &#123; ans = min(ans, dp((1 &lt;&lt; N) - 1, u, 1)); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-6-20]]></title>
    <url>%2F2019%2F06%2F20%2Fbulletin-2019-6-20%2F</url>
    <content type="text"><![CDATA[招募启事tth37最近发现，他写了好多好多题解啦。但是这些题解全都被展示在Homepage里，导致Homepage不够简洁，题目检索不太方便。 于是，tth37决定在每篇题解最前面，写一段题目内容的一句话总结。但是tth37比较忙，实在不想做这件事，因此他决定招募跪求巨佬来帮他完成这项工作。 一份完整的一句话总结必须清楚地概括题面（拒绝花里胡哨），并且给出数据范围。一切字母必须采用$L^AT_EX$公式。（百度一下？） 写好一句话总结后，请将其上传至洛谷剪贴板，并将剪贴板链接发给tth37。tth37会根据其质量，酌情发送0.01~0.66元红包作为报酬。 如果在座的各位对本活动反响不够热烈，tth37可能会强迫你们当中的一些人完成这项任务。当然，没有报酬。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p3953逛公园]]></title>
    <url>%2F2019%2F06%2F19%2Fsolution-luogu-p3953%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个$n$个点$m$条边的有向带权图，设起点到终点的最短路为$d$，求起点到终点满足权值总和小于等于$(d+k)$的路径数量 $1 \le p\le 10^9 $ , $1 \le n\le 10^5$ , $1 \le m\le 2 \times 10^5$ , $1 \le k\le 50$ 感谢@oy 的贡献 一道看似图论实则可以用动态规划解决的题目。 朴素的状态定义：$f[u][k]$表示从$1$号节点走到$u$号节点，路径长度为$k$的方案总数。状态转移方程： f[u][k]=\sum_{(u,v)\in E}f[v][k-w(u,v)]但是这样的状态定义有一个严重的问题：空间消耗过大。考虑到题目中给出的$K$值并不大，我们可以利用题目所要求的信息来优化状态设计。 优化后的状态定义：$d[u]$表示从$1$号节点走到$u$号节点的最短路长度，$f[u][k]$表示从$1$号节点走到$u$号节点，路径长度为$d[u]+k$的方案总数。 如此一来，状态所需的空间大大减少，但相应的状态转移略显复杂。不妨设$f[u][k]$状态可以由$f[v][x]$转移得到，则： d[v]+x+w(u,v)=d[u]+k移项，得到： x=d[u]-d[v]+k-w(u,v)因此，完整的状态转移方程如下： f[u][k]=\sum_{(u,v)\in E}f[v][d[u]-d[v]+k-w(u,v)]我们最终要求的答案即为$\sum_{i=0}^Kf[N][i]$，用记忆化搜索实现即可。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100001;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G1[MAXN], G2[MAXN];int T, N, M, K, P;bool fail;int f[MAXN][51];int d[MAXN];bool vis[MAXN];bool ins[MAXN][51];void Dijkstra() &#123; memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(0, 1)); d[1] = 0; while (q.size()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (vector&lt;Edge&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123; int v = it-&gt;v, w = it-&gt;w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; q.push(make_pair(-d[v], v)); &#125; &#125; &#125;&#125;inline int dp(int u, int k) &#123; if (k &lt; 0) return 0; if (ins[u][k])&#123; fail = 1; return 0; &#125; if (f[u][k]) return f[u][k]; ins[u][k] = 1; int ans = 0; for (vector&lt;Edge&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123; int p = it-&gt;v, w = it-&gt;w; ans = (ans + dp(p, d[u] - d[p] + k - w))%P; if (fail == 1) return 0; &#125; ins[u][k] = 0; return f[u][k] = ans;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;K, &amp;P); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G1[u].push_back((Edge)&#123;v, w&#125;); G2[v].push_back((Edge)&#123;u, w&#125;); &#125; Dijkstra(); dp(1, 0); f[1][0] = 1; int ans = 0; for (register int i = 0; i &lt;= K; ++i) &#123; ans = (ans + dp(N, i))%P; &#125; if(fail == 1) puts("-1"); else printf("%d\n", ans); fail = 0; memset(f, 0, sizeof(f)); memset(ins, 0, sizeof(ins)); for (register int i = 1; i &lt;= N; ++i) &#123; G1[i].clear(), G2[i].clear(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2627修剪草坪]]></title>
    <url>%2F2019%2F06%2F09%2Fsolution-luogu-p2627%2F</url>
    <content type="text"><![CDATA[题目链接 读入$n$个整数，选取其中若干个数，最多连续取$k$个，求取到数字和的最大值 $1\le k \le n \le 100000$ 感谢@oy 的贡献 一道单调队列入门题。 面对动规题，首先设计状态转移方程。令$f[i]$表示$1-i$中连取不超过$K$个数，且第$i$个数不取所能累加的最大和。 因为第$i$个数不取，所以在$i$之前一定连取了一段数。这段数的长度可能为$0-K$（注意是$0-K$而不是$1-K$，可以通过手推样例发现最优解中可能存在连着两个数不取的情况）。连取的一段数所能累加的和可以用前缀和计算。考虑边界条件后，状态转移方程如下： f[i]=\max_{i-K-1\le j \le i-1} \lbrace f[j]+s[i-1]-s[j] \rbrace由于$max$函数的循环变量是$j$，所以只与$i$相关的变量$s[i-1]$可以作为常数提出到$max$函数之外，即： f[i]=\max_{i-K-1\le j \le i-1}\lbrace f[j]-s[j]\rbrace +s[i-1]将状态转移方程化简到这样，就已经可以用单调队列进行优化了。我们可以用单调队列维护$f[j]-s[j]$的最值，在循环时将其最大值取出再加上$s[i-1]$即为$f[i]$。 如果想不到该如何操作，也可以这样理解： g[i]=f[i]-s[i] f[i]=\max_{i-K-1\le j \le i-1}\lbrace g[j]\rbrace+s[i-1]由于我们定义$f[i]$是第$i$个数不取的最优解，可以强行求解$f[N+1]$（虽然它似乎没有实际意义）作为本题的最终答案。 代码如下： 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, K;ll s[100005], f[100005];int q[100005];int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%lld", &amp;s[i]); s[i] += s[i-1]; &#125; int l = 0, r = 1; q[0] = 0, f[0] = 0; for (register int i = 1; i &lt;= N + 1; ++i) &#123; while (l &lt; r &amp;&amp; q[l] &lt; i - K - 1) l++; f[i] = f[q[l]] - s[q[l]] + s[i-1]; while (l &lt; r &amp;&amp; f[q[r - 1]] - s[q[r - 1]] &lt; f[i] - s[i]) r--; q[r++] = i; &#125; printf("%lld", f[N + 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1600天天爱跑步(Beta)]]></title>
    <url>%2F2019%2F06%2F07%2Fsolution-luogu-p1600%2F</url>
    <content type="text"><![CDATA[题目链接 $n$个点的树上有$m$条路径$(S_i, T_i)$，每条路径上各有一个人从$S_i$跑到$T_i$。他们在第$0$时刻同时跑，每秒能跑一条边。回答$n$个询问，询问恰好在第$W_i$时刻到达节点$i$的人数。 $1 \le n \le 300000,1 \le m \le 300000 $ 感谢@tth37 的贡献 准备写一篇较为详细的题解。部分思路来自《算法竞赛进阶指南》。 游戏地图构成树形结构，为方便处理，可以取$1$号节点作为根，转化为有根树处理。 可以发现，从S到T的路径有且只有一条，并且必将经过$lca(S,T)$。 不妨设$x$节点上有一名观察员，其观察时间为$W[x]$。我们可以对$x$的位置进行分情况讨论。 $x$在$S$到$lca(S,T)$的路径上（该路径包含$lca(S,T)$）。 为方便说明，假设$S=6$，$T=4$。那么，此时$x$可能为$1$，$3$或$6$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=d[S]-d[x]$（$d$数组表示节点深度）。对上式移项，得到$W[x]+d[x]=d[S]$。 接下来，我们给每一个节点分配若干个权值，即在每一个节点上开一个一维数组，记录各个权值。根据上式，我们可以将$S$到$lca(S,T)$的路径上每一个节点的$d[S]$号权值加一。按照这种方式处理完所有玩家的信息之后，我们遍历所有节点，每个节点上的$(W[x]+d[x])$号权值即为所求。 该方法的正确性应该不难理解。$(W[x]+d[x])$号权值的意义即为该节点上满足前文所述等式的玩家个数，而满足等式意味着玩家将会在观察员探头时经过观察点，符合题意。 但是这种暴力方法显然还有优化的空间。在有根树的一条链上进行权值更改，可以尝试用树上差分的知识解决。在节点$S$上的$d[S]$号权值加一，节点$fa[lca(S,T)]$上的$d[S]$号权值减一（可以在每个节点上开一个不定长数组vector记录当前节点上的加减操作），最后进行统计时，计算当前子树所有$(W[x]+d[x])$号权值和即可。但即便如此，答案统计也并不容易实现；我们可以使用以下方法： 建立全局数组$s$，其中$s[i]$表示$i$号权值之和。深度优先遍历所有节点，在刚访问到当前节点时，记录$cnt=s[W[x]+d[x]]$。遍历当前节点上的vector，执行加减操作（例如：vector中的一项操作把$3$号权值减一，则$s[3]=s[3]-1$）。递归访问当前节点的所有子节点。访问结束后，$(s[W[x]+d[x]]-cnt)$即为所求。 结合dfs序的相关知识，访问完当前节点的所有子节点之后，$s$数组已经记录了以$x$为根的子树上所有操作。因此将访问后与访问前的权值相减，即为树上差分所得到的答案。 别忘了才分类讨论了一半呢…… $x$在$lca(S,T)$到$T$的路径上（该路径不包含$lca(S,T)$）。同样假设$S=6$，$T=4$。此时$x$可能为$2$或$4$。如果此观察员可以观察到当前玩家，当且仅当$W[x]=(d[S]-d[lca(S,T)])+(d[x]-d[lca(S,T)])$。对上式移项，得到$W[x]-d[x]=d[S]-2*d[lca(S,T)]$。 类似地，我们只需将操作改为对$(d[S]-2*d[lca(S,T)])$号权值的操作即可。由于权值有可能为负，需要将序号整体平移$N$个单位，即改为对$(d[S]-2*d[lca(S,T)]+N)$号权值的操作。在每个节点上另开一个操作vector，统计答案时另开一个$s$数组，将计算出的答案与第一种情况的答案相加即可。 Q：为什么必须另开操作vector和$s$数组？ A：回顾一下提到的两个式子：$W[x]+d[x]=d[S]$，$W[x]-d[x]=d[S]-2*d[lca(S,T)]$如果将两者合起来操作，有可能产生“将$d[S]$号权值加一，碰巧统计答案时$W[x]-d[x]=d[S]$”的情况。然而，上述等式是没有任何意义的：$x$号节点根本无法观察到玩家。为了避免此类错误，必须将两种操作分开处理。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300005;struct opt &#123;int id, op;&#125;;vector&lt;int&gt; G[MAXN];vector&lt;opt&gt; opt1[MAXN], opt2[MAXN];int N, M;int W[MAXN];int f[MAXN][20], d[MAXN];void dfs1(int u, int fa) &#123; f[u][0] = fa, d[u] = d[fa] + 1; for (register int i = 1; i &lt;= 19; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (d[u] &lt; d[v]) swap(u, v); for (register int i = 19; i &gt;= 0; --i) &#123; if (d[f[u][i]] &gt;= d[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 19; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int s1[MAXN*3], s2[MAXN*3];int ans[MAXN];void dfs2(int u, int fa) &#123; int cnt1 = s1[W[u] + d[u] + N]; int cnt2 = s2[W[u] - d[u] + N]; for (vector&lt;opt&gt;::iterator it = opt1[u].begin(); it != opt1[u].end(); it++) s1[it-&gt;id] += it-&gt;op; for (vector&lt;opt&gt;::iterator it = opt2[u].begin(); it != opt2[u].end(); it++) s2[it-&gt;id] += it-&gt;op; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs2(v, u); &#125; ans[u] = s1[W[u] + d[u] + N] - cnt1 + s2[W[u] - d[u] + N] - cnt2;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(1, 0); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;W[i]); for (register int i = 1; i &lt;= M; ++i) &#123; int S, T; scanf("%d%d", &amp;S, &amp;T); int lca = Lca(S, T); opt1[S].push_back((opt)&#123;d[S] + N, 1&#125;); opt1[f[lca][0]].push_back((opt)&#123;d[S] + N, -1&#125;); opt2[T].push_back((opt)&#123;d[S] - 2*d[lca] + N, 1&#125;); opt2[lca].push_back((opt)&#123;d[S] - 2*d[lca] + N, -1&#125;); &#125; dfs2(1, 0); for (register int i = 1; i &lt;= N; ++i) printf("%d ", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2633 Count on a tree(COT)]]></title>
    <url>%2F2019%2F05%2F20%2Fsolution-luogu-p2633%2F</url>
    <content type="text"><![CDATA[题目链接 给定一棵$n$个节点的树，每个节点上有一个权值。对于$m$次询问，需要输出$u$到$v$的最短路径上第$k$小的点权。 $1\le n\le 100000,1 \le m\le 100000$ 感谢@tth37 的贡献 这题不难呀，怎么调了这么久？ ——Mr. G 前置知识是主席树。在利用主席树求解区间第K小数时可以发现，主席树是一种类似前缀和的数据结构，具有和前缀和类似的区间加减及差分等优秀性质。在求解线性区间的第K小数时，我们需要将该区间内的所有数值信息扔到一棵主席树中，并在这棵主席树上左右递归，以找到第K小数；同样的，我们可以类比树上前缀和的操作，定义$s[u]$为从根节点到第$u$号节点的“前缀主席树”（感性理解谢谢）。那么，包含$u$到$v$上所有数值信息的主席树就应该是： s[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]理解上式后，问题基本可以解决了。另外注意离散化和主席树的代码细节。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;// 离散化操作#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN = 100005;struct Node &#123; int l, r, sum;&#125;node[10000005];int head[MAXN],cnt;vector&lt;int&gt; G[MAXN];int N, M, L, lastans;int a[MAXN], b[MAXN];int f[MAXN][19], dep[MAXN];inline void build(Node &amp;u, int l, int r) &#123; u.sum = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r);&#125;inline void insert(Node c, Node &amp;u, int l, int r, int p) &#123; u.sum = c.sum + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r; else insert(node[c.r], node[u.r = ++cnt], mid+1, r, p), u.l = c.l;&#125;inline void dfs(int u, int fa) &#123; insert(node[head[fa]], node[head[u] = ++cnt], 1, L, id(u)); f[u][0] = fa; dep[u] = dep[fa] + 1; for (register int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (register int i = 18; i &gt;= 0; --i) &#123; if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 18; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;inline int query(Node x, Node y, Node z, Node w, int l, int r, int k) &#123; if (l == r) return l; int sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum; int mid = (l + r) &gt;&gt; 1; if(sum &gt;= k) return query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k); return query(node[x.r], node[y.r], node[z.r], node[w.r], mid+1, r, k - sum);&#125;inline int querypath(int u, int v, int k) &#123; int lca = Lca(u, v); return rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][0]]], 1, L, k));&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;a[i]), b[i] = a[i]; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; sort(b + 1, b + N + 1); L = unique(b + 1, b + N + 1) - (b + 1); build(node[head[0] = ++cnt], 1, L); dfs(1, 0); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, k; scanf("%d%d%d", &amp;u, &amp;v, &amp;k); int nowans = querypath(u^lastans, v, k); printf("%d\n", nowans); lastans = nowans; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>树上前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-5-18]]></title>
    <url>%2F2019%2F05%2F18%2Fbulletin-2019-5-18%2F</url>
    <content type="text"><![CDATA[Hi~ 访问我网站的小崽子们~ 想在评论区发言的同时留下自己的个人头像吗？速戳这里！（Gravatar.com） 在这个网站注册用户，并在评论区留言时留下在Gravatar的账号邮箱，即可在评论区显示头像！ 可以在这里测试一下 由于网站是国家顶级域名（*.cn），所以缓存可能需要一周（或更长）的时间才能更新，请耐心等待！ 谢谢资瓷！]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1273有线电视网]]></title>
    <url>%2F2019%2F04%2F25%2Fsolution-luogu-p1273%2F</url>
    <content type="text"><![CDATA[题目链接 背包类树形dp。本题需要运用分组背包模型。 首先定义状态：$f[u][i]$表示以$u$为根的子树上，选择$i$个用户时的最大利润。由于电视公司可能亏本，因此$f$数组应赋极小初值。 可以将选择的用户个数看作背包的容量维度，将获得的利润看作背包的价值维度。可以设计出如下的状态转移： f[u][i]=\max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}其中，$v$为$u$的子节点，$w$为这条边的权值。在$u$每个子节点上有许多“物品”，“物品”总数即为以$v$为根的子树上用户的个数；每个“物品”所具有的价值即为其最大利润，即$f[v][j]$。同时不应忽略边权对利润带来的影响。 注意细节处理及边界。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-数论专题-素数的判定]]></title>
    <url>%2F2019%2F04%2F13%2Falgorithm-maths-primecheck%2F</url>
    <content type="text"><![CDATA[版权声明：本篇文章由特邀讲师胡家睿撰写，tth37只负责搬运、整理和发布；版权归胡家睿所有。 概述 素数定义：除1和本身以外没有其他因数的数 素数在信息学竞赛中有较多的应用，素数判定是解决复杂数论问题的基础。本篇文章介绍了一些素数判定的方法。 单个素数判定朴素判定： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;n;++i)&#123; if(n%i==0) return false;//除1、n以外还存在因数，所以n为合数； &#125; return true；//循环后没有判定为合数，则为素数。&#125; 时间复杂度：$\Theta (n)$ 优化： 1234567bool prime(int n)&#123; if(n==1) return false;//特判1（不为素数） for(int i=2;i&lt;=sqrt(n);++i)&#123; if(n%i==0) return false; &#125; return true；&#125; 时间复杂度：$\Theta(\sqrt{n})$ 证明： ​ 若一个数$n$为合数，则它一定拥有一个质因数$k$。可以知道，$n/k$（记为$s$）为$n$的因数，且$s$不等于$n$。$k$和$s$二者必定有一个数小于等于$\sqrt{n}$，否则$k*s$一定大于$n$。所以只要在$\sqrt{n}$以内循环一遍即可。 埃氏素数筛如果用上面的方法判定$1-n$以内所有素数，会发现时间复杂度非常高。那么这个时候就要用筛法了。大致意思是用素数来筛掉合数，然后用$f$数组储存是否是素数。 1234567f[1]=true;//特判还是很必要的for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue;//i为合数直接跳过 for(int j=i+i;j&lt;=n;j+=i)&#123; f[j]=true;//i为素数，i的倍数一定为合数 &#125;&#125; 优化： 1234567f[1]=true;for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue; for(int j=i*i;j&lt;=n;j+=i)&#123;//这里只变了乘号，但是会快很多喔 f[j]=true; &#125;&#125; 原因是：$i*i$以下的所有合数都已经被筛掉了。具体证法，可以接着看下去（在线性筛里有类似的思想，所以看完可以尝试一下自己证明）。 素数线性筛上一个筛法时间复杂度$\Theta(log log n)$非常接近线性。但是要达到线性还差一点（这里不是比赛要求掌握所以就当兴趣学吧） 上一个筛法的大概想法，是每一个素数的倍数都筛掉，所以是让每一个合数都被它的质因子筛一遍。 那么接下来的筛法，就是让每个合数的最小质因子筛一遍（要开一个prime数组存所有素数）。先放代码： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f[10005],prime[10005];int main()&#123; ll n,i,j,cnt=0; cin&gt;&gt;n; //这个地方不用特判1,因为我们判定是否为素数的方法是f[i]是否为0; for(i=2;i&lt;=n;++i) &#123; if(!f[i]) &#123; prime[++cnt]=i;//存入素数; f[i]=i; &#125; for(j=1;j&lt;=cnt;++j) &#123; if(prime[j]*i&gt;n||prime[j]&gt;f[i]) break;//判定出界或i的因子中有比当前素数更小的（即prime[j]*i已经被f[i]筛过了）; f[prime[j]*i]=prime[j];//标记所有未被标记的i的倍数； &#125; &#125; cin&gt;&gt;i; cout&lt;&lt;f[i]&lt;&lt;" "; return 0; &#125; 核心就在于神奇的判定方法，可以多咀嚼咀嚼 时间复杂度$\Theta(n)$搞定，还可以找到$1-n$内所有合数的最小质因数。]]></content>
      <categories>
        <category>算法学习</category>
        <category>数论专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4559列队]]></title>
    <url>%2F2019%2F04%2F10%2Fsolution-luogu-p4559%2F</url>
    <content type="text"><![CDATA[题目链接 给定数轴上$n$个点，给出$m$条独立的指令，将编号为$[l,r]$ 的点集中到$[k,k+r-l]$的位置且这些点个点位置不能重合，求每次命令中移动的点的距离和的最小值（$n,m≤5×10^5, 1≤a_i,K≤10^6$） 感谢@oy的贡献 本题是主席树的一个简单应用。 阅读题目，不难得出贪心策略。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。（不会证） 对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。 为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下） 接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案： $r\le ql$ 此时处于当前值域内的所有学生都要往右跑 $qr\le l$ 此时处于当前值域内的所有学生都要往左跑 当前值域内没有学生 返回 $0$ 否则，必须将值域拆分，递归到左右子节点进行统计。 本题最绕的地方在于学生编号和学生位置是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int L=1000005;int N,M;struct Node&#123; int l,r; ll gl,gr,sum;&#125;node[L*22+5];int head[MAXN];int cnt;inline void build(Node&amp; u,int l,int r)&#123; u.sum=u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1;u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l; u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+1); u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);&#125;inline ll query(Node x,Node y,int l,int r,ll ql,ll qr)&#123; ll sum=y.sum-x.sum; ll gl=y.gl-x.gl,gr=y.gr-x.gr; if(sum==0) return 0; if(qr&lt;=l) return gl+(2*l-ql-qr)*(qr-ql+1)/2; if(ql&gt;=r) return gr+(ql+qr-2*r)*(qr-ql+1)/2; int mid=(l+r)&gt;&gt;1; ll lsum=node[y.l].sum-node[x.l].sum; return query(node[x.l],node[y.l],l,mid,ql,ql+lsum-1)+ query(node[x.r],node[y.r],mid+1,r,ql+lsum,qr);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); build(node[0],1,L); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); insert(node[head[i-1]],node[head[i]=++cnt],1,L,a); &#125; for(register int i=1;i&lt;=M;++i)&#123; ll l,r,k; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); printf("%lld\n",query(node[head[l-1]],node[head[r]],1,L,k,k+r-l)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p5283异或粽子]]></title>
    <url>%2F2019%2F04%2F09%2Fsolution-luogu-p5283%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个长度为$n$的数组$a$，取$k$个各不相同的连续区间$[l,r]$ 使得这些区间所有元素的异或和的和最大，求这个最大值（$ 1 \le n \le 5 \times 10^5,1\le k \le min(\frac{n(n-1)}{2},2\times 10^5),0\le a_i \le 4294967295$） 感谢@oy的贡献 分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。 用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus … \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r] \oplus s[l-1]$。 将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。 将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。 在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。 注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。 另外，在将(1&lt;&lt;d)这样的式子转long long时，不能写成(long long)(1&lt;&lt;d)，而是((long long)1&lt;&lt;d)。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int DEP=31;int N,M;ll ans,s[MAXN];struct State&#123; ll val; int r,k; bool operator &lt;(const State&amp; rhs) const &#123;return val&lt;rhs.val;&#125;&#125;;priority_queue&lt;State&gt; q;struct Node&#123; int son[2],sum;&#125;trie[MAXN*(DEP+2)];int head[MAXN],cnt;inline void insert(Node c,Node&amp; u,ll val,int d)&#123; u.sum=c.sum+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; u.son[!x]=c.son[!x]; insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d-1);&#125;inline ll query(Node u,ll val,int d,int k)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; int lsum=trie[u.son[!x]].sum; if(lsum&gt;=k) return ((ll)1&lt;&lt;d)+(ll)query(trie[u.son[!x]],val,d-1,k); return (ll)query(trie[u.son[x]],val,d-1,k-lsum);&#125;int main()&#123; trie[0].son[0]=trie[0].son[1]=trie[0].sum=0; insert(trie[0],trie[head[0]=++cnt],0,DEP); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; ll a; scanf("%lld",&amp;a); s[i]=s[i-1]^a; insert(trie[head[i-1]],trie[head[i]=++cnt],s[i],DEP); q.push((State)&#123;query(trie[head[i-1]],s[i],DEP,1),i,1&#125;); &#125; for(register int i=1;i&lt;=M;++i)&#123; ans+=q.top().val; int r=q.top().r,k=q.top().k; q.pop(); if(k==r) continue; q.push((State)&#123;query(trie[head[r-1]],s[r],DEP,k+1),r,k+1&#125;); &#125; printf("%lld",ans); return 0;&#125; $p.s.$洛谷评测机有点小慢，不开O2会小概率发生TLE QwQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>可持久化trie</tag>
        <tag>异或</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-04-08]]></title>
    <url>%2F2019%2F04%2F08%2Fbulletin-2019-4-8%2F</url>
    <content type="text"><![CDATA[tth37 Blog已经绑定了最新域名：tth37.cn ！(购买自阿里云) 由于一些奇怪的原因（DNS域名解析和CNAME配置问题），我的博客在四月七日至四月八日出现许多异常，现已全部修复。 但在四月九日至四月十日的测试中，我被疯狂打脸；现在已经可以保证，只要在浏览器输入栏输入 tth37.cn，即可自动跳转https://tth37.cn，并在*CloudFlare*证书授权下安全运行。 请大佬们在新域名下体验高速加载和流畅访问新体验吧！ 另外，左侧边栏“日程表”已经启用；网站基本搭建完毕。以后将缩减网站维护时间。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习-可持久化数据结构]]></title>
    <url>%2F2019%2F03%2F29%2Falgorithm-persistentdatastructure%2F</url>
    <content type="text"><![CDATA[概述可持久化数据结构可以存储数据集在任意时间的历史状态。“可持久化”的基本思想是在每项操作结束后，仅创建数据结构中发生改变的部分的副本，不拷贝其他部分。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，可持久化数据结构能够高效地记录一个数据结构的所有历史状态。 可持久化Trie【实现过程】 设当前可持久化Trie的根节点为root，令p=root，i=0 建立一个新的节点，令root‘=q 若p!=0，则对于每种字符c，令trie[q,c]=trie[p,c] 建立一个新的节点q’，令trie[q,s]=q‘ 令p=trie[p,s]，q=trie[q,s]，i=i+1 重复步骤3-5，直到i到达字符串末尾 【例题】最大异或和 luogu-p4735给定一个非负整数序列{a}，初始长度为N。 有M个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。 Q l r x：询问操作，你需要找到一个位置p，满足l≤p≤r，使得： a[p]⊕a[p+1]⊕…⊕a[N]⊕x 最大，输出最大是多少。 【分析】考虑异或前缀和。根据异或运算的性质： a[p]\oplus a[p+1]\oplus ...\oplus a[N]\oplus x=s[p-1]\oplus s[N]\oplus x对于添加操作，序列s很容易维护。对于询问操作，问题变为：已知一个整数val=s[N] xor x，求一个位置p，满足l-1&lt;=p&lt;=r-1，使得s[p] xor val最大。显然可以将s数组插入可持久化Trie中，每次取出在l与r范围内的数据进行贪心（尽量往相反的节点走），从而求出答案。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC optimize(3)//QwQ#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=600005;const int DEP=24;int N,M;int trie[MAXN*26][2],sum[MAXN*26];int head[MAXN],cnt=1;int s[MAXN];inline void insert(int c,int u,int val,int d)&#123; sum[u]=sum[c]+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; trie[u][!x]=trie[c][!x]; insert(trie[c][x],trie[u][x]=++cnt,val,d-1);&#125;inline int query(int c,int u,int val,int d)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; if(sum[trie[u][!x]]&gt;sum[trie[c][!x]]) return (1&lt;&lt;d)+query(trie[c][!x],trie[u][!x],val,d-1); else return query(trie[c][x],trie[u][x],val,d-1);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); insert(0,0,0,DEP); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); s[i]=s[i-1]^a; insert(head[i-1],head[i]=++cnt,s[i],DEP); &#125; for(register int i=1;i&lt;=M;++i)&#123; char opt; getchar(),opt=getchar(); if(opt=='A')&#123; int a; scanf("%d",&amp;a); N++; s[N]=s[N-1]^a; insert(head[N-1],head[N]=++cnt,s[N],DEP); &#125; else&#123; int l,r,a; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); if(l==r) printf("%d\n",s[l-1]^s[N]^a); else printf("%d\n",query(head[l-2],head[r-1],a^s[N],DEP)); &#125; &#125; return 0;&#125; 可持久化数组【例题】【模板】可持久化数组 luogu-p3919如题，你需要维护这样的一个长度为 N 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 【分析】在原数组上建立线段树，在叶子节点上记录原数组数值。执行完修改操作后，根据可持久化的思想，只需更改一条链上的节点信息；执行完访问操作后，则可以将目前操作的根节点指针指向被查询的历史状态根节点。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;struct Node&#123; int l,r,val;&#125;node[MAXN*22+5];int N,M,cnt;int a[MAXN],head[MAXN];inline void build(Node&amp; u,int l,int r)&#123; if(l==r)&#123; u.val=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void change(Node c,Node&amp; u,int l,int r,int p,int val)&#123; if(l==r)&#123; u.val=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)&#123; change(node[c.l],node[u.l=++cnt],l,mid,p,val); u.r=c.r; &#125; else&#123; change(node[c.r],node[u.r=++cnt],mid+1,r,p,val); u.l=c.l; &#125;&#125;inline int query(Node u,int l,int r,int p)&#123; if(l==r) return u.val; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) return query(node[u.l],l,mid,p); else return query(node[u.r],mid+1,r,p);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) scanf("%d",&amp;a[i]); build(node[0],1,N); for(register int i=1;i&lt;=M;++i)&#123; int v,opt,p,val; scanf("%d%d",&amp;v,&amp;opt); if(opt==1)&#123; scanf("%d%d",&amp;p,&amp;val); change(node[head[v]],node[head[i]=++cnt],1,N,p,val); &#125; else&#123; scanf("%d",&amp;p); head[i]=head[v]; printf("%d\n",query(node[head[i]],1,N,p)); &#125; &#125; return 0;&#125; 可持久化值域线段树（主席树）【例题】【模板】可持久化线段树 luogu-p3834给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。 【分析】值域有负数出现，考虑离散化。假设离散化后的值域为[1,L]。 在值域上建立线段树，每个节点上存储该值域内有多少个数据。对线段树进行可持久化处理，与上一题可持久化数组实现方式类似。 在查询时，如果一个节点的左子节点上的cnt值小于等于正在查询的K，则问题转化为求左半区间内第K小值；否则，转化为求右半区间内第K-cnt小值。 查询时的操作类似于在值域上的二分，因此复杂度在log级别。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN=200005;struct Node&#123; int l,r,sum;&#125;node[MAXN&lt;&lt;6];int N,M,L,cnt;int a[MAXN],b[MAXN];int head[MAXN];inline void build(Node u,int l,int r)&#123; u.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],1,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l;&#125;inline int query(Node c,Node u,int l,int r,int k)&#123; if(l==r) return l; int sum=node[u.l].sum-node[c.l].sum,mid=(l+r)&gt;&gt;1; if(sum&gt;=k) return query(node[c.l],node[u.l],1,mid,k); else return query(node[c.r],node[u.r],mid+1,r,k-sum);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+N+1); L=unique(b+1,b+N+1)-(b+1); head[0]=0; build(node[0],1,L); for(register int i=1;i&lt;=N;++i) insert(node[head[i-1]],node[head[i]=++cnt],1,L,id(i)); for(register int i=1;i&lt;=M;++i)&#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",rid(query(node[head[l-1]],node[head[r]],1,L,k))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化trie</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p4516潜入行动]]></title>
    <url>%2F2019%2F03%2F28%2Fsolution-luogu-p4516%2F</url>
    <content type="text"><![CDATA[这是一个并不简单的背包类树形dp…… 很自然地想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。 状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是： f[u][i+j]=combine(f[u][i],f[v][j])相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为： f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1] f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1]) f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1] f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100005;const int mod=1000000007;int N,K;int f[MAXN][105][2][2];int g[105][2][2];int size[MAXN];vector&lt;int&gt; G[MAXN];inline int Mod(ll x,ll y)&#123; x%=mod,y%=mod; return (int)(x+y)%mod;&#125;void dp(int u,int fa)&#123; size[u]=1; f[u][0][0][0]=f[u][1][1][0]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(v,u); for(register int i=0;i&lt;=min(size[u],K);++i)&#123; g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0; g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0; g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0; g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0; &#125; for(register int i=0;i&lt;=min(size[u],K);++i)&#123; for(register int j=0;j&lt;=min(size[v],K-i);++j)&#123; f[u][i+j][0][0]=Mod((ll)f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]); f[u][i+j][0][1]=Mod((ll)f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*((ll)f[v][j][1][1]+(ll)f[v][j][0][1])); f[u][i+j][1][0]=Mod((ll)f[u][i+j][1][0],(ll)g[i][1][0]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1])); f[u][i+j][1][1]=Mod((ll)f[u][i+j][1][1],(ll)g[i][1][0]*((ll)f[v][j][1][0]+(ll)f[v][j][1][1])+(ll)g[i][1][1]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]+(ll)f[v][j][1][0]+(ll)f[v][j][1][1])); &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1,0); printf("%d",(int)(f[1][K][0][1]+f[1][K][1][1])%mod); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习-背包类树形dp]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-knapsacktreedp%2F</url>
    <content type="text"><![CDATA[树形分组背包【例题】 选课 luogu-p2014 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 【分析】记录状态：$f[u][i]$为以$u$为根的子树上，选择$i$门课所能获得的最大学分。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。那么在$u$上相当于有一个容量为$M$的背包，每个子树中不同的状态相当于不同的物品，例如$f[v][j]$为体积为$j$，价值为$f[v][j]$中存储的数值。 在本题中，由于所有关系构成森林结构，因此可以设$0$号结点为“没有先修课”的课的先修课。然后以$0$为根，进行状态转移即可。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define Pb push_backconst int MAXN=305;const int MAXM=305;int N,M;vector&lt;int&gt; son[MAXN];int a[MAXN],f[MAXN][MAXM];inline void dp(int u)&#123; for(vector&lt;int&gt;::iterator it=son[u].begin();it!=son[u].end();it++) &#123; int v=*it; dp(v); for(register int i=M;i&gt;=0;--i) for(register int j=0;j&lt;=i;++j) f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]); &#125; if(u) &#123; for(register int i=M;i&gt;=1;--i) f[u][i]=f[u][i-1]+a[u]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) &#123; int k,s; scanf("%d%d",&amp;k,&amp;s); son[k].Pb(i);a[i]=s; &#125; dp(0); printf("%d",f[0][M]); return 0;&#125; 【例题】有线电视网 luogu-p1273某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 【分析】记录状态：$f[i][j]$为以$i$为根，选择$j$个用户最多有多少收入。状态转移时如果无法从正面入手（如本题不知道价格的最值，且价值分布更为稀疏），可以从反面设计状态，在输出答案时进行判断即可。转移时可以记录$size$数组进行优化。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125; 组合计数类树形背包【例题】树的独立集 （原创）给定一棵有$N$个结点的树，输出这棵树中包含$K$个结点的独立集个数。 【分析】有关组合计数的背包类树形dp问题，一般均可用以下方式解决。 记录状态：$f[u][k][0/1]$ 为以$u$为根的子树，$u$的状态为选或不选，共选择$k$个结点时独立集的个数。 记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。每递归访问结束一个子结点，就考虑把该子结点的状态与已经处理一部分的当前结点状态相匹配。每访问完一个结点，就把配对后产生的状态归为已处理的状态。由于需要根据之前的状态推导后续状态，因此不难看出利用到背包的思想。 状态转移方程的基本思想如下： f[u][i+j][(state)]=combine(f[u][i][(state)]*f[u][j][(state)])本题的状态转移方程也不难推出： f[u][0][i+j]=\sum f[u][0][i]*(f[v][0][j]+f[v][1][j]) f[u][1][i+j]=\sum f[u][1][i]*f[v][0][j]【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10005;int N,K;vector&lt;int&gt; G[MAXN];int f[MAXN][105][2];int g[105][2];int size[MAXN];void dp(int fa,int u)&#123; size[u]=1; f[u][0][0]=1,f[u][1][1]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(u,v); for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; g[i][0]=f[u][i][0],f[u][i][0]=0; g[i][1]=f[u][i][1],f[u][i][1]=0; &#125; for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; for(register int j=0;j&lt;=min(K-i,size[v]);++j)&#123; f[u][i+j][0]+=g[i][0]*(f[v][j][0]+f[v][j][1]); f[u][i+j][1]+=g[i][1]*f[v][j][0]; &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(0,1); printf("%d",f[1][K][0]+f[1][K][1]); return 0;&#125; 习题潜入行动 未完待续~]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p2774方格取数问题]]></title>
    <url>%2F2019%2F03%2F24%2Fsolution-luogu-p2774%2F</url>
    <content type="text"><![CDATA[题目链接 不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。 首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。 源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。 如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。 问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAXN=100005;int N,M,S,T;ll sum;int nx[]=&#123;0,1,0,-1&#125;;int ny[]=&#123;1,0,-1,0&#125;;struct Edge&#123; int v,w,nxt;&#125;mem[MAXN];int head[MAXN],cnt=1;inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].w=w; mem[cnt].v=v; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int d[MAXN];bool vis[MAXN];inline bool bfs()&#123; memset(vis,0,sizeof(vis)); vis[S]=1;d[S]=0; queue&lt;int&gt; q; q.push(S); while(q.size())&#123; int u=q.front();q.pop(); for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(vis[v]||(w==0)) continue; vis[v]=1;d[v]=d[u]+1; q.push(v); &#125; &#125; return vis[T];&#125;inline int dfs(int u,int flow)&#123; if(u==T) return flow; int rflow; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(w==0||d[u]+1!=d[v]) continue; if(rflow=dfs(v,min(flow,w)))&#123; mem[i].w-=rflow; mem[i^1].w+=rflow; return rflow; &#125; &#125; return 0;&#125;inline int Dinic()&#123; int maxflow=0,lowflow; while(bfs())&#123; while(lowflow=dfs(S,INF)) maxflow+=lowflow; &#125; return maxflow;&#125;int main()&#123; scanf("%d%d",&amp;M,&amp;N); S=0,T=M*N+1; for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125; printf("%lld",sum-Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目列表-网络流]]></title>
    <url>%2F2019%2F03%2F24%2Flist-networkflow%2F</url>
    <content type="text"><![CDATA[方格取数问题（二分图+建模技巧）将原图黑白染色，并保证产生矛盾的两个位置颜色不同。源点连接黑点，白点连接汇点，黑点连接与之产生矛盾的白点。通过 最大和=全局和-最小割，在建立的网络上跑最小割（最大流）即可。 123456789101112131415161718192021for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125;]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[公告 2019-03-24]]></title>
    <url>%2F2019%2F03%2F24%2Fbulletin-2019-3-24%2F</url>
    <content type="text"><![CDATA[2019/3/24，tth37搭建了这个github博客。 tth37希望在这个博客里记录一些自己学习OI的心得，并发布一些题解，贴出学习规划。 但tth37实在是太弱了，因此他会更新得十分缓慢。 另外，还请shiwt巨佬多多指教。 任何一个伟大的思想，都有一个微不足道的开始。 p.s. 可能会将洛谷博客上的文章搬运过来，所以有些文章的发布时间可能在此之前，请别见怪。]]></content>
      <categories>
        <category>公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题目列表-动态规划]]></title>
    <url>%2F2019%2F03%2F20%2Flist-dp%2F</url>
    <content type="text"><![CDATA[任务安排（斜率优化+费用提前计算） f[i]=min_{0\le j]]></content>
      <categories>
        <category>题目列表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1080国王游戏]]></title>
    <url>%2F2019%2F01%2F26%2Fsolution-luogu-p1080%2F</url>
    <content type="text"><![CDATA[题目链接 高精度怎能少了Python3题解。。。 贪心策略一楼dalao已经讲得很清楚了，上一发超短代码（学Python就是为了水高精） 123456789101112131415N=int(input())s=input().split()S=int(s[0])T=int(s[1])a=[]for i in range(1,N+1): k=input().split() a.append((int(k[0]),int(k[1])))a.sort(key=lambda x:x[0]*x[1])ans=0for i in range(0,N): if(S//(a[i])[1]&gt;ans): ans=S//(a[i])[1] S*=(a[i])[0]print(ans)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1022计算器的改良]]></title>
    <url>%2F2018%2F12%2F19%2Fsolution-luogu-p1022%2F</url>
    <content type="text"><![CDATA[题目链接 本题是一道非常漂亮的模拟。只要能理清思路，代码并不会特别复杂。 首先分析题目。解一元一次方程最简单的方法就是移项，把常数移到等号右侧，把一次项系数移到等号左侧，用常数除以系数即为答案。那么在读入字符串的过程中，便可以进行操作。 对于字符串中的数据，我们可以用类似快读的方法读入。然而，要判断这些数据从哪里来，到哪里去，便是本题的关键所在。 对于每个数据，要想清楚地辨别它的身份，我们只需解决三个问题： 1.该数据是正数还是负数？ 3.该数据在等号左侧还是在等号右侧？ 2.该数据是常数还是系数？ 第一个问题看似十分无脑，用一个变量f1来存储符号即可（将f1赋值为1或-1，在读入数据结束时将得到的数据乘以f1）。但需特别注意，在一个表达式的开头（等号左侧和等号右侧的表达式）不会有‘+’、‘-’符号，所以在程序的开头和读入‘=’号是，要将f1赋值为1。 第二个问题也非常简单，可以用变量f2来存储。因为这个问题与移项运算的符号有关，因此也可以将f2赋值为1或-1，并约定在等号左侧时f2为1，在等号右侧时f2为-1。（当然你也可以反着约定） 第三个问题同样不难解决。在读入数据结束后（即读入了一个符号），判断这个符号是运算符还是字母即可。如果是字母，则将得到的数据移到等号右侧，否则将数据移到等号左侧。但是还有一个注意点：如果一个未知数的系数为1，我们会将系数省略。因此在读入数据为0时，我们要将其更改为1。 经过分析，你会发现本题一点也不难实现。其关键在于对数据状态的准确描述。用清晰、简洁的变量描述状态，根据不同的状态采取不同的措施，这便是编程学习的一大基本素养。 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int l,r;//l代表系数，r代表常数 char x; //用x存储字母 void solve()&#123; char c; int f1=1,f2=1,tmp=0; while(~scanf("%c",&amp;c)) &#123; if(c&gt;='0'&amp;&amp;c&lt;='9')//类似快读的读入方式 &#123; tmp*=10; tmp+=c-'0'; &#125; else &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') l+=(tmp==0)?f2*f1:tmp*f2*f1,x=c;//判断系数是否为1 else r+=tmp*(-f2)*f1; tmp=0; &#125; if(c=='+') &#123;f1=1;continue;&#125; if(c=='-') &#123;f1=-1;continue;&#125; if(c=='=') &#123;f2=-1;f1=1;continue;&#125; &#125;&#125;int main()&#123; solve(); printf("%c=%0.3f",x,(float)r/l==0?abs((float)r/l):(float)r/l); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-luogu-p1204挤牛奶]]></title>
    <url>%2F2018%2F12%2F15%2Fsolution-luogu-p1204%2F</url>
    <content type="text"><![CDATA[题目链接 介绍一种本题的贪心解法。 本题要求读入一些挤牛奶的时间段，求最长至少有一人在挤牛奶的时间段和最长没有人在挤牛奶的时间段。把读入的区间视作线段，则题意转变为求至少有一条线段覆盖的最大区间和没有线段覆盖的区间。 假设读入数据如下： 首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。 然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。 程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。 程序如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int N; struct node&#123; int begin,end;&#125;m[5005];bool cmp(node a,node b)&#123; return a.begin&lt;b.begin;&#125;int main()&#123; scanf("%d",&amp;N); for(register int i=1;i&lt;=N;++i) scanf("%d%d",&amp;m[i].begin,&amp;m[i].end); sort(m+1,m+1+N,cmp); int begin=m[1].begin; int end=m[1].end; int ans1=0,ans2=0; for(register int i=2;i&lt;=N;++i)&#123; if(m[i].begin&lt;=end) end=max(end,m[i].end); else&#123; ans1=max(ans1,end-begin); ans2=max(ans2,m[i].begin-end); begin=m[i].begin; end=m[i].end; &#125; &#125; ans1=max(ans1,end-begin); printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
