<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tth37&#39;s Blog</title>
  
  <subtitle>Think twice, code once.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tth37.cn/"/>
  <updated>2019-10-02T16:05:16.141Z</updated>
  <id>https://tth37.cn/</id>
  
  <author>
    <name>tth37</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解-LibreOJ-2071最佳团体</title>
    <link href="https://tth37.cn/2019/10/02/solution-loj-2071/"/>
    <id>https://tth37.cn/2019/10/02/solution-loj-2071/</id>
    <published>2019-10-02T15:46:00.000Z</published>
    <updated>2019-10-02T16:05:16.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P4322" target="_blank" rel="noopener">题目链接(Luogu)</a></p><p><a href="https://loj.ac/problem/2071" target="_blank" rel="noopener">题目链接(LibreOJ)</a></p><p>题目概括<strong>重金</strong>征集中~</p></blockquote><a id="more"></a><p>0/1 分数规划的基本模型：给定整数 $a_1,a_2,…,a_n$ 以及 $b_1,b_2,…,b_n$，求一组解 $x_i$（$x_i$ 的取值为 0 或 1），使下式最大化：</p><script type="math/tex; mode=display">\frac{\Sigma a_i*x_i}{\Sigma b_i*x_i}</script><p>在本题中，${a_n}$ 对应着战斗值， ${b_n}$ 对应着招募费用。题目要求从中选出若干名选手（即将相应的 $x_i$ 赋为 1），使得上式最大化。</p><p>值得注意的是，在本题中 $x_i$ 的取值同样有限制：如果 $x_i=1$，则一定有 $x_R[i]=1$ 或$R[i]=0$。</p><p>接下来考虑上式的计算。我么们不妨任意猜测一个值 $mid$ ，如果 $\frac{\Sigma a_i<em>x_i}{\Sigma b_i</em>x_i} \ge mid$ ，即 $mid$ 比我们要求的最大值要小，则可以推出 $\Sigma (a_i-mid<em>b_i)</em>x_i\ge 0$。因此，我们只需判定 $\Sigma (a_i-mid<em>b_i)</em>x_i$ 是否大于等于 0，即可进一步缩小 $mid$ 的范围。</p><p>综上所述，我们可以二分答案（实数）。当二分的值为 $mid$ 时，计算 $\Sigma (a_i-mid<em>b_i)</em>x_i$ 的最大值，检查最大值是否非负。若非负，则令 $l=mid$；否则令 $r=mid$。当二分停止时，就得到了 0/1 分数规划问题的解。</p><p>本题的另一关键点在于计算 $\Sigma (a_i-mid<em>b_i)</em>x_i$ 的最大值。本题可以采用背包类树形 DP 实现，具体内容不再赘述。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125;edge[<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, head[<span class="number">2505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].v = v;</span><br><span class="line">    edge[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K, N;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2505</span>], b[<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">float</span> f[<span class="number">2505</span>][<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">int</span> size[<span class="number">2505</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> delta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        dfs(edge[i].v);</span><br><span class="line">        size[u] += size[edge[i].v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> w = <span class="number">1.0</span> * a[u] - <span class="number">1.0</span> * delta * b[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i)</span><br><span class="line">        f[u][i] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        dp(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(K, size[u]); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(size[v], i); ++j)</span><br><span class="line">                f[u][i] = max(f[u][i], f[u][i - j] + f[v][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(K, size[u]); i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            f[u][i] = f[u][i - <span class="number">1</span>] + w;</span><br><span class="line">        f[u][<span class="number">1</span>] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;K, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;b[i], &amp;a[i], &amp;r);</span><br><span class="line">        AddEdge(r, i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span> l = <span class="number">0</span>, r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        <span class="keyword">float</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        delta = mid;</span><br><span class="line">        dp(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">0</span>][K] &lt; <span class="number">0</span>) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3f"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P4322&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接(Luogu)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/2071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接(LibreOJ)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目概括&lt;strong&gt;重金&lt;/strong&gt;征集中~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="0/1分数规划" scheme="https://tth37.cn/tags/0-1%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
      <category term="二分答案" scheme="https://tth37.cn/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>解题报告-NOIP2017提高组初赛</title>
    <link href="https://tth37.cn/2019/09/29/solution-noip2017pre/"/>
    <id>https://tth37.cn/2019/09/29/solution-noip2017pre/</id>
    <published>2019-09-29T15:23:06.000Z</published>
    <updated>2019-09-29T16:02:42.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>未完待续……</p></blockquote><a id="more"></a><p><strong>第 1 题</strong></p><p>从（ ）年开始，NOIP 竞赛将不再支持 Pascal 语言。</p><p> A. 2020 B. 2021 C. 2022 D. 2023</p><blockquote><p>送命题。</p></blockquote><p><strong>第 2 题</strong></p><p>在 8 位二进制补码中，10101011 表示的数是十进制下的（ ）。</p><p> A. 43 B. -85 C. -43 D. -84</p><blockquote><div class="table-container"><table><thead><tr><th></th><th>原码</th><th>补码</th><th>反码</th></tr></thead><tbody><tr><td>正数</td><td>符号(0)+数值表示法</td><td>原码</td><td>原码</td></tr><tr><td>负数</td><td>符号(1)+数值表示法</td><td>符号位之外各位取反</td><td>符号位之外各位取反，最低位加1</td></tr></tbody></table></div><script type="math/tex; mode=display">[x]_{补}=10101011</script><script type="math/tex; mode=display">[x]_{反}=10101010</script><script type="math/tex; mode=display">[x]_{原}=11010101</script><script type="math/tex; mode=display">x=-85</script></blockquote><p><strong>第 3 题</strong></p><p>分辨率为 1600x900、16 位色的位图，存储图像信息所需的空间为（ ）。 </p><p>A. 2812.5KB B. 4218.75KB C. 4320KB D. 2880KB</p><blockquote><script type="math/tex; mode=display">8 \ bit= 1\ byte(B)\\1024\ B=1\  KB\\1024\ KB=1\ MB\\1024\ MB=1\ GB</script></blockquote><p><strong>第 4 题</strong></p><p>2017 年 10 月 1 日是星期日，1949 年 10 月 1 日是（ ）。 </p><p>A. 星期三 B. 星期日 C. 星期六 D. 星期二</p><blockquote><p>2017-&gt;2016：星期日-&gt;星期六</p><p>2016-&gt;2015：星期六-&gt;星期四</p><p>2015-&gt;2014：星期四-&gt;星期三</p><p>……</p><p>1950-&gt;1949：星期日-&gt;星期六</p></blockquote><p><strong>第 5 题</strong></p><p>设 G 是有 n 个结点、m 条边（n ≤ m）的连通图，必须删去 G 的（ ）条边， 才能使得 G 变成一棵树。 </p><p>A. m – n + 1 B. m - n C. m + n + 1 D. n – m + 1</p><blockquote><p>树有 n - 1 条边</p></blockquote><p><strong>第 6 题</strong></p><p>若某算法的计算时间表示为递推关系式：<br>T(N) = 2T(N / 2) + N log N<br>T(1) = 1<br>则该算法的时间复杂度为（ ）。 </p><p>A. O(N) B. O(NlogN) C. O(Nlog^2N) D. O(N^2)</p><blockquote><p>$T$ 共有 $\log N$ 次递归调用，每次复杂度为 $O(N\log N)$</p></blockquote><p><strong>第 7 题</strong></p><p>表达式 a * (b + c) * d 的后缀形式是（ ）。 </p><p>A. a b c d * + * B. a b c + * d * C. a * b c + * d D. b + c * a * d</p><blockquote><p>普通表达式为中序遍历，后缀表达式为可能的后序遍历</p></blockquote><p><strong><font color="#dd0000">第 8 题 </font></strong></p><p>由四个不同的点构成的简单无向连通图的个数是（ ）。 </p><p>A. 32 B. 35 C. 38 D. 41</p><blockquote><p>由四个点构成的简单无向连通图，它们之间只可能有 6 条不同的边。将四个点按序排列，这 6 条边可分为纵横向及斜向两种边。</p><ol><li><p>纵横边有 1 条</p><p>该情况下，无向图有 4 种摆放位置。要使得图连通，斜向边只有 1 种摆法。</p><p>ans += 4 * 1</p></li><li><p>纵横边有 2 条</p><ul><li><p>两纵/两横</p><p>ans += 2 * 3</p></li><li><p>一纵一横</p><p>ans += 4 * 2</p></li></ul></li><li><p>纵横边有 3 条</p><p>ans += 4 * 4</p></li><li><p>纵横边有 4 条</p><p>ans += 1 * 4</p></li></ol></blockquote><p><strong><font color="#dd0000">第 9 题</font></strong></p><p>将 7 个名额分给 4 个不同的班级，允许有的班级没有名额，有（ ）种不 同的分配方案。 </p><p>A. 60 B. 84 C. 96 D. 120</p><blockquote><p>可重组合。不会</p></blockquote><p><strong><font color="#dd0000">第 10 题</font></strong></p><p>若 f[0] = 0, f[1] = 1, f[n + 1] = (f[n] + f[n - 1]) / 2，则随着 i 的增大，f[i]将接近于( )。 </p><p>A. 1/2 B. 2/3 C. (√5 − 1)/2 D. 1</p><blockquote><p>不会</p></blockquote><p><strong>第 11 题</strong></p><p>设 A 和 B 是两个长为 n 的有序数组，现在需要将 A 和 B 合并成一个排好序的 数组，请问任何以元素比较作为基本运算的归并算法最坏情况下至少要做 （ ）次比较。 </p><p>A. n^2 B. nlogn C. 2n D. 2n-1</p><blockquote><p>构造 A、B 分别为 [1,3,5,7…] [2,4,6,8,…] 此时需要 2n-1 次比较</p></blockquote><p><strong>第 12 题</strong></p><p>在 n（n ≥ 3）枚硬币中有一枚质量不合格的硬币（质量过轻或质量过重）,如果只有一架天平可以用来称重且称重的硬币数没有限制，下面是找出这枚不合格的硬币的算法。请把 a-c 三行代码补全到算法中。<br>a. A ← X ∪ Y<br>b. A ← Z<br>c. n ← |A| 算法 Coin(A, n)1. k ← ⌊n/3⌋   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">k ← ⌊n/3⌋</span><br><span class="line">将 A 中硬币分成 X，Y，Z 三个集合，使得|X| = |Y| = k,|Z| = n - 2k</span><br><span class="line">if W(X) ≠ W(Y)       //W(X), W(Y)分别为 X 或 Y 的重量</span><br><span class="line">then _____</span><br><span class="line">else _____</span><br><span class="line">_____</span><br><span class="line">if n&gt;2 then goto 1</span><br><span class="line">if n=2 then 任取 A 中1枚硬币与拿走硬币比较，若不等，则它不合格； 若相等，则 A 中剩下的硬币不合格</span><br><span class="line">if n=1 then A 中硬币不合格</span><br></pre></td></tr></table></figure><p>正确的填空顺序是（ ）。 </p><p>A. b, c, a B. c, b, a C. c, a, b D. a, b, c</p><blockquote><p>还没做~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;未完待续……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="解题报告" scheme="https://tth37.cn/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>题解-LibreOJ-6032水箱</title>
    <link href="https://tth37.cn/2019/09/28/solution-loj-6032/"/>
    <id>https://tth37.cn/2019/09/28/solution-loj-6032/</id>
    <published>2019-09-27T16:04:49.000Z</published>
    <updated>2019-09-27T16:26:34.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://loj.ac/problem/6032" target="_blank" rel="noopener">题目链接</a></p><p>题目概括<strong>重金</strong>征集中~</p></blockquote><a id="more"></a><p>比较毒瘤的一道题。</p><p>注意到每个条件只有“有水”限制和“没水”限制。问题在于如何统计最多能满足多少条件。假定所有的“没水”条件都能满足，在 DP 中如果在“没水”限制的格子中填入了水，则对答案的贡献减一；如果在“有水”限制的格子中填入了水，则对答案的贡献加一。</p><p>根据以上方法，可以定义状态：$f[i][j]$ 表示在从左往右第 $i$ 个格子中，高度为 $j$ 的地方<strong>有水</strong>时对答案产生的最大贡献。注意：此时假定第 $i$ 个格子的右侧挡板为无限高。</p><p>显然，如果 $j$ 小于等于其左侧挡板的高度，上一格的水的高度可以为 $1-h[i]$ 的任意值；如果 $j$ 大于其左侧挡板的高度，那么上一格的水的高度必须同样为 $j$。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]=\begin{cases}\sum_{k=1}^{j} w[i][k]+\max_{k=1}^{h[i]}\lbrace f[i-1][k]\rbrace,\ j\le h[i]\\\sum_{k-1}^{j} w[i][k]+f[i-1][j],\ j>h[i]\end{cases}</script><p>不难发现可以使用滚动数组优化空间；并且注意到，每个新的 $f[i][j]$ 要么是被修改成某个值，要么是在原来的基础上加上了某些东西。</p><p>在本题中，每个格子中限制条件的分布是相对<strong>稀疏</strong>的。那么，在同一格子的不同高度处，只要其对答案的贡献前缀和相等，则可以作为区间进行快速处理。</p><p>具体来说，可以使用<strong>线段树</strong>维护 $f[1]-f[L]$，并在其中用滚动数组的操作进行状态转移。这棵线段树需要支持区间修改（替换），区间修改（增加），区间查询最大值。</p><p>注意需要对高度进行离散化处理。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(u) node[u].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(u) node[u].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(u) node[u].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tag1(u) node[u].tag1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tag2(u) node[u].tag2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) (lower_bound(b + 1, b + L + 1, x) - b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid(x) b[x]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, val, tag1, tag2;</span><br><span class="line">    <span class="comment">// val: max</span></span><br><span class="line">    <span class="comment">// tag1: replace</span></span><br><span class="line">    <span class="comment">// tag2: add</span></span><br><span class="line">&#125;node[MAXN * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Limit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, k;</span><br><span class="line">&#125;limit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, M;</span><br><span class="line"><span class="keyword">int</span> R, L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[MAXN], h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    u = ++cnt;</span><br><span class="line">    tag1(u) = -inf;</span><br><span class="line">    tag2(u) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson(u), l, mid);</span><br><span class="line">    build(rson(u), mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag1(u) != -inf) &#123;</span><br><span class="line">        val(lson(u)) = val(rson(u)) = tag1(u);</span><br><span class="line">        tag1(lson(u)) = tag1(rson(u)) = tag1(u);</span><br><span class="line">        tag2(lson(u)) = tag2(rson(u)) = <span class="number">0</span>;</span><br><span class="line">        tag1(u) = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag2(u) != <span class="number">0</span>) &#123;</span><br><span class="line">        val(lson(u)) += tag2(u);</span><br><span class="line">        val(rson(u)) += tag2(u);</span><br><span class="line">        tag2(lson(u)) += tag2(u);</span><br><span class="line">        tag2(rson(u)) += tag2(u);</span><br><span class="line">        tag2(u) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    val(u) = max(val(lson(u)), val(rson(u)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify_replace</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">    pushdown(u);</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        val(u) = val;</span><br><span class="line">        tag1(u) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) modify_replace(lson(u), l, mid, ql, qr, val);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) modify_replace(rson(u), mid + <span class="number">1</span>, r, ql, qr, val);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify_add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">    pushdown(u);</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        val(u) += val;</span><br><span class="line">        tag2(u) = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) modify_add(lson(u), l, mid, ql, qr, val);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) modify_add(rson(u), mid + <span class="number">1</span>, r, ql, qr, val);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    pushdown(u);</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> val(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ret = -inf;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret = max(ret, query_max(lson(u), l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) ret = max(ret, query_max(rson(u), mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Limit a, Limit b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">if</span> (a.y != b.y) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.k &lt; b.k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line">        cnt = <span class="number">0</span>, L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line">            b[++L] = h[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;limit[i].x, &amp;limit[i].y, &amp;limit[i].k);</span><br><span class="line">            limit[i].y++;</span><br><span class="line">            <span class="keyword">if</span> (limit[i].k == <span class="number">0</span>) limit[i].k = <span class="number">-1</span>, ans1++;</span><br><span class="line">            b[++L] = limit[i].y;</span><br><span class="line">            b[++L] = limit[i].y - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="number">1</span>, b + L + <span class="number">1</span>);</span><br><span class="line">        L = unique(b + <span class="number">1</span>, b + L + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">        h[<span class="number">1</span>] = L;</span><br><span class="line">        build(R, <span class="number">1</span>, L);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">            h[i] = id(h[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">            limit[i].y = id(limit[i].y);</span><br><span class="line">        sort(limit + <span class="number">1</span>, limit + M + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> height = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = query_max(R, <span class="number">1</span>, L, <span class="number">1</span>, h[i]);</span><br><span class="line">            <span class="keyword">while</span> (limit[cur].x == i &amp;&amp; limit[cur].y &lt;= h[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = limit[cur].k;</span><br><span class="line">                <span class="keyword">while</span> (limit[cur].x == limit[cur + <span class="number">1</span>].x &amp;&amp; limit[cur].y == limit[cur + <span class="number">1</span>].y) &#123;</span><br><span class="line">                    w += limit[++cur].k;</span><br><span class="line">                &#125;</span><br><span class="line">                modify_replace(R, <span class="number">1</span>, L, height, id(rid(limit[cur].y) - <span class="number">1</span>), s + tmp);</span><br><span class="line">                height = limit[cur].y;</span><br><span class="line">                s += w;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height &lt;= h[i])</span><br><span class="line">                modify_replace(R, <span class="number">1</span>, L, height, h[i], s + tmp);</span><br><span class="line">            height = h[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (limit[cur].x == i) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = limit[cur].k;</span><br><span class="line">                <span class="keyword">while</span> (limit[cur].x == limit[cur + <span class="number">1</span>].x &amp;&amp; limit[cur].y == limit[cur + <span class="number">1</span>].y) &#123;</span><br><span class="line">                    w += limit[++cur].k;</span><br><span class="line">                &#125;</span><br><span class="line">                modify_add(R, <span class="number">1</span>, L, height, id(rid(limit[cur].y) - <span class="number">1</span>), s);</span><br><span class="line">                height = limit[cur].y;</span><br><span class="line">                s += w;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height &lt;= L)</span><br><span class="line">                modify_add(R, <span class="number">1</span>, L, height, L, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans1 + query_max(R, <span class="number">1</span>, L, <span class="number">1</span>, L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/6032&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目概括&lt;strong&gt;重金&lt;/strong&gt;征集中~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="离散化" scheme="https://tth37.cn/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p3960列队</title>
    <link href="https://tth37.cn/2019/09/24/solution-luogu-p3960/"/>
    <id>https://tth37.cn/2019/09/24/solution-luogu-p3960/</id>
    <published>2019-09-24T15:14:36.000Z</published>
    <updated>2019-09-24T15:37:12.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P3960" target="_blank" rel="noopener">题目链接</a></p><p>题目概括征集中~</p></blockquote><a id="more"></a><p>一道非常有意思的题。</p><p>假设我们有一个神奇的数据结构，它可以动态地维护一个长度为 $n$ 的队列，其初始元素为 $1,2,…,n$ 。该队列可以支持两种操作，第一种为删除队列的第 $k$ 项元素，执行“向前看齐”操作，并在队列的末尾补充 $n+1$ （以此类推）。第二种为查询队列的第 $k$ 项元素的数值。</p><p>拥有这样一个数据结构，本题就简单多了；观察到“向前看齐”命令只对最后一列产生影响，我们可以在每一行维护一个动态队列，最后一列用另一个动态队列单独处理。</p><p>如果出列的同学位于最后一列，则只需对最后一列进行一次删除操作即可；如果出列的同学不在最后一列，则需要对出列同学所在的那一行与最后一列同时进行操作。实现细节不再赘述。</p><p>现在我们来考虑一下如何实现神奇的动态队列。在本题的情况中，假设每个动态队列最多有 $Q$ 次删除操作，那么动态队列的时空复杂度必须只与 $Q$ 相关，否则 $O(n^2)$ 的时空复杂度无法承受。似乎这里可以用平衡树实现，而我采用了较为好写的<strong>动态开点权值线段树</strong>来维护动态队列。</p><p>初始状态，权值线段树下标为 $1,2,…,n$ 的节点大小均为 $1$ 。对于删除操作，我们只需将对应的权值大小减一，并在权值 $n+1$ 的大小加一即可。对于查询操作，只需在权值线段树中查询第 $k$ 小元素即为对应数值。实现细节同样不再赘述。</p><p>记得开 long long 。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(u) (node[u].l)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(u) (node[u].r)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(u) (node[u].sum)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum;</span><br><span class="line">&#125;node[MAXN * <span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> root[MAXN], size[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; ins[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>) u = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sum(u) += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) modify(lson(u), l, mid, p, val);</span><br><span class="line">    <span class="keyword">else</span> modify(rson(u), mid + <span class="number">1</span>, r, p, val);</span><br><span class="line">    sum(u) = sum(lson(u)) + sum(rson(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lsum = sum(lson(u));</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= T) &#123;</span><br><span class="line">        lsum += (mid &gt; T) ? T - l + <span class="number">1</span> : mid - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= lsum) <span class="keyword">return</span> query(lson(u), l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rson(u), mid + <span class="number">1</span>, r, k - lsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;M, &amp;Q);</span><br><span class="line">    <span class="keyword">int</span> Case = Q;</span><br><span class="line">    <span class="keyword">while</span> (Case--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        ll ans = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (y == M) &#123;</span><br><span class="line">            T = N;</span><br><span class="line">            ans = query(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, x);</span><br><span class="line">            modify(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, ans, <span class="number">-1</span>);</span><br><span class="line">            modify(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, N + (++size[N + <span class="number">1</span>]), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= N) ans = ans * (ll)M;</span><br><span class="line">            <span class="keyword">else</span> ans = ins[N + <span class="number">1</span>][ans - N - <span class="number">1</span>];</span><br><span class="line">            ins[N + <span class="number">1</span>].push_back(ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T = M - <span class="number">1</span>;</span><br><span class="line">            ans = query(root[x], <span class="number">1</span>, M + Q, y);</span><br><span class="line">            modify(root[x], <span class="number">1</span>, M + Q, ans, <span class="number">-1</span>);</span><br><span class="line">            modify(root[x], <span class="number">1</span>, M + Q, M - <span class="number">1</span> + (++size[x]), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= M - <span class="number">1</span>) ans += (ll)(x - <span class="number">1</span>) * M;</span><br><span class="line">            <span class="keyword">else</span> ans = ins[x][ans - M];</span><br><span class="line">            T = N;</span><br><span class="line">            tmp = query(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, x);</span><br><span class="line">            modify(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, tmp, <span class="number">-1</span>);</span><br><span class="line">            modify(root[N + <span class="number">1</span>], <span class="number">1</span>, N + Q, N + (++size[N + <span class="number">1</span>]), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt;= N) tmp = tmp * (ll)M;</span><br><span class="line">            <span class="keyword">else</span> tmp = ins[N + <span class="number">1</span>][tmp - N - <span class="number">1</span>];</span><br><span class="line">            ins[N + <span class="number">1</span>].push_back(ans);</span><br><span class="line">            ins[x].push_back(tmp);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P3960&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目概括征集中~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2680运输计划(Beta)</title>
    <link href="https://tth37.cn/2019/09/20/solution-luogu-p2680/"/>
    <id>https://tth37.cn/2019/09/20/solution-luogu-p2680/</id>
    <published>2019-09-20T13:46:44.000Z</published>
    <updated>2019-09-20T14:14:02.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P2680" target="_blank" rel="noopener">题目链接</a></p><p>证明及优化树上路径求交算法后 将会在洛谷博客上发布</p></blockquote><a id="more"></a><p>这是一道暑假集训被劝退的神仙题 在今天的信息课上奇迹般地一遍过</p><p>根据题意，将某一条边的边权从 $w$ 改为 $0$，即为将经过该条边的路径总长度减去 $w$。而我们要做的，就是改造树上的某一条边，使得最长的路径长度最短。</p><p>题目乍一看可以二分，但在这篇题解中采用贪心策略。</p><p>首先将所有路径按照长度降序排序。不难发现，只有在“改造”操作能够同时减小前 $x$ 条路径的长度，该操作才是有意义的，否则不会对答案产生贡献。</p><p>那么如何使“改造”操作同时减小前 $x$ 条路径的长度呢？显然，此时选取的边一定属于前 $x$ 条路径的交。路径的交一定仍是路径，根据贪心，只需在路径的交上选取最大的边权，将这条边的边权改为 $0$，然后更新答案即可。</p><p>仅剩的问题在于如何快速求出前 $x$ 条路径的交。这里介绍一种 <a href="https://tth37.cn">tth37</a> 算法。（开始口胡）</p><blockquote><p>引理：路径 $p(u1,v1)$ 与 $p(u2,v2)$ 如果存在交，则路径的交的端点一定为 $lca(u1,u2),lca(u1,v2),lca(v1,u2),lca(v1,v2)$ 中同时属于两条路径的最远点对。</p></blockquote><p>尚未证明。未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P2680&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;证明及优化树上路径求交算法后 将会在洛谷博客上发布&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="倍增" scheme="https://tth37.cn/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="最近公共祖先" scheme="https://tth37.cn/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1941飞扬的小鸟</title>
    <link href="https://tth37.cn/2019/09/19/solution-luogu-p1941/"/>
    <id>https://tth37.cn/2019/09/19/solution-luogu-p1941/</id>
    <published>2019-09-19T14:57:50.000Z</published>
    <updated>2019-10-02T15:45:27.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P1941" target="_blank" rel="noopener">题目链接</a></p><p>给定 $n*m$ 的游戏界面，求是否可以通过操作使小鸟通过所有管道以及最少操作次数。</p><p>$n\le 10000,m\le 1000$</p></blockquote><a id="more"></a><p>这篇博客不会在洛谷发表，所以内容可能比较放飞自我。</p><p>神仙shiwt巨佬早在去年的这个时候就已经切掉了这个神仙题。</p><p>记 $f[i][j]$ 表示从起点飞到坐标 $(i,j)$ 所需的最小步数。考虑 $f[i][j]$ 的转移。它要么是从 $(i-1,j+Y)$ 那里掉下来的，也有可能是从 $(i-1,j-kX)$ 那里升上来的。</p><p>考虑优化。 $(i-1,j-kX)$ 的枚举较为啰嗦；不难发现如果小鸟🐦可以飞到 $(i,j-X)$ ，那么它再飞一下不就到 $(i,j)$ 了吗？</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]=\min \{f[i-1][j+Y],f[i][j-X]+1,f[i-1][j-X]+1\}</script><p>不妨写个滚动数组。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN];</span><br><span class="line"><span class="keyword">int</span> L[MAXN], R[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][MAXM * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, minn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;M, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;X[i], &amp;Y[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p, l, h;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p, &amp;l, &amp;h);</span><br><span class="line">        L[p] = l, R[p] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i &amp; <span class="number">1</span>;</span><br><span class="line">        minn = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M + X[i]; ++j)</span><br><span class="line">            f[cur][j] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = X[i]; j &lt;= M + X[i]; ++j)</span><br><span class="line">            f[cur][j] = min(f[cur][j], min(f[cur ^ <span class="number">1</span>][j - X[i]] + <span class="number">1</span>, f[cur][j - X[i]] + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = M + <span class="number">1</span>; j &lt;= M + X[i]; ++j)</span><br><span class="line">            f[cur][M] = min(f[cur][M], f[cur][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M - Y[i]; ++j)</span><br><span class="line">            f[cur][j] = min(f[cur][j], f[cur ^ <span class="number">1</span>][j + Y[i]]);</span><br><span class="line">        <span class="keyword">if</span> (L[i] || R[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= L[i]; ++j)</span><br><span class="line">                f[cur][j] = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = R[i]; j &lt;= M; ++j)</span><br><span class="line">                f[cur][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">0</span>] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">            minn = min(minn, f[cur][j]);</span><br><span class="line">        <span class="keyword">if</span> (minn == INF) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += L[i] || R[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, minn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1941&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定 $n*m$ 的游戏界面，求是否可以通过操作使小鸟通过所有管道以及最少操作次数。&lt;/p&gt;
&lt;p&gt;$n\le 10000,m\le 1000$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1979华容道</title>
    <link href="https://tth37.cn/2019/09/18/solution-luogu-p1979/"/>
    <id>https://tth37.cn/2019/09/18/solution-luogu-p1979/</id>
    <published>2019-09-18T14:45:06.000Z</published>
    <updated>2019-09-18T15:30:25.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P1979" target="_blank" rel="noopener">题目链接</a></p><p>给定一个 $n * m$  的棋盘，共 $q$ 次询问，每次询问在华容道游戏中将目标块移动到目标位置的最少步数</p><p>$n,m\le 30, q\le 300$</p></blockquote><a id="more"></a><p>本题的正解比较难想，正常人看到这题可能都会在搜索剪枝的<del>不归</del>路上越走越远。</p><p>如果采用搜索的策略，每次需要记录下棋盘的完整状态，状态数量和转移数量过于庞大，以致于无法在规定时间内求解。</p><p>观察到棋盘中的非障碍位置只可能有空格、普通棋子或目标棋子三种可能，因此我们只需确定目标棋子和空格的位置，就可以将整张棋盘的状态确定下来。</p><p>显然，如果想要挪动目标棋子，则目标棋子的上下左右四个方向之一必须为空格。可以定义状态为三元组 $(x,y,d)$ ，表示目标棋子位于 $(x,y)$ ，并且其 $d(0\le d\le 3)$ 方向为空格。</p><p>假设位于 $(x1,y1)$ 的目标棋子向 $d1$ 方向移动一个单位后到达 $(x2,y2)$ ，不难发现状态 $(x1,y1,d1)$ 可以转移到状态 $(x2,y2,d2)$。而此次转移需要的代价，即为将空格从原始位置移动到 $(x2,y2)$ 的 $d2$ 方向所需的最小步数。这里可以用 bfs 求解。（注意障碍方块和 $(x2,y2)$ 位置是不可以经过的）</p><p>将每个状态 $(x,y,d)$ 抽象为节点，可以转移的状态之间连一条有向边，边权即为转移的最小步数。对于每次询问，计算出抽象后的图中最短路径即可。</p><p>代码如下：（略丑）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x, y, d) ((x - 1) * M + y) + N * M * (d)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> v, <span class="keyword">int</span> w): v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[<span class="number">35</span> * <span class="number">35</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> nx[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ny[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> N, M, Q;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> px, <span class="keyword">int</span> py)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span> (h[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    t[x][y] = <span class="number">1</span>, vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    q.push(make_pair(x, y));</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> ux = q.front().first, uy = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= <span class="number">3</span>; ++d) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = ux + nx[d], ty = uy + ny[d];</span><br><span class="line"><span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; N || ty &lt; <span class="number">1</span> || ty &gt; M) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (tx == px &amp;&amp; ty == py) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (h[tx][ty] == <span class="number">0</span> || vis[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">t[tx][ty] = t[ux][uy] + <span class="number">1</span>;</span><br><span class="line">q.push(make_pair(tx, ty));</span><br><span class="line">vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">G[u].push_back(Edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">35</span> * <span class="number">35</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">35</span> * <span class="number">35</span> * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">d[S] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">q.push(make_pair(<span class="number">0</span>, S));</span><br><span class="line"><span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.top().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (v[u]) <span class="keyword">continue</span>;</span><br><span class="line">v[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = it-&gt;v, w = it-&gt;w;</span><br><span class="line"><span class="keyword">if</span> (d[u] + w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + w;</span><br><span class="line">q.push(make_pair(-d[v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;M, &amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= N; ++x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= M; ++y) &#123;</span><br><span class="line"><span class="keyword">if</span> (h[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= <span class="number">3</span>; ++d) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + nx[d], ty = y + ny[d];</span><br><span class="line"><span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; N || ty &lt; <span class="number">1</span> || ty &gt; M) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (h[tx][ty] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">getdis(x, y, tx, ty);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">0</span>; d2 &lt;= <span class="number">3</span>; ++d2) &#123;</span><br><span class="line"><span class="keyword">int</span> tx2 = tx + nx[d2], ty2 = ty + ny[d2];</span><br><span class="line"><span class="keyword">if</span> (tx2 &lt; <span class="number">1</span> || tx2 &gt; N || ty2 &lt; <span class="number">1</span> || ty2 &gt; M) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (t[tx2][ty2] &gt;= INF) <span class="keyword">continue</span>;</span><br><span class="line">AddEdge(id(x, y, d), id(tx, ty, d2), t[tx2][ty2]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (Q--) &#123;</span><br><span class="line"><span class="keyword">int</span> ex, ey, sx, sy, tx, ty;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;ex, &amp;ey, &amp;sx, &amp;sy, &amp;tx, &amp;ty);</span><br><span class="line">        <span class="keyword">if</span> (sx == tx &amp;&amp; sy == ty) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">getdis(ex, ey, sx, sy);</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d1 = <span class="number">0</span>; d1 &lt;= <span class="number">3</span>; ++d1) &#123;</span><br><span class="line"><span class="keyword">int</span> fx = sx + nx[d1], fy = sy + ny[d1];</span><br><span class="line"><span class="keyword">if</span> (fx &lt; <span class="number">1</span> || fx &gt; N || fy &lt; <span class="number">1</span> || fy &gt; M) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (t[fx][fy] &gt;= INF) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> cur = INF;</span><br><span class="line">Dijkstra(id(sx, sy, d1));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d2 = <span class="number">0</span>; d2 &lt;= <span class="number">3</span>; ++d2)</span><br><span class="line">cur = min(cur, d[id(tx, ty, d2)]);</span><br><span class="line">cur += t[fx][fy] - <span class="number">1</span>;</span><br><span class="line">ans = min(ans, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &gt;= INF) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个 $n * m$  的棋盘，共 $q$ 次询问，每次询问在华容道游戏中将目标块移动到目标位置的最少步数&lt;/p&gt;
&lt;p&gt;$n,m\le 30, q\le 300$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="最短路" scheme="https://tth37.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p5290春节十二响</title>
    <link href="https://tth37.cn/2019/09/12/solution-luogu-p5290/"/>
    <id>https://tth37.cn/2019/09/12/solution-luogu-p5290/</id>
    <published>2019-09-12T15:19:41.000Z</published>
    <updated>2019-09-12T15:46:09.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P5290" target="_blank" rel="noopener">题目链接</a></p><p>给定一棵有 $n$ 个节点的树，将树上所有节点分为若干组，其中每一组中的任意两个节点不能存在祖先-后代关系，每一组的权值为该组中所有节点权值的最大值，求所有组的权值总和最小值。</p><p>$1 \le n \le 200000$</p><p>我感谢我自己</p></blockquote><a id="more"></a><p>首先考虑树退化为链的情况。树根最多有两棵子树，树根需要被单独分为一段，其余段中不能出现同一棵子树内的两个点。</p><p>这时我们需要将左子树中的节点与右子树中的节点配对。可以证明，将左子树中的最大值与右子树中的最大值、左子树中的次大值与右子树中的次大值以此类推两两配对，可以使所有段的权值总和最小。</p><p>如此一来，两条链实则被合并成为一条链。同理，多条链也可以使用类似的方式合并为一条链。</p><p>因此，我们可以维护每个节点到叶子节点的一条<strong>等效链</strong>，并且要求高效地将两条链合并为一条新链。</p><p>不难看出，由于我们需要<strong>取最大值</strong>的性质，可以使用堆来维护链信息。即，在每个节点上建立一个堆，堆中存储从当前节点到叶子节点的等效链上所有权值信息。</p><p>接下来需要解决的即为链的合并即<strong>堆的合并</strong>问题。假设需要合并堆 $q1$ ，$q2$ 。</p><p>如果 $q1.size()&gt;q2.size()$，那么只需取出 $q1$ 的前 $q2.size()$ 项，并将它们与 $q2$ 中的所有元素取最大值即可。时间复杂度 $O(q2.size()\log q2.size())$ 。</p><p>如果 $q1.size()&lt;q2.size()$，那么不仅需要取出 $q1$ 的所有项，并将它们与 $q2$ 中的前 $q1.size()$ 项取最大值，还需将 $q2$ 中剩余的元素插入 $q1$ 中。时间复杂度 $O(q2.size()\log q2.size())$ 。</p><p>不难看出，将大堆合并进入小堆，时间复杂度在 $O(max(q1.size(),q2.size()))$ 级别。但如果换一种思路，将小堆合并进入大堆，时间复杂度就降到 $O(min(q1.size(),q2.size()))$ 级别。此方法与并查集的按秩合并有异曲同工之妙，被成为<strong>启发式合并</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> M[<span class="number">200005</span>];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">200005</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        dfs(v);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[u].size() &lt; q[v].size()) swap(q[u], q[v]);</span><br><span class="line">        <span class="keyword">while</span>(q[v].size()) &#123;</span><br><span class="line">            tmp[++cnt] = max(q[u].top(), q[v].top());</span><br><span class="line">            q[u].pop(), q[v].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            q[u].push(tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    q[u].push(M[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f);</span><br><span class="line">        G[f].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q[<span class="number">1</span>].size()) ans += q[<span class="number">1</span>].top(), q[<span class="number">1</span>].pop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5290&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵有 $n$ 个节点的树，将树上所有节点分为若干组，其中每一组中的任意两个节点不能存在祖先-后代关系，每一组的权值为该组中所有节点权值的最大值，求所有组的权值总和最小值。&lt;/p&gt;
&lt;p&gt;$1 \le n \le 200000$&lt;/p&gt;
&lt;p&gt;我感谢我自己&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="启发式合并" scheme="https://tth37.cn/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="堆" scheme="https://tth37.cn/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-点分治&amp;动态点分治</title>
    <link href="https://tth37.cn/2019/09/11/algorithm-treedivide/"/>
    <id>https://tth37.cn/2019/09/11/algorithm-treedivide/</id>
    <published>2019-09-11T14:49:52.000Z</published>
    <updated>2019-09-11T14:56:54.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>点分治适合处理大规模的树上路径信息问题。</p><p>点分治的实现基于以下结论：一棵子树上的任意一条路径，要么经过树根，要么被完全包含在树根的一棵子树中。</p><p>定义 $solve()$ 函数，对每棵子树进行分值处理，并保证 $O(n\log n)$ 的时间复杂度。</p><a id="more"></a><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>这么简单还要模板？</p><h2 id="动态点分治（点分树）"><a href="#动态点分治（点分树）" class="headerlink" title="动态点分治（点分树）"></a>动态点分治（点分树）</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在树上的每个节点上建立数据结构，存储其控制范围内所有点与之的距离信息。在进行修改或查询操作时，只需访问当前节点的所有祖先（最多 $O(\log n)$ 个）即可。</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><p>代码过于毒瘤 不贴了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;点分治&quot;&gt;&lt;a href=&quot;#点分治&quot; class=&quot;headerlink&quot; title=&quot;点分治&quot;&gt;&lt;/a&gt;点分治&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;点分治适合处理大规模的树上路径信息问题。&lt;/p&gt;
&lt;p&gt;点分治的实现基于以下结论：一棵子树上的任意一条路径，要么经过树根，要么被完全包含在树根的一棵子树中。&lt;/p&gt;
&lt;p&gt;定义 $solve()$ 函数，对每棵子树进行分值处理，并保证 $O(n\log n)$ 的时间复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="点分治" scheme="https://tth37.cn/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="动态点分治" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1311选择客栈</title>
    <link href="https://tth37.cn/2019/09/09/solution-luogu-p1311/"/>
    <id>https://tth37.cn/2019/09/09/solution-luogu-p1311/</id>
    <published>2019-09-09T14:17:18.000Z</published>
    <updated>2019-09-09T16:04:10.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P1311" target="_blank" rel="noopener">题目链接</a></p><p>现在我随机@一个人 这个人必须帮我写题目概括</p><p>@gzn7264</p></blockquote><a id="more"></a><p>这篇题解就不在洛谷博客上发布了。</p><p>首先枚举点对的右端点。显而易见，合法的左端点必须满足：</p><ol><li>左端点与右端点颜色相同</li><li>左端点到右端点之间必须存在至少一个客栈，使得其费用小于等于 $P$</li></ol><p>第二个条件有点麻烦，我们可以稍微转化一下。记 $l_i$ 为客栈 $i$ 的左侧第一个费用小于等于 $P$ 的客栈编号。那么，以 $i$ 为右端点的情况下，左端点的可选位置即为 $1-l_i$ 种所有颜色与客栈 $i$ 相同的客栈个数。</p><p> 由于本题卡空间，必须采用滚动数组。数组 $s_i$ 记录颜色 $i$ 的出现次数，数组 $c_i$ 记录颜色 $i$ 的可选左端点个数。每次更新答案时，加上 $c_{color}$ 即可。</p><p>在示例代码中，可选的左端点包括其本身，因此当 $money\le P$ 时存在重复计算，答案减一。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">int</span> N, K, P;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">50</span>], s[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;K, &amp;P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> color, money;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;color, &amp;money);</span><br><span class="line">        s[color]++;</span><br><span class="line">        <span class="keyword">if</span> (money &lt;= P)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j)</span><br><span class="line">                c[j] = s[j];</span><br><span class="line">        ans += c[color] - (money &lt;= P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1311&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我随机@一个人 这个人必须帮我写题目概括&lt;/p&gt;
&lt;p&gt;@gzn7264&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="前缀和" scheme="https://tth37.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2495消耗战</title>
    <link href="https://tth37.cn/2019/08/30/solution-luogu-p2495/"/>
    <id>https://tth37.cn/2019/08/30/solution-luogu-p2495/</id>
    <published>2019-08-30T13:58:48.000Z</published>
    <updated>2019-08-30T14:58:40.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P2495" target="_blank" rel="noopener">题目链接</a></p><p>现在我随机@一个人 这个人必须帮我写题目概括</p><p>@xj</p></blockquote><a id="more"></a><p>这是一篇虚树入门题解。</p><p>考虑题目中 $m=1$ 的情况。树上动规，定义状态 $f[u]$ 表示切断节点 $u$ 与该子树内所有关键点的路径，最小总代价。状态转移方程如下：</p><script type="math/tex; mode=display">f[u]=\begin{equation}\begin{cases}w(u,v) \ \texttt{if h[v]=1} \\\min(w(u,v),f[v])\  \texttt{if h[v]=0}\end{cases}\end{equation}</script><p>动态规划部分不再赘述。该算法复杂度为 $O(n)$ 。</p><p>考虑题目中 $m\not= 1$ 的情况。如果对于每一次查询，都进行一次 $O(n)$ 复杂度的遍历显然无法接受。观察到题目中 $\Sigma{k}$ 的取值不大，可以考虑针对没个询问，<strong>舍弃树上的一些非关键点，仅保留一棵包含原树上部分节点的虚树</strong>，并在<strong>虚树</strong>上进行动态规划。</p><p>那么，在虚树上应该保留原树上的哪些点呢？</p><p>首先，每次讯问中给出的 $k$ 个关键点（资源丰富的岛屿）显然应该包含在虚树中。其次，任意两个关键点的最近公共祖先也应该包含在虚树中；因为在本题中，切断一条边可以同时切断根节点与多个关键点间的路径，最近公共祖先的存在为动态规划提供了这种状态转移。最后为了方便，我们可以将 $1$ 号节点（即根节点）也加入到虚树中。</p><p>构造虚树的方法很多，在这里介绍一种用<strong>栈</strong>建树的算法流程。</p><p>令 $1$ 号节点为虚树的根。</p><p>将所有关键点按照其在原树中的 dfs 序升序排序。假设当前正在处理的关键点为 $u$ 。</p><p>维护一个栈，使得栈底到栈顶的元素依次为虚树上<strong>从根节点到节点 $u$ 的一条链</strong>。</p><p>这里为什么要维护一个栈呢？</p><p><img src="https://i.loli.net/2019/08/30/qTkLb1Wca4yvwJ9.jpg" alt="1.jpg"></p><p>如图：在处理完 $3$ 号关键点后，虚树中只有 $1$ 、 $3$ 两个节点，栈中的元素依次为 $1$ 、 $3$ 。但是这条链是不完整的，可以观察到在处理 $4$ 号关键点时，还需要将 $2$ 号节点添加到虚树中。利用栈的性质，我们可以动态维护一条虚树上的链，并在必要的时候添加节点。</p><p>回到刚才的叙述，当前正在处理关键点 $u$ 。根据栈的定义，上一个处理的关键点一定为 $stack.top()$ 。</p><p>由于进行过排序，即节点 $u$  的 dfs 序大于上一个关键点的 dfs 序，因此节点 $u$ 要么是上一个关键点的后代，要么与其没有祖先-后代的关系。</p><p>显然，如果节点 $u$ 是 $stack.top()$ 的后代，那么只需将节点 $u$ 入栈即可，因为 $u$ 在虚树中，一定是上一个关键点的儿子。</p><p>但是如果节点 $u$ 与 $stack.top()$ 没有祖先-后代的关系，那么此时的讨论将比较复杂。</p><p>可以结合上图观察，假设当前正在处理 $4$ 号关键点。我们可以首先将栈顶弹出，因为 $stack.top()$ 一定不在根节点到节点 $u$ 的链上。此时，栈中剩余的元素只有 $1$ 。然而， $3$ 与 $4$ 的最近公共祖先 $2$ 号节点还不在栈中；因此我们需要把 $2$ 号节点入栈，并将<strong>刚刚弹出的节点与新的栈顶</strong>在虚树中连边。处理结束后，将 $4$ 入栈。</p><p>接下来处理 $5$ 号关键点，此时栈中的元素依次为 $1$ 、$2$ 、$4$ 。首先将栈顶弹出，但由于我们接下来需要维护的链为 $1-&gt;5$ ，栈中仍然有节点 $2$ ，因此我们需要将 $2$ 和刚刚弹出的节点 $4$ 连边，并且重复以上操作。将新的栈顶 $2$ 弹出后，栈中只剩下节点 $1$ 。这时发现 $1$ 号节点恰好为 $5$ 与上一次处理的关键点 $4$ 的最近公共祖先，因此将 $1$ 与 $2$ 连边后，弹栈可以中止了。处理结束后，将 $5$ 入栈。</p><p>此时我们已经处理完了所有关键点，但是栈中的元素间还没有连边。将栈中的节点依次连边后，虚树的构建就完成了。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">将关键点按照 dfs 序排序</span><br><span class="line">stack.push(1)</span><br><span class="line">for u = 1 ~ k: // 假设当前正在处理节点 u</span><br><span class="line">lca = Lca(u, stack.top())</span><br><span class="line">while stack.top() != lca:</span><br><span class="line">tmp = stack.top()</span><br><span class="line">stack.pop()</span><br><span class="line">if dfn[stack.top()] &lt; dfn[lca]</span><br><span class="line">stack.push(lca)</span><br><span class="line">AddEdge(stack.top(), tmp)</span><br><span class="line">stack.push(u)</span><br><span class="line">while stack.top() != 1:</span><br><span class="line">tmp = stack.top()</span><br><span class="line">stack.pop()</span><br><span class="line">AddEdge(stack.top(), tmp)</span><br></pre></td></tr></table></figure><p>可以证明，对于本题，虚树上的边权一定对应原树上两节点之间边权的最小值。证明不再赘述。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> v;ll w;Edge(<span class="keyword">int</span> a, ll b) &#123;v = a, w = b;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Key</span> &#123;</span><span class="keyword">int</span> u, dfn;&#125;keys[<span class="number">250005</span>];</span><br><span class="line"><span class="keyword">int</span> keys_cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Key a, Key b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dfn &lt; b.dfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[<span class="number">250005</span>], VT[<span class="number">250005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">250005</span>][<span class="number">19</span>], g[<span class="number">250005</span>][<span class="number">19</span>], dep[<span class="number">250005</span>];</span><br><span class="line">ll d[<span class="number">250005</span>];</span><br><span class="line"><span class="keyword">bool</span> h[<span class="number">250005</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">250005</span>], dfn_idx;</span><br><span class="line"><span class="keyword">int</span> lg[<span class="number">250005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, ll w)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    dfn[u] = ++dfn_idx;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa, g[u][<span class="number">0</span>] = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>],</span><br><span class="line">        g[u][i] = min(g[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>], g[u][i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v;</span><br><span class="line">        ll w = it -&gt; w;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v;</span><br><span class="line">        ll w = it -&gt; w;</span><br><span class="line">        dp(v);</span><br><span class="line">        <span class="keyword">if</span> (h[v]) d[u] += w;</span><br><span class="line">        <span class="keyword">else</span> d[u] += min(w, d[v]);</span><br><span class="line">        h[v] = <span class="number">0</span>; d[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VT[u].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">        u = f[u][lg[dep[u] - dep[v]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[dep[u]]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (f[u][i] != f[v][i])</span><br><span class="line">            u = f[u][i], v = f[v][i];</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) &#123;</span><br><span class="line">        ans = min(ans, g[u][lg[dep[u] - dep[v]]]);</span><br><span class="line">        u = f[u][lg[dep[u] - dep[v]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = query(v, u);</span><br><span class="line">    VT[u].push_back(Edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">250000</span>; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        G[u].push_back(Edge(v, w));</span><br><span class="line">        G[v].push_back(Edge(u, w));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">    <span class="keyword">while</span> (M--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        keys_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;keys[++keys_cnt].u);</span><br><span class="line">            h[keys[keys_cnt].u] = <span class="number">1</span>;</span><br><span class="line">            keys[keys_cnt].dfn = dfn[keys[keys_cnt].u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        sort(keys + <span class="number">1</span>, keys + keys_cnt + <span class="number">1</span>);</span><br><span class="line">        s.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= keys_cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = keys[i].u;</span><br><span class="line">            <span class="keyword">int</span> lca = Lca(u, s.top());</span><br><span class="line">            <span class="keyword">while</span> (s.top() != lca) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span> (dfn[s.top()] &lt; dfn[lca])</span><br><span class="line">                    s.push(lca);</span><br><span class="line">                AddEdge(s.top(), tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.top() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = s.top(); s.pop();</span><br><span class="line">            AddEdge(s.top(), tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, d[<span class="number">1</span>]);</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P2495&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在我随机@一个人 这个人必须帮我写题目概括&lt;/p&gt;
&lt;p&gt;@xj&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="虚树" scheme="https://tth37.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
      <category term="栈" scheme="https://tth37.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p4103大工程</title>
    <link href="https://tth37.cn/2019/08/30/solution-luogu-p4103/"/>
    <id>https://tth37.cn/2019/08/30/solution-luogu-p4103/</id>
    <published>2019-08-30T12:54:26.000Z</published>
    <updated>2019-08-30T13:11:15.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P4103" target="_blank" rel="noopener">题目链接</a></p><p>给定一棵有 $n$ 个节点的树，边权为 $1$ 。共有 $q$ 次询问，每次给出 $k$ 个节点，求： $k$ 个节点间两两距离之总和；最短距离；最长距离。</p><p>$1\le n \le 1000000,1 \le q \le 1000000, \Sigma{k}\le 2 * n$</p><p>感谢@tth37 的贡献</p></blockquote><a id="more"></a><p>本题用到了一些点分治的思想。</p><p>考虑 $q=1$ 的情况。一种朴素的做法是：枚举当前节点的所有子节点，并计算子树间关键点形成的路径、更新答案。但是本题与一般点分治题目略有不同，我们可以通过预处理子树信息来优化点分治过程。</p><p>稍加观察可以发现，只需预处理每个子树中树根到关键点的最小距离、最大距离，以及子树中关键点的个数、所有关键点到树根的距离总和即可完成点分治全部过程，时间复杂度 $O(n)$ 。</p><p>对于 $q\not=1$  的情况，观察到 $\Sigma{k}$ 与 $n$ 同阶，可以对每次查询建立一棵虚树，在虚树上点分治即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> v, w; Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;v = a, w = b;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Key</span> &#123;</span><span class="keyword">int</span> u, dfn;&#125;keys[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Key a, Key b)</span> </span>&#123;<span class="keyword">return</span> a.dfn &lt; b.dfn;&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAXN], VT[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, Q, K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">21</span>], dep[MAXN], dfn[MAXN], dfn_idx;</span><br><span class="line"><span class="keyword">int</span> lg[MAXN];</span><br><span class="line"><span class="keyword">bool</span> h[MAXN];</span><br><span class="line">ll g[MAXN];</span><br><span class="line"><span class="keyword">int</span> m[MAXN], n[MAXN];</span><br><span class="line"><span class="keyword">int</span> c[MAXN];</span><br><span class="line">ll ans1;</span><br><span class="line"><span class="keyword">int</span> ans2, ans3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfn_idx;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[dep[u]]; ++i)</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs0(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    g[u] = <span class="number">0</span>;</span><br><span class="line">    c[u] = h[u];</span><br><span class="line">    m[u] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    n[u] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (h[u]) m[u] = n[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v, w = it -&gt; w;</span><br><span class="line">        dfs1(v);</span><br><span class="line">        c[u] += c[v];</span><br><span class="line">        g[u] += g[v] + <span class="number">1l</span>l * w * c[v];</span><br><span class="line">        m[u] = min(m[u], w + m[v]);</span><br><span class="line">        n[u] = max(n[u], w + n[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = h[u];</span><br><span class="line">    <span class="keyword">int</span> minn = <span class="number">0x3f3f3f3f</span>, maxx = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span> (h[u]) minn = maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v, w = it -&gt; w;</span><br><span class="line">        ans1 += <span class="number">1l</span>l * sum * c[v] + <span class="number">1l</span>l * w * cnt * c[v] + <span class="number">1l</span>l * g[v] * cnt;</span><br><span class="line">        ans2 = min(ans2, minn + w + m[v]);</span><br><span class="line">        ans3 = max(ans3, maxx + w + n[v]);</span><br><span class="line">        sum += g[v] + <span class="number">1l</span>l * c[v] * w;</span><br><span class="line">        cnt += c[v];</span><br><span class="line">        minn = min(minn, w + m[v]);</span><br><span class="line">        maxx = max(maxx, w + n[v]);</span><br><span class="line">        dfs2(v);</span><br><span class="line">    &#125;</span><br><span class="line">    h[u] = <span class="number">0</span>;</span><br><span class="line">    VT[u].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) u = f[u][lg[dep[u] - dep[v]]];</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[dep[u]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000000</span>; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(Edge(v, <span class="number">1</span>));</span><br><span class="line">        G[v].push_back(Edge(u, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs0(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">            h[u] = <span class="number">1</span>;</span><br><span class="line">            keys[i].u = u, keys[i].dfn = dfn[u];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(keys + <span class="number">1</span>, keys + K + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        s.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = keys[i].u;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> lca = Lca(u, s.top());</span><br><span class="line">            <span class="keyword">while</span> (s.top() != lca) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span> (dfn[s.top()] &lt; lca) s.push(lca);</span><br><span class="line">                VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.top() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = s.top(); s.pop();</span><br><span class="line">            VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>);</span><br><span class="line">        ans1 = ans3 = <span class="number">0</span>;</span><br><span class="line">        ans2 = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        dfs2(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %d %d\n"</span>, ans1, ans2, ans3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P4103&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵有 $n$ 个节点的树，边权为 $1$ 。共有 $q$ 次询问，每次给出 $k$ 个节点，求： $k$ 个节点间两两距离之总和；最短距离；最长距离。&lt;/p&gt;
&lt;p&gt;$1\le n \le 1000000,1 \le q \le 1000000, \Sigma{k}\le 2 * n$&lt;/p&gt;
&lt;p&gt;感谢@tth37 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="虚树" scheme="https://tth37.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
      <category term="点分治" scheme="https://tth37.cn/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-虚树</title>
    <link href="https://tth37.cn/2019/08/29/algorithm-virtualtree/"/>
    <id>https://tth37.cn/2019/08/29/algorithm-virtualtree/</id>
    <published>2019-08-29T03:19:56.000Z</published>
    <updated>2019-08-29T03:34:48.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在处理某些树上问题时，并非树上的所有节点都起作用；这时可以借助虚树，将树上重要的点构造成一棵树，在虚树上处理问题，优化时间复杂度。</p><a id="more"></a><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>用栈来维护虚树上的一条从根到 $u$ 的链。如果 $u$ 是栈顶节点的儿子，则入栈；否则将栈中 dfn 值大于 $lca(u,s.top())$ 的元素出栈。</p><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">将树上所有关键点按照 dfs 序排序</span><br><span class="line">stack.push(1)</span><br><span class="line">for u = 1 ~ n: //假设当前正在处理节点 u</span><br><span class="line">lca = Lca(u, stack.top())</span><br><span class="line">while stack.top != lca:</span><br><span class="line">tmp = stack.top()</span><br><span class="line">stack.pop()</span><br><span class="line">if (dfn[stack.top()] &lt; dfn[lca]):</span><br><span class="line">stack.push(lca)</span><br><span class="line">AddEdge(stack.top(), tmp)</span><br><span class="line">stack.push(u)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在处理某些树上问题时，并非树上的所有节点都起作用；这时可以借助虚树，将树上重要的点构造成一棵树，在虚树上处理问题，优化时间复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="虚树" scheme="https://tth37.cn/tags/%E8%99%9A%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2019-10-1 国庆节</title>
    <link href="https://tth37.cn/2019/08/27/NationalDay/"/>
    <id>https://tth37.cn/2019/08/27/NationalDay/</id>
    <published>2019-08-27T13:40:39.000Z</published>
    <updated>2019-10-02T15:45:03.240Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1314聪明的质监员</title>
    <link href="https://tth37.cn/2019/08/27/solution-luogu-p1314/"/>
    <id>https://tth37.cn/2019/08/27/solution-luogu-p1314/</id>
    <published>2019-08-27T07:49:57.000Z</published>
    <updated>2019-08-27T08:08:44.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P1314" target="_blank" rel="noopener">题目链接</a></p><p>咕咕咕</p></blockquote><a id="more"></a><p>本题难度不大，第一眼就能看出需要用二分答案或<strong>倍增答案</strong>解决。</p><p>需要解决的第一个问题是如何根据一个猜测的参数 $W$ ，快速计算出检验结果 $Y$ 。由于只有 $w_j \ge W$ 的矿石才会对检验结果做出贡献，因此我们可以将 $w_j &lt; W$ 的矿石忽略并预处理前缀和，并且回答 $M$ 个询问即可。</p><p>接下来应该考虑如何计算猜测值 $W$ 。观察到 $Y(W)$ 是单调不增的，我们可以用<strong>倍增</strong>求出满足 $Y \ge S$  的最大 $W$ 值，那么满足 $Y&lt;S$ 的最小 $W$ 值一定为 $W+1$ 。</p><p>最终答案即为 $\min\lbrace |Y(W)-S|,|Y(W+1)-S|\rbrace$ 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> N, M, ans = <span class="number">1</span>; ll S;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">200005</span>], v[<span class="number">200005</span>], l[<span class="number">200005</span>], r[<span class="number">200005</span>]; ll s1[<span class="number">200005</span>], s2[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Y</span><span class="params">(<span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        s1[i] = w[i] &gt;= W ? s1[i - <span class="number">1</span>] + <span class="number">1</span> : s1[i - <span class="number">1</span>],</span><br><span class="line">        s2[i] = w[i] &gt;= W ? s2[i - <span class="number">1</span>] + v[i] : s2[i - <span class="number">1</span>];</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        ret += (s1[r[i]] - s1[l[i] - <span class="number">1</span>]) * (s2[r[i]] - s2[l[i] - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;N, &amp;M, &amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        ans += Y(ans + (<span class="number">1</span> &lt;&lt; i)) &gt;= S ? (<span class="number">1</span> &lt;&lt; i) : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, min(Y(ans) - S, S - Y(ans + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P1314&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;咕咕咕&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分答案" scheme="https://tth37.cn/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="前缀和" scheme="https://tth37.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="倍增" scheme="https://tth37.cn/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p5503灯塔</title>
    <link href="https://tth37.cn/2019/08/26/solution-luogu-p5503/"/>
    <id>https://tth37.cn/2019/08/26/solution-luogu-p5503/</id>
    <published>2019-08-26T15:29:57.000Z</published>
    <updated>2019-08-26T15:55:23.561Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P5503" target="_blank" rel="noopener">题目链接</a></p><p>咕咕咕</p></blockquote><a id="more"></a><p>由于根号的存在，本题并没有什么明显的单调性，不能通过二分或单调队列实现。</p><p>本题的关键在于问题转化。记 $l_i$ 表示在山峰 $i$ 上建灯塔，并使得山峰 $1…i$ 全部被照亮的最小高度。</p><script type="math/tex; mode=display">h_j\le h_i+l_i - \sqrt{i-j} (1\le j\le i)</script><script type="math/tex; mode=display">h_j+\sqrt{i-j}-h_i\le l_i(1\le j\le i)</script><script type="math/tex; mode=display">l_i=\max_{1\le j\le i}\lbrace  h_j+\lceil  (\sqrt{i-j})  \rceil \rbrace-h_i</script><p>这样 ${l}$ 数组的求解即转化为区间求解最值问题，然而 $\max$ 函数中的 $\lceil  (\sqrt{i-j})  \rceil$ 似乎有些棘手。然而观察到当 $\lceil  (\sqrt{i-j})  \rceil$ 相等时，只有该区间内最大的 $h_j$ 才会对答案产生贡献。因此我们可以枚举 $\lceil  (\sqrt{i-j})  \rceil$ 的值，求出对应的 $j$ 区间内 $h_j$ 的最值作为 $l_i$ 的候选答案。</p><p>$r_i$ 的定义与 $l_i$ 类似，最终的 $p_i$ 即为 $\max \lbrace l_i,r_i\rbrace$ 。</p><p>求解区间最值可以用 ST 表实现。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">100005</span>][<span class="number">18</span>];</span><br><span class="line"><span class="keyword">int</span> lg[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> power[<span class="number">320</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(st[l][s], st[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100000</span>; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">319</span>; ++i) &#123;</span><br><span class="line">        power[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;st[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[N]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N; ++i)</span><br><span class="line">            st[i][j] = max(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">0</span>, l = i, r = i;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            p[i] = max(p[i], query(l, r) + delta - st[i][<span class="number">0</span>]);</span><br><span class="line">            r = l - <span class="number">1</span>, l = i - power[++delta];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">1</span>) p[i] = max(p[i], query(<span class="number">1</span>, r) + delta - st[i][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">0</span>, l = i, r = i;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= N) &#123;</span><br><span class="line">            p[i] = max(p[i], query(l, r) + delta - st[i][<span class="number">0</span>]);</span><br><span class="line">            l = r + <span class="number">1</span>, r = i + power[++delta];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= N) p[i] = max(p[i], query(l, N) + delta - st[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P5503&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;咕咕咕&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="ST算法" scheme="https://tth37.cn/tags/ST%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>模板-常数优化</title>
    <link href="https://tth37.cn/2019/08/26/template-optimization/"/>
    <id>https://tth37.cn/2019/08/26/template-optimization/</id>
    <published>2019-08-26T13:00:29.000Z</published>
    <updated>2019-08-29T05:22:20.602Z</updated>
    
    <content type="html"><![CDATA[<h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><ol><li><p>减少函数参数传递，开全局变量 <a href="https://www.luogu.org/record/23355022" target="_blank" rel="noopener">血的教训</a></p></li><li><p><code>memset</code> 实在是太慢了！避免大数组的多次 <code>memset</code>，可以在程序的其他位置（如遍历）顺手将数组清空 <a href="https://www.luogu.org/record/23451875" target="_blank" rel="noopener">血的教训</a></p></li></ol><a id="more"></a><h4 id="快速读入"><a href="#快速读入" class="headerlink" title="快速读入"></a>快速读入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readint</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> ...<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">readint</span>(<span class="title">T1</span> &amp;<span class="title">i</span>, <span class="title">T2</span>&amp;... <span class="title">rest</span>)&#123;</span></span><br><span class="line">    i=<span class="number">0</span>;<span class="keyword">char</span> c;<span class="keyword">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c=getchar())) f=c==<span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">do</span> i=(i&lt;&lt;<span class="number">3</span>)+(i&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c=getchar()));</span><br><span class="line">    <span class="keyword">if</span> (f) i=-i;</span><br><span class="line">    readint(rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速输出"><a href="#快速输出" class="headerlink" title="快速输出"></a>快速输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂无</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;实用技巧&quot;&gt;&lt;a href=&quot;#实用技巧&quot; class=&quot;headerlink&quot; title=&quot;实用技巧&quot;&gt;&lt;/a&gt;实用技巧&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;减少函数参数传递，开全局变量 &lt;a href=&quot;https://www.luogu.org/record/23355022&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;血的教训&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;memset&lt;/code&gt; 实在是太慢了！避免大数组的多次 &lt;code&gt;memset&lt;/code&gt;，可以在程序的其他位置（如遍历）顺手将数组清空 &lt;a href=&quot;https://www.luogu.org/record/23451875&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;血的教训&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="模板" scheme="https://tth37.cn/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>公告 2019-8-26</title>
    <link href="https://tth37.cn/2019/08/26/bulletin-2019-8-26/"/>
    <id>https://tth37.cn/2019/08/26/bulletin-2019-8-26/</id>
    <published>2019-08-26T06:18:33.000Z</published>
    <updated>2019-08-27T13:54:12.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://tth37.cn/2019/05/18/bulletin-2019-5-18/">上一篇公告</a></p></blockquote><p>Hi~ 访问我网站的小崽子们~</p><p>想在评论区发言的同时留下自己的个人头像吗？快快注册一个<a href="https://www.github.com" target="_blank" rel="noopener">Github</a>账号吧！<del>学信息没个Github账号怎么行</del>  我的网站与Github完全兼容，可以使用Github登录我的网站，并且在文章下方评论！</p><p><a href="https://tth37.cn/message/">可以在这里测试一下</a></p><p>虽然网站是国家顶级域名（<code>*.cn</code>），但是Github头像的更新是实时的，注册Github账号之后立刻可以到我的博客评论！</p><p>谢谢资瓷！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://tth37.cn/2019/05/18/bulletin-2019-5-18/&quot;&gt;上一篇公告&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hi~ 访问我网站的小崽子们~&lt;/p&gt;
&lt;p&gt;想在评论区发言的同时留下
      
    
    </summary>
    
      <category term="公告" scheme="https://tth37.cn/categories/%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>题解-luogu-p5502最大公约数</title>
    <link href="https://tth37.cn/2019/08/23/solution-luogu-p5502/"/>
    <id>https://tth37.cn/2019/08/23/solution-luogu-p5502/</id>
    <published>2019-08-23T15:21:35.000Z</published>
    <updated>2019-08-23T15:23:12.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/P5502" target="_blank" rel="noopener">题目链接</a></p><p>咕咕咕</p></blockquote><a id="more"></a><p>对于求解区间权值 $=value *length$ 的最值问题时，我们通常可以枚举区间左端点，然后高效地找出右端点更新答案。</p><p>朴素的想法是枚举右端点 $r\in [l,n]$ 。根据显然的贪心策略，如果右端点在某一区间移动时，$\gcd(a_l,a_{l+1},…,a_r)$ 保持不变，则右端点越大越好。</p><p>因此可以用倍增优化右端点的确定。但是在倍增的过程中，需要多次查询区间最大公约数；我们可以用ST表的思路对序列预处理，做到 $O(1)$ 复杂度查询。</p><p>但是，如果已经确定左端点 $l$ ，不同的右端点选取会对应许多不同的最大公约数值，那么该算法的复杂度将无法承受。</p><p>稍加观察，可以发现当左端点确定时，右端点右移一个单位，原子段的最大公约数要么维持不变；要么变为原最大公约数的一个约数。换言之，当左端点确定时，不同的右端点最多对应 $\log_2n$ 个不同的最大公约数值。算法复杂度得以控制在 $O(n(\log n)^2)$ 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N;</span><br><span class="line">ll ans;</span><br><span class="line">ll a[<span class="number">100005</span>];</span><br><span class="line">ll st[<span class="number">100005</span>][<span class="number">18</span>];</span><br><span class="line"><span class="keyword">int</span> lg[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> gcd(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100000</span>; ++i)</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;st[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[N]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= N; ++i)</span><br><span class="line">            st[i][j] = gcd(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N; ++l) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= N) &#123;</span><br><span class="line">            ll cur = query(l, r);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = lg[N]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r + (<span class="number">1</span> &lt;&lt; i) &lt;= N &amp;&amp; query(l, r + (<span class="number">1</span> &lt;&lt; i)) == cur)</span><br><span class="line">                    r += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, cur * (r - l + <span class="number">1</span>));</span><br><span class="line">            r += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/P5502&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;咕咕咕&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="倍增" scheme="https://tth37.cn/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="ST算法" scheme="https://tth37.cn/tags/ST%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-uva11021麻球繁衍</title>
    <link href="https://tth37.cn/2019/08/23/solution-luogu-uva11021/"/>
    <id>https://tth37.cn/2019/08/23/solution-luogu-uva11021/</id>
    <published>2019-08-23T14:11:12.000Z</published>
    <updated>2019-08-23T14:22:20.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problem/UVA11021" target="_blank" rel="noopener">题目链接</a></p><p>有 $k$ 只麻球，每只活一天就会死亡，临死前可能会生出一些新的麻球。具体来说，生 $i$ 只麻球的概率为 $P_i$ 。给定 $m$ ，求 $m$ 天后所有麻球均死亡的概率。</p><p>我感谢我自己</p></blockquote><a id="more"></a><p>每只麻球均可视为一个独立的问题。设 $f[i]$ 表示第一天只有 $1$ 只麻球，在第 $i$ 天它及它的后代全部死亡的概率。由全概率公式，有</p><script type="math/tex; mode=display">f[i]=P_0+P_1f[i-1]+P_2f[i-1]^2+P_3f[i-1]^3+...+P_{n-1}f[i-1]^{n-1}</script><p>其中 $P_jf[i-j]^j$ 的含义是这个麻球生了 $j$ 个后代，并且它们在 $i-1$ 天后全部死亡的概率。由于一开始有 $k$ 只麻球，最终答案为 $f[m]^k$ 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N, K, M;</span><br><span class="line"><span class="keyword">double</span> P[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; ++Case) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; P[i];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">f[i] += P[j] * <span class="built_in">pow</span>(f[i - <span class="number">1</span>], j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; Case &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">8</span>) &lt;&lt; <span class="built_in">pow</span>(f[M], K) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problem/UVA11021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有 $k$ 只麻球，每只活一天就会死亡，临死前可能会生出一些新的麻球。具体来说，生 $i$ 只麻球的概率为 $P_i$ 。给定 $m$ ，求 $m$ 天后所有麻球均死亡的概率。&lt;/p&gt;
&lt;p&gt;我感谢我自己&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="概率" scheme="https://tth37.cn/tags/%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2279消防局的设立</title>
    <link href="https://tth37.cn/2019/08/19/solution-luogu-p2279/"/>
    <id>https://tth37.cn/2019/08/19/solution-luogu-p2279/</id>
    <published>2019-08-18T16:24:39.000Z</published>
    <updated>2019-08-26T10:04:49.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener">题目链接</a></p><p>给定一棵有 $n$ 个节点的树，求至少需要标记多少个点使得树上任意两个点的距离均小于等于 $2$</p><p>$n \le 1000$</p><p>感谢@oy的贡献</p></blockquote><a id="more"></a><p>实际上就是<a href="https://www.luogu.org/problem/P3267" target="_blank" rel="noopener">这道题</a>的简化版。</p><p>首先定义状态。$f[u][4]$ 表示节点 $u$ 的二级祖先（父亲的父亲）及以下节点被完全覆盖，所需的最小代价。$f[u][3]$ 表示节点 $u$ 的一级祖先及以下节点被完全覆盖所需最小代价。以此类推， $f[u][0]$ 表示节点 $u$ 的二级儿子（儿子的儿子）及以下节点被完全覆盖所需的最小代价。</p><p>考虑 $f[u][4]$ 的推导。由于每个节点被选中后只能覆盖到与其距离小于等于二的节点，要使 $u$ 的二级祖先被覆盖到，则节点 $u$ 必须被选取。对节点 $u$ 的各个儿子没有要求。因此，$f[u][4]=1+\Sigma f[v][0…4]$ 。</p><p>考虑 $f[u][3]$。由于只需要覆盖到节点 $u$ 的父亲，只需使节点 $u$ 的<strong>至少一个</strong>子节点可以覆盖到其二级祖先即可。同时，该子节点在覆盖到节点 $u$ 的二级祖先时，可以同时覆盖到节点 $u$  的其他儿子，因此节点 $u$ 的其他儿子不必被覆盖。$f[u][3]=f[k][4]+\Sigma f[v][1…4]$。</p><p>$f[u][2]$ 的情况与 $f[u][3]$ 类似，只需保证一个儿子能将节点 $u$ 覆盖即可。 $f[u][2]=f[k][3]+\Sigma f[v][2…4]$ 。</p><p>$f[u][1]$ 与 $f[u][0]$ 的推导相对简单，因为各个子节点之间不会相互影响。 $f[u][1]=\Sigma f[v][2…4]$，$f[u][0]=\Sigma f[v][1…4]$。</p><p>对转移方程进行简单优化即可。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">f[u][<span class="number">3</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">f[u][<span class="number">2</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">f[u][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = *it;</span><br><span class="line"><span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dp(v, u);</span><br><span class="line">f[u][<span class="number">0</span>] += f[v][<span class="number">1</span>];</span><br><span class="line">f[u][<span class="number">1</span>] += f[v][<span class="number">2</span>];</span><br><span class="line">f[u][<span class="number">2</span>] = min(f[u][<span class="number">2</span>], f[v][<span class="number">3</span>] - f[v][<span class="number">2</span>]);</span><br><span class="line">f[u][<span class="number">3</span>] = min(f[u][<span class="number">3</span>], f[v][<span class="number">4</span>] - f[v][<span class="number">1</span>]);</span><br><span class="line">f[u][<span class="number">4</span>] += f[v][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">f[u][<span class="number">2</span>] += f[u][<span class="number">1</span>];</span><br><span class="line">f[u][<span class="number">3</span>] += f[u][<span class="number">0</span>];</span><br><span class="line">f[u][<span class="number">3</span>] = min(f[u][<span class="number">3</span>], f[u][<span class="number">4</span>]);</span><br><span class="line">f[u][<span class="number">2</span>] = min(f[u][<span class="number">2</span>], f[u][<span class="number">3</span>]);</span><br><span class="line">f[u][<span class="number">1</span>] = min(f[u][<span class="number">1</span>], f[u][<span class="number">2</span>]);</span><br><span class="line">f[u][<span class="number">0</span>] = min(f[u][<span class="number">0</span>], f[u][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">2</span>; u &lt;= N; ++u) &#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">dp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2279&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵有 $n$ 个节点的树，求至少需要标记多少个点使得树上任意两个点的距离均小于等于 $2$&lt;/p&gt;
&lt;p&gt;$n \le 1000$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-Pólya计数与Burnside引理</title>
    <link href="https://tth37.cn/2019/08/13/algorithm-polya/"/>
    <id>https://tth37.cn/2019/08/13/algorithm-polya/</id>
    <published>2019-08-12T17:00:09.000Z</published>
    <updated>2019-08-12T18:50:14.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>如果题目中定义一种等价关系，满足等价关系的元素被看成同一类，只统计一次；这样的问题称为<strong>等价类计数问题</strong>。一般的等价类计数问题可以用 Burnside 引理或 Pólya定理解决。</p><a id="more"></a><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h4><p>置换实际上就是一一映射，$f$ 可以看成定义域和值域为 $\lbrace 1,2,3,…,n\rbrace$ 的函数，其中 $f(1)=a_1$， $f(2)=a_2$ 等等。</p><script type="math/tex; mode=display">f=\left(\begin{array}{cccc}     1&2&...&n \\     a_1&a_2&...&a_n \\ \end{array}\right)</script><h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><p>如果</p><script type="math/tex; mode=display">f=\left(\begin{array}{cccc}     1&2&...&n \\     a_1&a_2&...&a_n \\ \end{array}\right)</script><p>且</p><script type="math/tex; mode=display">g=\left(\begin{array}{cccc}     1&2&...&n \\     b_1&b_2&...&b_n \\ \end{array}\right)</script><p>是 $\lbrace 1,2,3,…,n\rbrace$  的两个置换，则他们的<strong>复合</strong>按照先 $f$ 后 $g$ 的顺序放置得到一个新置换：</p><script type="math/tex; mode=display">g\circ f=\left(\begin{array}{cccc}     1&2&...&n \\\    a_1&a_2&...&a_n \\\end{array}\right)\circ\left(\begin{array}{cccc}     1&2&...&n \\     b_1&b_2&...&b_n \\ \end{array}\right)</script><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>为了处理方便，常常把置换分解成<strong>循环</strong>的乘积，其中每个循环代表一些元素“循环移位”。比如 $(1,4,3)$ 这个循环表示 $1\rightarrow 4$，$4\rightarrow 3$，$3\rightarrow 1$。</p><p>易证任意置换都可以分解为循环乘积的形式。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>在 2*2 方格中涂黑白两色，方格允许旋转，有几种方法？</p></blockquote><p>假设不考虑方格允许旋转，则共有 16 种上色方案。本题中“旋转后相同”即为一个等价关系，有了等价关系，所有元素会被分为若干个<strong>等价类</strong>，我们需要统计的即为等价类的个数。</p><p>对于一个置换 $f$ ，若一个着色方案 $s$ 经过置换后不变，称 $s$ 为 $f$ 的<strong>不动点</strong>。将 $f$ 的不动点数目记为 $C(f)$，则可以证明<strong>等价类数目为置换群中所有 $C(f)$ 的平均值</strong>。此结论称为 Burnside 引理。</p><p>一般地，如果置换 $f$ 被分解为 $m(f)$ 个循环的乘积，那么每个循环内所有位置的颜色必须相同，假设涂 $k$ 种颜色，则有 $C(f)=k^{m(f)}$。带入 Burnside 引理的表达式之后得到 Pólya 定理：<strong>等价类的个数等于置换群种所有置换 $f$ 的 $k^{m(f)}$ 的平均数</strong>。 </p><blockquote><p>将 $t$ 种颜色的 $n$ 个小球排成一个环，允许旋转和翻转，有几种方法？</p></blockquote><p>首先考虑旋转置换。记置换 $f_i$ 为将环形顺时针旋转 $i$ 个单位长度。显然，$m(f_i)=gcd(i,n)$ 。</p><p>其次考虑翻转置换。当 $n$ 为奇数时，$|G|=n$，且 $m(f)=(n-1)/2+1$；当 $n$ 为偶数时，$|G|=n$，且 $m(f)=n/2+1$。</p><p>记：</p><script type="math/tex; mode=display">a=\Sigma_{i=0}^{n-1} t^{gcd(i,n)}\\b=\begin{cases}t^{(n-1)/2+1} , n=2k+1\\t^{n/2+1},n=2k\end{cases}</script><p>最终答案 $ans=(a+b)/2n$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;如果题目中定义一种等价关系，满足等价关系的元素被看成同一类，只统计一次；这样的问题称为&lt;strong&gt;等价类计数问题&lt;/strong&gt;。一般的等价类计数问题可以用 Burnside 引理或 Pólya定理解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://tth37.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="群论" scheme="https://tth37.cn/tags/%E7%BE%A4%E8%AE%BA/"/>
    
      <category term="Pólya计数" scheme="https://tth37.cn/tags/Polya%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-KMP模式匹配</title>
    <link href="https://tth37.cn/2019/08/07/algorithm-kmp/"/>
    <id>https://tth37.cn/2019/08/07/algorithm-kmp/</id>
    <published>2019-08-07T12:06:38.000Z</published>
    <updated>2019-08-31T04:05:52.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>给定一个文本 $A$ 和一个字符串 $B$ ，我们可以利用 KMP 算法尝试找到并展示 $B$ 在 $A$ 中的所有出现（occurrence）。</p><a id="more"></a><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="预处理前缀函数"><a href="#预处理前缀函数" class="headerlink" title="预处理前缀函数"></a>预处理前缀函数</h4><p>预处理出字符串 $B$ 的前缀函数 $next$ 数组，其中 $next[i]$ 为<strong>既是子串 $B[1…i]$ 的前缀同时也是该子串的后缀的最长真前缀</strong>长度。一个字符串的真前缀是其前缀但不等于该字符串本身。根据定义， $next[1]=0$ 。</p><h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><blockquote><ol><li>在循环中以 $i=2$ 到 $i=n$的顺序计算前缀函数 $next[i]$ 的值。（$next[1]$ 被赋值为0）</li><li>为了计算当前的前缀函数值 $next[i]$，我们令变量 $j$ 表示右端点位于 $i-1$  的最长匹配前后缀的长度。初始时 $j=next[i-1]$ 。</li><li>通过比较 $B[j+1]$ 和 $B[i]$ 来检查长度为 $j+1$ 的后缀是否同时也是一个前缀。如果二者相等，那么置 $next[i]=j+1$，否则减少 $j$ 至 $next[j]$ 并重复该过程。</li><li>如果 $j=0$ 并且仍没有任何一次匹配，则置 $next[i]=0$ 并移至下一个下标 $i+1$ 。</li></ol></blockquote><h5 id="F-A-Q"><a href="#F-A-Q" class="headerlink" title="F.A.Q"></a>F.A.Q</h5><p><em>算法流程中的步骤三，为什么要将 $j$ 减少至 $next[j]$ ？</em></p><p>考虑我们正在计算的 $next[i]$ 。我们要使 $k$ 最大化，并且保证 $B[1…k]$ 与 $B[i-k+1…i]$ 相等。将其拆成两部分看，我们需要在 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等的同时，保证 $B[k]=B[i]$ ，且 $k$ 取到最大值。</p><p>不难发现，如果只需要最大化 $k-1$ 使得 $B[1…k-1]$ 与 $B[i-k+1…i-1]$ 相等，我们可以很快得出答案。回顾一下前缀函数的定义即可发现，记 $j$ 为 $next[i-1]$，则此时的 $j$ 即为我们需要最大化的 $k-1$ 的值。如果这时又恰好满足 $B[j+1]=B[i]$ ，则我们需要最大化的 $k$ 即为 $j+1$ 。</p><p>然而此时如果不能满足 $B[j+1]=B[i]$ ，我们就只能考虑减小 $j$ 的值。<strong>在减小 $j$ 值的同时，我们要始终保证减小后的 $j’$ 满足 $B[1…j’]=B[j-j’+1…j]$ 。</strong></p><p><img src="http://tth37.cn/images/kmp.jpg" alt></p><p>结合上图不难看出，要使得 $B[1…j’]=B[i-j’…i-1]$，即保证 $B[1…j’]=B[j-j’+1…j]$ 。而 $j’$ 的确定也十分简单，再次结合前缀函数的定义可得， $j’$ 的取值应为 $next[j]$ 。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; B[i] != B[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (B[i] == B[j + <span class="number">1</span>]) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在目标串中查找子串"><a href="#在目标串中查找子串" class="headerlink" title="在目标串中查找子串"></a>在目标串中查找子串</h4><p>计算出 $f$ 数组，其中 $f[i]$ 为<strong>既是子串 $B[1…i]$ 的前缀同时也是子串 $A[1…i]$ 的后缀的最长前缀</strong>长度。<strong>（注意这里不一定是真前缀）</strong>在预处理前缀函数的过程中，相当于 $B$ 串与自己本身做了一次模式匹配，因此此处的算法流程与上一个操作十分类似。</p><h5 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h5><blockquote><ol><li>在循环中以 $i=1$ 到 $i=n$的顺序计算 $f[i]$ 的值。</li><li>为了计算当前的 $f[i]$ ，我们令变量 $j$ 表示右端点位于 $i-1$ 的最长匹配前后缀的长度。初始时 $j=f[i-1]$ 。</li><li>通过比较 $B[j+1]$ 和 $A[i]$ 来检查 $B$ 串中长度为 $j+1$ 的前缀是否也是 $A$ 串中长度为 $j+1$ 的后缀。如果二者相等，那么置 $f[i]=j+1$，否则减少 $j$ 至 $next[j-1]$ 并重复该过程。</li><li>如果 $j=0$ 并且仍没有任何一次匹配，则置 $f[i]=0$ 并移至下一个下标 $i+1$ 。</li><li>如果 $j=M$，即找到 $B$ 在 $A$ 中的一次出现。</li></ol></blockquote><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; A[i] != B[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (A[i] == B[j + <span class="number">1</span>]) j++;</span><br><span class="line">    f[i] = p;</span><br><span class="line">    <span class="comment">// if (f[i] == M) do something... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;给定一个文本 $A$ 和一个字符串 $B$ ，我们可以利用 KMP 算法尝试找到并展示 $B$ 在 $A$ 中的所有出现（occurrence）。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="字符串" scheme="https://tth37.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>CF游记-Codeforces Round</title>
    <link href="https://tth37.cn/2019/08/01/codeforces-1199/"/>
    <id>https://tth37.cn/2019/08/01/codeforces-1199/</id>
    <published>2019-08-01T15:21:39.000Z</published>
    <updated>2019-08-01T15:49:39.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/contest/1199" target="_blank" rel="noopener">比赛链接</a></p></blockquote><p>人生第二次觉得CF的题还是可做的。目前只弄了5道，剩下一题咕着。</p><a id="more"></a><h5 id="A-City-Day"><a href="#A-City-Day" class="headerlink" title="#A City Day"></a>#A <a href="https://codeforces.com/contest/1199/problem/A" target="_blank" rel="noopener">City Day</a></h5><p>简单模拟，开心的话可以写个单调队列。</p><h5 id="B-Water-Lily"><a href="#B-Water-Lily" class="headerlink" title="#B Water Lily"></a>#B <a href="https://codeforces.com/contest/1199/problem/B" target="_blank" rel="noopener">Water Lily</a></h5><p>初中数学题，勾股定理。</p><script type="math/tex; mode=display">(x+H)^2=x^2+L^2 \\ x=(L^2-H^2)/2H</script><h5 id="C-MP3"><a href="#C-MP3" class="headerlink" title="#C MP3"></a>#C <a href="https://codeforces.com/contest/1199/problem/C" target="_blank" rel="noopener">MP3</a></h5><p>既然硬盘的大小是固定的，那么 $K$ 应该尽可能大。为了让 $K$ 尽可能大， $k$ 也要尽可能大。</p><p>所以：</p><script type="math/tex; mode=display">k=\lfloor(I*8)/n\rfloor \\ K=2^k</script><p>把 $K$ 求出来之后，我们实际上只需保留 $K$ 种不同的数字，并使删除的数字最少。</p><p>根据题意，我们只能删除最大的或最小的数。考虑对 $a$ 数组离散化，并用 $b$ 数组记录每个数值出现的次数。保留下来的数值一定是<strong>连续的$K$个</strong>，只需在 $b$数组上进行前缀和预处理，枚举保留的 $K$ 个数值位置即可。</p><h5 id="D-Welfare-State"><a href="#D-Welfare-State" class="headerlink" title="#D Welfare State"></a>#D <a href="https://codeforces.com/contest/1199/problem/D" target="_blank" rel="noopener">Welfare State</a></h5><p>非主流警告⚠</p><p>观察到只有一次查询，所以我们可以针对每个位置，求出当前位置在经过 $q$ 次操作后的值并输出。</p><p>先来看两个结论：</p><blockquote><p>可以忽略对当前位置的<strong>最后一次一号操作</strong>之前的所有操作。</p></blockquote><p>管你之前被改成什么了，经过一次一号操作就得重新来过。</p><blockquote><p>对于<strong>连续的几次二号操作</strong>，只需保留 $x$ 最大的那一次操作。</p></blockquote><p>废话。</p><p>本题中二号操作是针对整体的，所以考虑开数组 $s$ 记录所有二号操作的<strong>后缀最大值</strong>。在针对每一位置进行计算时，只需将最后一次一号操作之前的操作删除后，与二号操作的后缀最大值比较即可得出答案。</p><h5 id="E-Matching-vs-Independent-Set"><a href="#E-Matching-vs-Independent-Set" class="headerlink" title="#E Matching vs Independent Set"></a>#E <a href="https://codeforces.com/contest/1199/problem/E" target="_blank" rel="noopener">Matching vs Independent Set</a></h5><h5 id="F-Rectangle-Painting-1"><a href="#F-Rectangle-Painting-1" class="headerlink" title="#F Rectangle Painting 1"></a>#F <a href="https://codeforces.com/contest/1199/problem/F" target="_blank" rel="noopener">Rectangle Painting 1</a></h5><p>超水的一道 F 题！</p><p>$f[x1][y1][x2][y2]$表示将一个矩形全部涂成白色的最小费用，状态转移考虑由两个子矩形合并或将一整块上色即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人生第二次觉得CF的题还是可做的。目前只弄了5道，剩下一题咕着。&lt;/p&gt;
    
    </summary>
    
      <category term="CF游记" scheme="https://tth37.cn/categories/CF%E6%B8%B8%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法学习-splay伸展树</title>
    <link href="https://tth37.cn/2019/07/24/algorithm-splay/"/>
    <id>https://tth37.cn/2019/07/24/algorithm-splay/</id>
    <published>2019-07-23T17:21:01.000Z</published>
    <updated>2019-08-27T05:03:11.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文部分内容转载自 <a href="https://oi-wiki.org/ds/splay/" target="_blank" rel="noopener">OI Wiki Splay</a></p><p>$\LaTeX$ 就先咕着吧……有时间慢慢搞</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Splay是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，它由 Daniel Sleator 和 Robert Tarjan 发明。</p><a id="more"></a><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="节点维护信息"><a href="#节点维护信息" class="headerlink" title="节点维护信息"></a>节点维护信息</h3><ul><li>root 根节点编号</li><li>cnt 节点个数</li><li>node[] 节点内部信息<ul><li>fa 父亲</li><li>ch[0/1] 左右儿子编号</li><li>val 节点权值</li><li>cnt 权值出现次数</li><li>sum 子树大小</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa, ch[<span class="number">2</span>], val, cnt, sum;</span><br><span class="line">&#125;node[MAXN];</span><br><span class="line"><span class="keyword">int</span> root, cnt;</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>update(u) 在改变节点位置后，将节点u的sum值更新</li><li>identify(u) 判断节点u是父亲的左儿子还是右儿子</li><li>clear(u) 销毁节点u</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    node[u].sum = node[u].cnt + node[node[u].ch[<span class="number">0</span>]].sum + node[node[u].ch[<span class="number">1</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">identify</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == node[node[u].fa].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    node[u].fa = node[u].ch[<span class="number">0</span>] = node[u].ch[<span class="number">1</span>] = node[u].val = node[u].cnt = node[u].sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><ul><li>connect(u, f, p) 将u连接在f的下方，连接方向为p</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    node[u].fa = f;</span><br><span class="line">    node[f].ch[p] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>分析咕咕咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = node[x].fa;</span><br><span class="line">    <span class="keyword">int</span> r = node[y].fa;</span><br><span class="line">    <span class="keyword">int</span> rp = identify(y);</span><br><span class="line">    <span class="keyword">int</span> yp = identify(x);</span><br><span class="line">    <span class="keyword">int</span> b = node[x].ch[yp ^ <span class="number">1</span>];</span><br><span class="line">    connect(b, y, yp);</span><br><span class="line">    connect(y, x, yp ^ <span class="number">1</span>);</span><br><span class="line">    connect(x, r, rp);</span><br><span class="line">    update(y), update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>旋转需要保证：</strong></p><ul><li>平衡树的中序遍历不变（不能破坏BST的性质）</li><li>受影响的节点维护的信息依然正确有效</li><li>root必须指向旋转后的根节点</li></ul><p><img src="https://cdn.luogu.org/upload/pic/4410.png" alt="如果你能看到这行字，就说明图片爆炸了"></p><p><img src="https://cdn.luogu.org/upload/pic/4411.png" alt="如果你能看到这行字，就说明图片爆炸了"></p><p><strong>具体分析旋转步骤（假设需要旋转的节点为x，其父亲为y，以右旋为例）：</strong></p><ol><li>将y的左儿子指向x的右儿子，且x的右儿子的父亲指向y</li><li>将x的右儿子指向y，且y的父亲指向x</li><li>如果原来的y还有父亲z，那么把z的某个儿子（原来y所在的儿子位置）指向x，且x的父亲指向z</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = node[x].fa, z = node[y].fa, p = identify(x);</span><br><span class="line">    node[y].ch[p] = node[x].ch[p ^ <span class="number">1</span>];</span><br><span class="line">    node[node[x].ch[p ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    node[x].ch[p ^ <span class="number">1</span>] = y;</span><br><span class="line">    node[y].fa = x;</span><br><span class="line">    node[x].fa = z;</span><br><span class="line">    <span class="keyword">if</span> (z) node[z].ch[y == node[z].ch[<span class="number">1</span>]] = x;</span><br><span class="line">    update(y);</span><br><span class="line">    update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="Splay 操作"></a>Splay 操作</h3><p>Splay规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为6种情况讨论（其中x为需要旋转到根的节点）</p><p><img src="https://oi-wiki.org/ds/images/splay1.png" alt></p><p>分析咕咕咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f = node[x].fa; f = node[x].fa, f; rotate(x)) </span><br><span class="line">        <span class="keyword">if</span> (node[f].fa &amp;&amp; identify(x) == identify(f)) rotate(f);</span><br><span class="line">   root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>分析咕咕咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>) &#123;</span><br><span class="line">        node[++cnt].val = val;</span><br><span class="line">        node[cnt].cnt++;</span><br><span class="line">        root = cnt;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = root, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[cur].val == val) &#123;</span><br><span class="line">            node[cur].cnt++;</span><br><span class="line">            update(cur);</span><br><span class="line">            update(f);</span><br><span class="line">            splay(cur);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = cur, cur = node[cur].ch[node[cur].val &lt; k];</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">            node[++cnt].val = val;</span><br><span class="line">            node[cnt].cnt++;</span><br><span class="line">            node[cnt].fa = f;</span><br><span class="line">            node[f].ch[node[f].val &lt; k] = cnt;</span><br><span class="line">            update(cnt);</span><br><span class="line">            update(f);</span><br><span class="line">            splay(cnt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询x的排名"><a href="#查询x的排名" class="headerlink" title="查询x的排名"></a>查询x的排名</h3><p>分析咕咕咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryid</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cur = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; node[cur].val) cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += node[node[cur].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (val == node[cur].val) &#123;</span><br><span class="line">                splay(cur);</span><br><span class="line">                <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += node[cur].cnt;</span><br><span class="line">            cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询排名为k的数"><a href="#查询排名为k的数" class="headerlink" title="查询排名为k的数"></a>查询排名为k的数</h3><p>分析咕咕咕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryrid</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node[cur].ch[<span class="number">0</span>] &amp;&amp; k &lt;= node[node[cur].ch[<span class="number">0</span>]].sum) cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= node[cur].cnt + node[node[cur].ch[<span class="number">0</span>]].sum;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> node[cur].val;</span><br><span class="line">            cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前驱"><a href="#查询前驱" class="headerlink" title="查询前驱"></a>查询前驱</h3><p>分析古古古</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querypre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    insert(val);</span><br><span class="line">    <span class="keyword">int</span> cur = node[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (node[cur].ch[<span class="number">1</span>]) cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">    delet(val);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询后继"><a href="#查询后继" class="headerlink" title="查询后继"></a>查询后继</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querynxt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    insert(val);</span><br><span class="line">    <span class="keyword">int</span> cur = node[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (node[cur].ch[<span class="number">0</span>]) cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">    delet(val);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    queryid(val);</span><br><span class="line">    <span class="keyword">if</span> (node[root].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node[root].cnt--;</span><br><span class="line">        update(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node[root].ch[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; node[root].ch[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        clear(root);</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node[root].ch[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = root;</span><br><span class="line">        root = node[root].ch[<span class="number">0</span>];</span><br><span class="line">        node[root].fa = <span class="number">0</span>;</span><br><span class="line">        clear(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node[root].ch[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = root;</span><br><span class="line">        root = node[root].ch[<span class="number">1</span>];</span><br><span class="line">        node[root].fa = <span class="number">0</span>;</span><br><span class="line">        clear(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u = querypre(val), cur = root; <span class="comment">// ???</span></span><br><span class="line">    node[node[cur].ch[<span class="number">1</span>]].fa = u;</span><br><span class="line">    node[u].ch[<span class="number">1</span>] = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">    clear(cur);</span><br><span class="line">    update(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文部分内容转载自 &lt;a href=&quot;https://oi-wiki.org/ds/splay/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OI Wiki Splay&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$\LaTeX$ 就先咕着吧……有时间慢慢搞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Splay是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，它由 Daniel Sleator 和 Robert Tarjan 发明。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据结构" scheme="https://tth37.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="https://tth37.cn/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p3275糖果</title>
    <link href="https://tth37.cn/2019/07/23/solution-luogu-p3275/"/>
    <id>https://tth37.cn/2019/07/23/solution-luogu-p3275/</id>
    <published>2019-07-23T15:28:24.000Z</published>
    <updated>2019-07-23T15:34:21.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3275" target="_blank" rel="noopener">题目链接</a></p><p>给定一个长度为$n$的序列以及$k$个条件，每个条件要求序列当中一个点的权值大于/小于/不大于/不小于/等于另一个点。求这个序列总和的最小值</p><p>$1 \le k,n \le 100000$</p><p>感谢@oy 的贡献</p></blockquote><a id="more"></a><p>差分约束系统的模板题。</p><p>记 $d$ 数组为以 $S$ 为源点到各个节点的最长路。根据最长路的性质，如果存在一条边 $(u,v,w)$ ，则一定满足以下不等式：</p><script type="math/tex; mode=display">d[u]+w(u,v)\le d[v]</script><p>我们可以将题目中给出的不等关系转化为图中的有向边，然后通过单源最长路求出的一组 $\lbrace d_n\rbrace$ 即为差分约束系统的一组解。</p><p>因此，在图中连一条边 $(u,v,w)$ 相当于对 $d[u]$ 和 $d[v]$ 的取值作出限制，我们只需在构造出一张有向图，并求出其单源最长路即为答案。</p><p>有向边的构造方式如下：</p><ol><li>限制 $d[A]=d[B]$</li></ol><script type="math/tex; mode=display">d[A]=d[B] \Leftrightarrow (d[B]\le d[A])\wedge(d[A]\le d[B])</script><script type="math/tex; mode=display">\Leftrightarrow (d[B]+0\le d[A])\wedge(d[A]+0\le d[B])</script><p>连边：$(A,B,0)$，$(B,A,0)$</p><ol><li>限制 $d[A]&lt;d[B]$<script type="math/tex; mode=display">d[A]<d[B]\Leftrightarrow d[A]+1\le d[B]</script></li></ol><p>连边：$(A,B,1)$</p><ol><li>限制 $d[A]\geq d[B]$<script type="math/tex; mode=display">d[A]\ge d[B]\Leftrightarrow d[B]+0\le d[A]</script></li></ol><p>连边：$(B,A,0)$</p><ol><li>限制 $d[A]&gt;d[B]$<script type="math/tex; mode=display">d[A]>d[B]\Leftrightarrow d[B]+1\le d[A]</script></li></ol><p>连边：$(B,A,1)$</p><ol><li>限制 $d[A]\le d[B]$</li></ol><p>连边：$(A,B,0)$</p><ol><li>限制 $d[i]&gt;0$</li></ol><p>连边：$(S,i,1)$</p><p>连完所有的边后，跑一遍单源最长路；如果存在正环则输出无解。</p><p>统计答案时记得开$long$ $long$。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> die &#123;puts(<span class="meta-string">"-1"</span>); exit(0);&#125;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w;</span><br><span class="line">Edge(<span class="keyword">int</span> v, <span class="keyword">int</span> w) &#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; v = v, <span class="keyword">this</span> -&gt; w = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN], cnt[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">G[u].push_back(Edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(N + <span class="number">1</span>);</span><br><span class="line">d[N + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">inq[N + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (cnt[u] &gt;= N) die</span><br><span class="line">cnt[u]++;</span><br><span class="line">inq[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = it -&gt; v, w = it -&gt; w;</span><br><span class="line"><span class="keyword">if</span> (d[u] + w &gt; d[v]) &#123;</span><br><span class="line">d[v] = d[u] + w;</span><br><span class="line"><span class="keyword">if</span> (inq[v] == <span class="number">0</span>) &#123;</span><br><span class="line">inq[v] = <span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;K);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> X, A, B;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;X, &amp;A, &amp;B);</span><br><span class="line"><span class="keyword">switch</span> (X) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">AddEdge(A, B, <span class="number">0</span>);</span><br><span class="line">AddEdge(B, A, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> (A == B) die</span><br><span class="line">AddEdge(A, B, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">AddEdge(B, A, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span> (A == B) die</span><br><span class="line">AddEdge(B, A, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">AddEdge(A, B, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">AddEdge(N + <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">SPFA();</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">ans += d[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3275&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为$n$的序列以及$k$个条件，每个条件要求序列当中一个点的权值大于/小于/不大于/不小于/等于另一个点。求这个序列总和的最小值&lt;/p&gt;
&lt;p&gt;$1 \le k,n \le 100000$&lt;/p&gt;
&lt;p&gt;感谢@oy 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="最短路" scheme="https://tth37.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="差分约束系统" scheme="https://tth37.cn/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p4175网络管理</title>
    <link href="https://tth37.cn/2019/07/21/solution-luogu-p4175/"/>
    <id>https://tth37.cn/2019/07/21/solution-luogu-p4175/</id>
    <published>2019-07-21T14:42:33.000Z</published>
    <updated>2019-07-23T15:35:15.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4175" target="_blank" rel="noopener">题目链接</a></p><p>给定一棵$n$个节点的树，进行$q$次操作：单点修改，或查询一条树链上的第$k$小值。</p><p>$n,q \le 80000,0 \le k \le n$</p><p>感谢@oy的贡献</p></blockquote><a id="more"></a><p>思路：树链剖分+树状数组套主席树</p><p>考虑到权值线段树自带buff——整体二分，不难想到对树链上的权值线段树求和，并在合并后的权值线段树上求第 $k$ 大即可愉快地解决本题。</p><p>在树链上的求和操作可以用树剖加线性数据结构进行维护。本题需要支持的操作只有单点修改和区间查询，所以可以用树状数组套主席树维护 dfs 序上的信息。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) (lower_bound(b + 1, b + L + 1, x) - b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid(x) (b[x])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (node[x].l)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (node[x].r)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) (node[x].sum)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">80005</span> * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opt</span> &#123;</span><span class="keyword">int</span> k, a, b;&#125; op[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum;</span><br><span class="line">    Node() &#123;l = r = sum = <span class="number">0</span>;&#125;</span><br><span class="line">&#125; node[MAXN * <span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> c[MAXN], cnt;</span><br><span class="line"><span class="keyword">int</span> N, Q, L;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">int</span> q1[MAXN], q2[MAXN], len1, len2;</span><br><span class="line"><span class="keyword">int</span> dep[MAXN], dfn[MAXN], f[MAXN], son[MAXN], top[MAXN], size[MAXN], dfn_idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>) u = ++cnt;</span><br><span class="line">    sum(u) += val;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) insert(lson(u), l, mid, p, val);</span><br><span class="line">    <span class="keyword">else</span> insert(rson(u), mid + <span class="number">1</span>, r, p, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; u &lt;= N; u += lowbit(u)) insert(c[u], <span class="number">1</span>, L, p, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u] = fa;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        <span class="keyword">if</span> (size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topc)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfn_idx;</span><br><span class="line">    top[u] = topc;</span><br><span class="line">    modify(dfn[u], t[u], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], topc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == son[u] || v == f[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_bin</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>* a, <span class="keyword">int</span>&amp; len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; u &gt;= <span class="number">1</span>; u -= lowbit(u)) a[++len] = c[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    len1 = len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v);</span><br><span class="line">        pre_bin(dfn[u], q1, len1);</span><br><span class="line">        pre_bin(dfn[top[u]] - <span class="number">1</span>, q2, len2);</span><br><span class="line">        u = f[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    pre_bin(dfn[u], q1, len1);</span><br><span class="line">    pre_bin(dfn[v] - <span class="number">1</span>, q2, len2);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, rsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) rsum += sum(rson(q1[i]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i) rsum -= sum(rson(q2[i]));</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= rsum) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) q1[i] = rson(q1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i) q2[i] = rson(q2[i]);</span><br><span class="line">        <span class="keyword">return</span> query(mid + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i) q1[i] = lson(q1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len2; ++i) q2[i] = lson(q2[i]);</span><br><span class="line">        <span class="keyword">return</span> query(l, mid, k - rsum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]), b[++L] = t[i], c[i] = ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op[i].k, &amp;op[i].a, &amp;op[i].b);</span><br><span class="line">        <span class="keyword">if</span> (op[i].k == <span class="number">0</span>) b[++L] = op[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + L + <span class="number">1</span>);</span><br><span class="line">    L = unique(b + <span class="number">1</span>, b + L + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) t[i] = id(t[i]);</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = op[i].k, a = op[i].a, b_ = op[i].b;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            b_ = id(b_);</span><br><span class="line">            modify(dfn[a], t[a], <span class="number">-1</span>);</span><br><span class="line">            t[a] = b_;</span><br><span class="line">            modify(dfn[a], t[a], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = pre(a, b_);</span><br><span class="line">            <span class="keyword">int</span> maxk = dep[a] + dep[b_] - dep[lca] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (maxk &lt; k) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"invalid request!"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rid(query(<span class="number">1</span>, L, k)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4175&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵$n$个节点的树，进行$q$次操作：单点修改，或查询一条树链上的第$k$小值。&lt;/p&gt;
&lt;p&gt;$n,q \le 80000,0 \le k \le n$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="https://tth37.cn/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="树状数组" scheme="https://tth37.cn/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树套树" scheme="https://tth37.cn/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-树套树</title>
    <link href="https://tth37.cn/2019/07/21/algorithm-treeintree/"/>
    <id>https://tth37.cn/2019/07/21/algorithm-treeintree/</id>
    <published>2019-07-21T05:39:53.000Z</published>
    <updated>2019-07-23T17:23:55.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文部分内容转载自 <a href="https://oi-wiki.org/ds/persistent-in-bit/" target="_blank" rel="noopener">OI Wiki 树状数组套主席树</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>普通数据结构维护单一维度信息，树套树维护多维度信息。</p><a id="more"></a><h2 id="树状数组套权值线段树"><a href="#树状数组套权值线段树" class="headerlink" title="树状数组套权值线段树"></a>树状数组套权值线段树</h2><p>树状数组套权值线段树可以在 $O(n \log^2 n)$ 的时间复杂度解决动态区间 $k$ 小值问题。</p><p>如果用<a href="https://oi-wiki.org/ds/balanced-in-seg/" target="_blank" rel="noopener">线段树套平衡树</a>中所论述的，用线段树套平衡树，即对于线段树的每一个节点，对于其所表示的区间维护一个平衡树，然后用二分来查找 $k$ 小值。由于每次查询操作都要覆盖多个区间，即有多个节点，但是平衡树并不能多个值一起查找，所以时间复杂度是 $O(n\log^3 n)$，并不是最优的。</p><p>思路是，把二分答案的操作和查询小于一个值的数的数量两种操作结合起来。最好的方法是使用 <strong>线段树套主席树</strong> 。</p><p>说是主席树其实不准确，因为并不是对线段树的可持久化，各个线段树之间也没有像主席树各版本之间的强关联性，所以称为 <strong>动态开点权值线段树</strong> 更为确切。</p><p>思路类似于线段树套平衡树，即对于线段树所维护的每个区间，建立一个动态开点权值线段树，表示其所维护的区间的值。</p><p>在修改操作进行时，先在线段树上从上往下跳到被修改的点，删除所经过的点所指向的动态开点权值线段树上的原来的值，然后插入新的值，要经过 $O(\log n)$ 个线段树上的节点，在动态开点权值线段树上一次修改操作是 $O(\log n)$ 的，所以修改操作的时间复杂度为 $O(\log^2 n)$ 。</p><p>由于线段树的常数较大，在实现中往往使用常数更小且更方便处理前缀和的 <strong>树状数组</strong> 实现。</p><p>给出一种代码实现：<a href="https://www.luogu.org/problemnew/show/P2617" target="_blank" rel="noopener">luogu-p2617</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) (lower_bound(b + 1, b + L + 1, x) - b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid(x) (b[x])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span> * <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">op</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> opt;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, t;</span><br><span class="line">&#125;ops[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum;</span><br><span class="line">    Node() &#123;l = r = sum = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;node[MAXN * <span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, c[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, M, L;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">int</span> qr[MAXN], ql[MAXN], qrlen, qllen;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>) u = ++cnt;</span><br><span class="line">    node[u].sum += val;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) insert(node[u].l, l, mid, p, val);</span><br><span class="line">    <span class="keyword">else</span> insert(node[u].r, mid + <span class="number">1</span>, r, p, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; u &lt;= N; u += lowbit(u)) insert(c[u], <span class="number">1</span>, L, p, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>* a, <span class="keyword">int</span>&amp; len)</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; u &gt;= <span class="number">1</span>; u -= lowbit(u)) a[++len] = c[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qrlen; ++i) lsum += node[node[qr[i]].l].sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qllen; ++i) lsum -= node[node[ql[i]].l].sum;</span><br><span class="line">    <span class="keyword">if</span> (lsum &gt;= k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qllen; ++i) ql[i] = node[ql[i]].l;</span><br><span class="line">        <span class="keyword">return</span> query(l, mid, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qllen; ++i) ql[i] = node[ql[i]].r;</span><br><span class="line">        <span class="keyword">return</span> query(mid + <span class="number">1</span>, r, k - lsum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), b[++L] = a[i], c[i] = ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops[i].opt;</span><br><span class="line">        <span class="keyword">if</span> (ops[i].opt == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;ops[i].i, &amp;ops[i].j, &amp;ops[i].k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ops[i].i, &amp;ops[i].t);</span><br><span class="line">            b[++L] = ops[i].t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + L + <span class="number">1</span>);</span><br><span class="line">    L = unique(b + <span class="number">1</span>, b + L + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        a[i] = id(a[i]);</span><br><span class="line">        modify(i, a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops[i].opt == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            pre(ops[i].j, qr, qrlen);</span><br><span class="line">            pre(ops[i].i - <span class="number">1</span>, ql, qllen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rid(query(<span class="number">1</span>, L, ops[i].k)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            modify(ops[i].i, a[ops[i].i], <span class="number">-1</span>);</span><br><span class="line">            a[ops[i].i] = id(ops[i].t);</span><br><span class="line">            modify(ops[i].i, a[ops[i].i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续……等我学完平衡树再接着弄</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文部分内容转载自 &lt;a href=&quot;https://oi-wiki.org/ds/persistent-in-bit/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OI Wiki 树状数组套主席树&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;普通数据结构维护单一维度信息，树套树维护多维度信息。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据结构" scheme="https://tth37.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树状数组" scheme="https://tth37.cn/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-cf1195c Basketball Exercise</title>
    <link href="https://tth37.cn/2019/07/18/solution-luogu-cf1195c/"/>
    <id>https://tth37.cn/2019/07/18/solution-luogu-cf1195c/</id>
    <published>2019-07-18T13:15:10.000Z</published>
    <updated>2019-07-18T13:18:46.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/CF1195C" target="_blank" rel="noopener">题目链接</a></p><p>给定一个$2*n$的矩阵，从中选出若干数，且任意两个数不上下或左右相邻，求这些数的最大总和</p><p>$1\le n \le 100000,1 \le h_{i,j}\le 1000000000$</p></blockquote><a id="more"></a><p>很水的一道C题……目测难度在黄~绿左右。请各位切题者合理评分。</p><p>注意到可以选择的球员编号是严格递增的，因此可以把状态的第一维定义为球员编号，第二维描述编号同为 $i$ 的两名球员的选取情况。</p><p>定义状态：$f[i][0/1/2]$ 表示选取了编号在 $i$ 及以前的球员，所能得到的身高总和最大值。其中，第二维的 $0$ 表示编号为 $i$ 的球员一个都不选；$1$ 表示只选上面一个；$i$ 表示只选下面一个。（显然没有上下都选的情况）</p><p>状态转移方程：</p><script type="math/tex; mode=display">f[i][0]=max\lbrace f[i-1][0],f[i-1][1],f[i-1][2]\rbrace</script><script type="math/tex; mode=display">f[i][1]=max\lbrace f[i-1][0],f[i-1][2]\rbrace+height[i][1]</script><script type="math/tex; mode=display">f[i][2]=max\lbrace f[i-1][0],f[i-1][1]\rbrace+height[i][2]</script><p><strong>Update: 用贪心可以证明，在最优解中，不会出现连续两列一个不取的情况。因此， $f[i][0]$ 其实没有必要考虑来自 $f[i-1][0]$ 的状态转移。</strong></p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">ll h[<span class="number">100005</span>][<span class="number">3</span>];</span><br><span class="line">ll f[<span class="number">100005</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">cin</span> &gt;&gt; h[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">cin</span> &gt;&gt; h[i][<span class="number">2</span>];</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = h[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">2</span>] = h[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">        f[i][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]) + h[i][<span class="number">1</span>];</span><br><span class="line">        f[i][<span class="number">2</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]) + h[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(f[N][<span class="number">0</span>], max(f[N][<span class="number">1</span>], f[N][<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/CF1195C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个$2*n$的矩阵，从中选出若干数，且任意两个数不上下或左右相邻，求这些数的最大总和&lt;/p&gt;
&lt;p&gt;$1\le n \le 100000,1 \le h_{i,j}\le 1000000000$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-数论专题-卡特兰数</title>
    <link href="https://tth37.cn/2019/07/14/algorithm-maths-catalan/"/>
    <id>https://tth37.cn/2019/07/14/algorithm-maths-catalan/</id>
    <published>2019-07-13T16:10:52.000Z</published>
    <updated>2019-07-13T16:11:49.198Z</updated>
    
    <content type="html"><![CDATA[<p>咕咕咕~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;咕咕咕~&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数论专题" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%95%B0%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="卡特兰数" scheme="https://tth37.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1641生成字符串</title>
    <link href="https://tth37.cn/2019/07/13/solution-luogu-p1641/"/>
    <id>https://tth37.cn/2019/07/13/solution-luogu-p1641/</id>
    <published>2019-07-13T15:19:46.000Z</published>
    <updated>2019-07-13T15:33:00.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1641" target="_blank" rel="noopener">题目链接</a></p><p>将$n$个$1$和$m$个$0$组成字符串，使得在任意的前$k$个字符中，$1$的个数不能少于$0$的个数。求满足条件的字符串共有多少个。</p><p>$1\le m \le n \le 1000000$</p></blockquote><a id="more"></a><p>本题是卡特兰数的一个简单变式。</p><p>回忆卡特兰数的推导过程，可以生成的所有字符串共有$C_{n+m}^n$个，其中不合法的字符串有$C_{n+m}^{n+1}$个。最终答案即为$C_{n+m}^{n}-C_{n+m}^{n+1}$。计算组合数前须预处理出阶乘逆元。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">20100403</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">2000005</span>], fac[<span class="number">2000005</span>], facinv[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll) fac[n] * facinv[m] % p * facinv[n - m] % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>; fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>; facinv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N + M; ++i) &#123;</span><br><span class="line">        inv[i] = (ll) (p - p / i) * inv[p % i] % p;</span><br><span class="line">        fac[i] = (ll) i * fac[i - <span class="number">1</span>] % p;</span><br><span class="line">        facinv[i] = (ll) facinv[i - <span class="number">1</span>] * inv[i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (C(N + M, N) - C(N + M, N + <span class="number">1</span>) + p) % p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1641&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将$n$个$1$和$m$个$0$组成字符串，使得在任意的前$k$个字符中，$1$的个数不能少于$0$的个数。求满足条件的字符串共有多少个。&lt;/p&gt;
&lt;p&gt;$1\le m \le n \le 1000000$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="卡特兰数" scheme="https://tth37.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="逆元" scheme="https://tth37.cn/tags/%E9%80%86%E5%85%83/"/>
    
      <category term="组合数" scheme="https://tth37.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-数论专题-乘法逆元</title>
    <link href="https://tth37.cn/2019/07/13/algorithm-maths-multiplicativeinversion/"/>
    <id>https://tth37.cn/2019/07/13/algorithm-maths-multiplicativeinversion/</id>
    <published>2019-07-13T04:59:09.000Z</published>
    <updated>2019-07-13T08:34:13.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>乘法逆元定义：如果一个线性同余方程$ax\equiv 1 \mod b$，则$x$成为$a \mod b$的逆元，记作$a^{-1}$。</p></blockquote><p>乘法逆元一般用于求$a\/b\mod p$的值（$p$通常为质数），是解决模意义下分数数值的必要手段。</p><p>对于$a\/b\mod p$，我们可以求出$b$在$\mod p$下的逆元，然后乘上$a$再$\mod p$，就是这个分数的值了。</p><a id="more"></a><h2 id="求解逆元的方法"><a href="#求解逆元的方法" class="headerlink" title="求解逆元的方法"></a>求解逆元的方法</h2><h3 id="扩展欧几里得法"><a href="#扩展欧几里得法" class="headerlink" title="扩展欧几里得法"></a>扩展欧几里得法</h3><p>求解$ax\equiv 1 \mod b$ 等价于解不定方程 $ax+by=1$，求解出的$x$即为$a \mod b$的逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂法"><a href="#快速幂法" class="headerlink" title="快速幂法"></a>快速幂法</h3><blockquote><p>费马小定理</p><p>若$p$为质数，$a$为正整数，且$a$、$p$互质，则$a^{p-1}\equiv 1 (\mod p)$。</p></blockquote><p>因为$ax\equiv 1\mod b$</p><p>所以$ax\equiv a^{b-1}\mod b$</p><p>所以$x\equiv a^{b-2}\mod b$</p><p>然后可以使用快速幂求解逆元。</p><p>代码略。</p><h3 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h3><p>假设现在要求$inv[i]$。</p><p>考虑带余除法，设$p=iq+r$，则有$iq+r\equiv 0\mod p$</p><p>注意到$p$是质数，因此$r$不为$0$，$r$的逆元存在</p><p>等式两边乘$i^{-1}r^{-1}$，得到$qr^{-1}+i^{-1}\equiv 0\mod p$</p><p>因此$i^{-1}\equiv -qr^{-1}\equiv -(p\/i)(p \mod i)^{-1}\mod p$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (inv[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = (p - p / i) * inv[p % i] % p;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;乘法逆元定义：如果一个线性同余方程$ax\equiv 1 \mod b$，则$x$成为$a \mod b$的逆元，记作$a^{-1}$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乘法逆元一般用于求$a\/b\mod p$的值（$p$通常为质数），是解决模意义下分数数值的必要手段。&lt;/p&gt;
&lt;p&gt;对于$a\/b\mod p$，我们可以求出$b$在$\mod p$下的逆元，然后乘上$a$再$\mod p$，就是这个分数的值了。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数论专题" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%95%B0%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="乘法逆元" scheme="https://tth37.cn/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p5021赛道修建</title>
    <link href="https://tth37.cn/2019/07/13/solution-luogu-p5021/"/>
    <id>https://tth37.cn/2019/07/13/solution-luogu-p5021/</id>
    <published>2019-07-12T16:54:10.000Z</published>
    <updated>2019-07-18T13:13:16.561Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">题目链接</a></p><p>给定一个有$n$个节点的树，在其中选出$m$条没有公共边的路径，并使得$m$条路径中最短路径的长度尽可能大。输出这个最短路径的长度。</p><p>$2\le n \le 50000,1\le m\le n-1 $</p></blockquote><a id="more"></a><p>题目要求使$m$条赛道中最短赛道的长度尽可能大，不难想到二分最短赛道的长度$len$，并判定是否能修建出$m$条赛道。</p><p>定义$f[u]$为自节点$u$向下延伸的<strong>不作为赛道</strong>的最长链长度。假设已知所有的$f[v]+w(u,v) (v\in son(u))$（即自节点$u$向下延伸的所有链的长度），则我们应在保证这些链能组成最多赛道的前提下，使保留下来的$f[v]+w(u,v)$最大。</p><p>考虑贪心。对于$f[v]+w(u,v)\ge len$的情况，可以直接将其作为一条赛道。而剩余的链，只能将它们两两拼接成赛道。由于需要使保留下来的$f[v]+w(u,v)$取最大值，所以我们可以优先使较短的链得到匹配，在剩余的无法匹配的链中取最值作为新的$f[u]$。</p><p>贪心操作可以用$multiset$实现。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> v, w;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, M, L, cnt;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = it -&gt; v, w = it -&gt; w;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        <span class="keyword">if</span> (f[v] + w &gt;= L) cnt++;</span><br><span class="line">        <span class="keyword">else</span> s.insert(f[v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin();</span><br><span class="line">        s.erase(it);</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = s.lower_bound(L - *it);</span><br><span class="line">        <span class="keyword">if</span> (it1 == s.end())</span><br><span class="line">            f[u] = max(f[u], *it);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            s.erase(it1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= M) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        G[u].push_back((Edge)&#123;v, w&#125;);</span><br><span class="line">        G[v].push_back((Edge)&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">500000000</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        L = mid;</span><br><span class="line">        <span class="keyword">if</span> (check()) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个有$n$个节点的树，在其中选出$m$条没有公共边的路径，并使得$m$条路径中最短路径的长度尽可能大。输出这个最短路径的长度。&lt;/p&gt;
&lt;p&gt;$2\le n \le 50000,1\le m\le n-1 $&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分答案" scheme="https://tth37.cn/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-树链剖分</title>
    <link href="https://tth37.cn/2019/07/04/algorithm-treechainsectioning/"/>
    <id>https://tth37.cn/2019/07/04/algorithm-treechainsectioning/</id>
    <published>2019-07-04T15:21:49.000Z</published>
    <updated>2019-07-05T05:51:32.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。</p><p>具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。</p><a id="more"></a><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="【实现过程】"><a href="#【实现过程】" class="headerlink" title="【实现过程】"></a>【实现过程】</h3><ol><li><p>第一个 DFS 记录每个结点的深度（deep）、子树大小（size）。</p></li><li><p>第二个 DFS 记录每个结点的重子结点（heavy-son）、重边优先遍历时的 DFN 序、所在链的链顶（top，且应初始化为结点本身）。</p></li><li><p>链上的 DFN 序是连续的，可以使用线段树，树状数组维护。</p><p>每次选择深度较大的链往上跳，直到两点在同一条链上。</p></li><li><p>在 DFS 搜索的时候，子树中的结点的 DFN 序是连续的。</p><p>每一个结点记录 bottom 表示所在子树连续区间末端的结点。</p><p>这样就把子树信息转化为连续的一段区间信息。</p></li></ol><p><img src="https://oi-wiki.org/graph/images/hld.png" alt></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, M, R, P;</span><br><span class="line"><span class="keyword">int</span> w[MAXN], fa[MAXN], size[MAXN], son[MAXN], top[MAXN], dep[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], dfn_index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, tag;</span><br><span class="line">&#125;node[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Node&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    u.tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        u.sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(node[u.l = ++cnt], l, mid);</span><br><span class="line">    build(node[u.r = ++cnt], mid + <span class="number">1</span>, r);</span><br><span class="line">    u.sum = (node[u.l].sum + node[u.r].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(Node&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u.tag) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        node[u.l].sum = (node[u.l].sum + u.tag * (mid - l + <span class="number">1</span>));</span><br><span class="line">        node[u.r].sum = (node[u.r].sum + u.tag * (r - mid));</span><br><span class="line">        node[u.l].tag = (node[u.l].tag + u.tag);</span><br><span class="line">        node[u.r].tag = (node[u.r].tag + u.tag);</span><br><span class="line">        u.tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        u.tag = (u.tag + val) % P;</span><br><span class="line">        u.sum = (u.sum + val * (r - l + <span class="number">1</span>)) % P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(u, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) modify(node[u.l], l, mid, ql, qr, val);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) modify(node[u.r], mid + <span class="number">1</span>, r, ql, qr, val);</span><br><span class="line">    u.sum = (node[u.l].sum + node[u.r].sum) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node&amp; u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> u.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    pushdown(u, l, r);</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ans = (ans + query(node[u.l], l, mid, ql, qr)) % P;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) ans = (ans + query(node[u.r], mid + <span class="number">1</span>, r, ql, qr)) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fath)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    fa[u] = fath;</span><br><span class="line">    dep[u] = dep[fath] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fath) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> topc)</span> </span>&#123;</span><br><span class="line">    top[u] = topc;</span><br><span class="line">    dfn[u] = ++dfn_index;</span><br><span class="line">    a[dfn[u]] = w[u];</span><br><span class="line">    <span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[u], topc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ModifySubtree</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    modify(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[u], dfn[u] + size[u] - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QuerySubtree</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[u], dfn[u] + size[u] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ModifyChain</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    val %= P;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v);</span><br><span class="line">        modify(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[top[u]], dfn[u], val);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    modify(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[v], dfn[u], val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QueryChain</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v);</span><br><span class="line">        ans = (ans + query(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[top[u]], dfn[u])) % P;</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    ans = (ans + query(node[<span class="number">0</span>], <span class="number">1</span>, N, dfn[v], dfn[u])) % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;R, &amp;P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(R, <span class="number">0</span>);</span><br><span class="line">    dfs2(R, R);</span><br><span class="line">    build(node[<span class="number">0</span>], <span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            ModifyChain(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, QueryChain(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;z);</span><br><span class="line">            ModifySubtree(x, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, QuerySubtree(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。&lt;/p&gt;
&lt;p&gt;具体来说，将整棵树剖分为若干条链，使它组合成线性结构，然后用其他的数据结构维护信息。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据结构" scheme="https://tth37.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="https://tth37.cn/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="dfs序" scheme="https://tth37.cn/tags/dfs%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2831愤怒的小鸟</title>
    <link href="https://tth37.cn/2019/07/03/solution-luogu-p2831/"/>
    <id>https://tth37.cn/2019/07/03/solution-luogu-p2831/</id>
    <published>2019-07-03T06:25:55.000Z</published>
    <updated>2019-07-14T08:51:07.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2831" target="_blank" rel="noopener">题目链接</a></p><p>在平面直角坐标系中给定$n$个位于第一象限的点，求至少需要从原点引出多少条开口向下的抛物线，使它们经过所有的点。</p><p>$ 1 \le n \le 18 $</p><p>感谢@oy的贡献</p></blockquote><a id="more"></a><p>一道并不是特别难的状压dp。</p><p>状态定义：$f[s]$表示将所有剩余的猪消灭至少需要多少只小鸟，其中$s$表示已经消灭的猪的集合。</p><p>考虑状态转移，发射一个小鸟可以消灭尚未被消灭的猪。记$curve[i][j]$为一个二进制集合，表示经过第$i$、$j$号猪的抛物线能消灭哪些猪。</p><p>即：</p><script type="math/tex; mode=display">f[s]=min\lbrace f[s|curve[i][j]]+1\rbrace</script><p>可以用记忆化搜索实现，注意精度控制和触摸状态。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x[<span class="number">19</span>], y[<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> curve[<span class="number">19</span>][<span class="number">19</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">524289</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">equals</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b, <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span> </span>&#123;</span><br><span class="line">    a = (y1 * x2 - x1 * y2) / (x1 * x1 * x2 - x2 * x2 * x1);</span><br><span class="line">    b = (y1 - x1 * x1 * a) / x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[s] != <span class="number">-1</span>) <span class="keyword">return</span> f[s];</span><br><span class="line">    <span class="keyword">if</span> (s == (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>) <span class="keyword">return</span> f[s] = <span class="number">0</span>;</span><br><span class="line">    f[s] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i; j &lt;= N; ++j) &#123;</span><br><span class="line">            f[s] = min(f[s], dp(s | curve[i][j]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(curve, <span class="number">0</span>, <span class="keyword">sizeof</span>(curve));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p1 = <span class="number">1</span>; p1 &lt;= N; ++p1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p2 = p1 + <span class="number">1</span>; p2 &lt;= N; ++p2) &#123;</span><br><span class="line">                <span class="keyword">double</span> a, b;</span><br><span class="line">                equals(a, b, x[p1], y[p1], x[p2], y[p2]);</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x[i] * x[i] * a + x[i] * b &gt;= y[i] - EPS &amp;&amp; x[i] * x[i] * a + x[i] * b &lt;= y[i] + EPS) &#123;</span><br><span class="line">                        curve[p1][p2] |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br><span class="line">                        curve[p2][p1] |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= N; ++p)</span><br><span class="line">            curve[p][p] = (<span class="number">1</span> &lt;&lt; (p - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2831&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在平面直角坐标系中给定$n$个位于第一象限的点，求至少需要从原点引出多少条开口向下的抛物线，使它们经过所有的点。&lt;/p&gt;
&lt;p&gt;$ 1 \le n \le 18 $&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态压缩" scheme="https://tth37.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p3959宝藏</title>
    <link href="https://tth37.cn/2019/06/30/solution-luogu-p3959/"/>
    <id>https://tth37.cn/2019/06/30/solution-luogu-p3959/</id>
    <published>2019-06-29T16:26:07.000Z</published>
    <updated>2019-07-21T14:43:17.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3959" target="_blank" rel="noopener">题目链接</a></p><p>输入一个有$n$个点$m$条边的有权无向图。选定任意节点作为根节点。构造一棵生成树，使得树上所有真实边权的总和最小。真实边权的计算公式：$w(u,v)\times L$，其中$L$为根节点到$u$路径上的节点总数。</p><p>$1\le n \le 12,1 \le m \le 1000$</p><p>感谢@oy的贡献</p></blockquote><a id="more"></a><p>这道题做了很长时间，从一开始推出错误的状态转移方程，到埋头优化正确的状态转移，前后花了一个多星期……</p><p>本题题解可以保证正确性（当然欢迎Hack），却在速度上略有欠缺。</p><p>状态定义：$f[s][u][d]$ $s$表示当前已联通的点集，$u$表示当前点集生成树的树根，$d$表示$u$到起点的距离。（注意：$u$不是起点）</p><p>状态转移：状态肯定是通过挖通道来转移的。如果将$u$和$v$之间挖通，则$u$所在的连通块和$v$所在的连通块将会合并。如果以$u$作为根，$u$到起点的距离为$d$，则$v$到起点的距离为$(d+1)$。方程如下：</p><script type="math/tex; mode=display">f[s][u][d]=min\lbrace f[s1][u][d]+f[s2][v][d+1]+w(u,v)*d\rbrace</script><p>其中：</p><script type="math/tex; mode=display">s1 \cup s2=s,u\in s1,v\in s2,w(u,v)\not= \inf</script><p>最终要求的答案即为$\min_{1\le i \le n}f[(1&lt;&lt;n)-1][i][1]$，采用记忆化搜索实现。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">13</span>][<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">13</span>][<span class="number">13</span>][<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> u, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[s][u][d] != <span class="number">-1</span>) <span class="keyword">return</span> f[s][u][d];</span><br><span class="line">    <span class="keyword">if</span> (s == (<span class="number">1</span> &lt;&lt; (u - <span class="number">1</span>))) <span class="keyword">return</span> f[s][u][d] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; ans = f[s][u][d] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> s1 = s; s1; s1 = (s1 - <span class="number">1</span>) &amp; s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(s1 &amp; (<span class="number">1</span> &lt;&lt; (u - <span class="number">1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; (v - <span class="number">1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (w[u][v] == INF) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> s2 = s ^ s1;</span><br><span class="line">            ans = min(ans, dp(s1, u, d) + dp(s2, v, d + <span class="number">1</span>) + w[u][v] * d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;t);</span><br><span class="line">        w[u][v] = w[v][u] = min(w[u][v], t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; ++u) &#123;</span><br><span class="line">        ans = min(ans, dp((<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, u, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3959&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输入一个有$n$个点$m$条边的有权无向图。选定任意节点作为根节点。构造一棵生成树，使得树上所有真实边权的总和最小。真实边权的计算公式：$w(u,v)\times L$，其中$L$为根节点到$u$路径上的节点总数。&lt;/p&gt;
&lt;p&gt;$1\le n \le 12,1 \le m \le 1000$&lt;/p&gt;
&lt;p&gt;感谢@oy的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态压缩" scheme="https://tth37.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>公告 2019-6-20</title>
    <link href="https://tth37.cn/2019/06/20/bulletin-2019-6-20/"/>
    <id>https://tth37.cn/2019/06/20/bulletin-2019-6-20/</id>
    <published>2019-06-19T16:16:06.000Z</published>
    <updated>2019-07-05T16:08:30.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="招募启事"><a href="#招募启事" class="headerlink" title="招募启事"></a>招募启事</h2><p>tth37最近发现，他写了<del>好多好多</del>题解啦。但是这些题解全都被展示在Homepage里，导致Homepage不够简洁，题目检索不太方便。</p><p>于是，tth37决定在每篇题解最前面，写一段<strong>题目内容的一句话总结</strong>。但是tth37比较忙，实在不想做这件事，因此他决定<del>招募</del>跪求巨佬来帮他完成这项工作。</p><p>一份完整的一句话总结必须<strong>清楚地概括题面（拒绝花里胡哨）</strong>，并且给出<strong>数据范围</strong>。一切字母必须采用$L^AT_EX$公式。（百度一下？）</p><p>写好一句话总结后，请将其上传至<strong>洛谷剪贴板</strong>，并将剪贴板链接发给tth37。tth37会根据其质量，酌情发送<strong>0.01~0.66元红包</strong>作为报酬。</p><p>如果在座的各位对本活动反响不够热烈，tth37可能会<strong>强迫</strong>你们当中的一些人完成这项任务。当然，<strong>没有报酬</strong>。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;招募启事&quot;&gt;&lt;a href=&quot;#招募启事&quot; class=&quot;headerlink&quot; title=&quot;招募启事&quot;&gt;&lt;/a&gt;招募启事&lt;/h2&gt;&lt;p&gt;tth37最近发现，他写了&lt;del&gt;好多好多&lt;/del&gt;题解啦。但是这些题解全都被展示在Homepage里，导致Homepage不够简洁，题目检索不太方便。&lt;/p&gt;
&lt;p&gt;于是，tth37决定在每篇题解最前面，写一段&lt;strong&gt;题目内容的一句话总结&lt;/strong&gt;。但是tth37比较忙，实在不想做这件事，因此他决定&lt;del&gt;招募&lt;/del&gt;跪求巨佬来帮他完成这项工作。&lt;/p&gt;
&lt;p&gt;一份完整的一句话总结必须&lt;strong&gt;清楚地概括题面（拒绝花里胡哨）&lt;/strong&gt;，并且给出&lt;strong&gt;数据范围&lt;/strong&gt;。一切字母必须采用$L^AT_EX$公式。（百度一下？）&lt;/p&gt;
&lt;p&gt;写好一句话总结后，请将其上传至&lt;strong&gt;洛谷剪贴板&lt;/strong&gt;，并将剪贴板链接发给tth37。tth37会根据其质量，酌情发送&lt;strong&gt;0.01~0.66元红包&lt;/strong&gt;作为报酬。&lt;/p&gt;
&lt;p&gt;如果在座的各位对本活动反响不够热烈，tth37可能会&lt;strong&gt;强迫&lt;/strong&gt;你们当中的一些人完成这项任务。当然，&lt;strong&gt;没有报酬&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="公告" scheme="https://tth37.cn/categories/%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>题解-luogu-p3953逛公园</title>
    <link href="https://tth37.cn/2019/06/19/solution-luogu-p3953/"/>
    <id>https://tth37.cn/2019/06/19/solution-luogu-p3953/</id>
    <published>2019-06-19T15:39:55.000Z</published>
    <updated>2019-06-29T17:35:41.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P3953" target="_blank" rel="noopener">题目链接</a></p><p>给定一个$n$个点$m$条边的有向带权图，设起点到终点的最短路为$d$，求起点到终点满足权值总和小于等于$(d+k)$的路径数量</p><p>$1 \le p\le 10^9 $ , $1 \le n\le 10^5$ , $1 \le m\le 2 \times 10^5$ , $1 \le k\le 50$</p><p>感谢@oy 的贡献</p></blockquote><a id="more"></a><p>一道看似图论实则可以用动态规划解决的题目。</p><p>朴素的状态定义：$f[u][k]$表示从$1$号节点走到$u$号节点，路径长度为$k$的方案总数。状态转移方程：</p><script type="math/tex; mode=display">f[u][k]=\sum_{(u,v)\in E}f[v][k-w(u,v)]</script><p>但是这样的状态定义有一个严重的问题：空间消耗过大。考虑到题目中给出的$K$值并不大，我们可以利用题目所要求的信息来优化状态设计。</p><p>优化后的状态定义：$d[u]$表示从$1$号节点走到$u$号节点的最短路长度，$f[u][k]$表示从$1$号节点走到$u$号节点，<strong>路径长度为$d[u]+k$的方案总数</strong>。</p><p>如此一来，状态所需的空间大大减少，但相应的状态转移略显复杂。不妨设$f[u][k]$状态可以由$f[v][x]$转移得到，则：</p><script type="math/tex; mode=display">d[v]+x+w(u,v)=d[u]+k</script><p>移项，得到：</p><script type="math/tex; mode=display">x=d[u]-d[v]+k-w(u,v)</script><p>因此，完整的状态转移方程如下：</p><script type="math/tex; mode=display">f[u][k]=\sum_{(u,v)\in E}f[v][d[u]-d[v]+k-w(u,v)]</script><p>我们最终要求的答案即为$\sum_{i=0}^Kf[N][i]$，用记忆化搜索实现即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> v, w;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G1[MAXN], G2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, N, M, K, P;</span><br><span class="line"><span class="keyword">bool</span> fail;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> ins[MAXN][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = it-&gt;v, w = it-&gt;w;</span><br><span class="line">            <span class="keyword">if</span> (d[u] + w &lt; d[v]) &#123;</span><br><span class="line">                d[v] = d[u] + w;</span><br><span class="line">                q.push(make_pair(-d[v], v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ins[u][k])&#123;</span><br><span class="line">        fail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[u][k]) <span class="keyword">return</span> f[u][k];</span><br><span class="line">    ins[u][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = it-&gt;v, w = it-&gt;w;</span><br><span class="line">        ans = (ans + dp(p, d[u] - d[p] + k - w))%P;</span><br><span class="line">        <span class="keyword">if</span> (fail == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ins[u][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[u][k] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;N, &amp;M, &amp;K, &amp;P);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            G1[u].push_back((Edge)&#123;v, w&#125;);</span><br><span class="line">            G2[v].push_back((Edge)&#123;u, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra();</span><br><span class="line">        dp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            ans = (ans + dp(N, i))%P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fail == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            G1[i].clear(), G2[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3953&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个$n$个点$m$条边的有向带权图，设起点到终点的最短路为$d$，求起点到终点满足权值总和小于等于$(d+k)$的路径数量&lt;/p&gt;
&lt;p&gt;$1 \le p\le 10^9 $ , $1 \le n\le 10^5$ , $1 \le m\le 2 \times 10^5$ , $1 \le k\le 50$&lt;/p&gt;
&lt;p&gt;感谢@oy 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2627修剪草坪</title>
    <link href="https://tth37.cn/2019/06/09/solution-luogu-p2627/"/>
    <id>https://tth37.cn/2019/06/09/solution-luogu-p2627/</id>
    <published>2019-06-08T17:42:17.000Z</published>
    <updated>2019-06-22T17:15:10.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2627" target="_blank" rel="noopener">题目链接</a></p><p>读入$n$个整数，选取其中若干个数，最多连续取$k$个，求取到数字和的最大值</p><p>$1\le k \le n \le 100000$</p><p>感谢@oy 的贡献</p></blockquote><a id="more"></a><p>一道单调队列入门题。</p><p>面对动规题，首先设计状态转移方程。令$f[i]$表示$1-i$中连取不超过$K$个数，且<strong>第$i$个数不取</strong>所能累加的最大和。</p><p>因为第$i$个数不取，所以在$i$之前一定连取了一段数。这段数的长度可能为$0-K$（注意是$0-K$而不是$1-K$，可以通过手推样例发现最优解中可能存在连着两个数不取的情况）。连取的一段数所能累加的和可以用前缀和计算。考虑边界条件后，状态转移方程如下：</p><script type="math/tex; mode=display">f[i]=\max_{i-K-1\le j \le i-1} \lbrace f[j]+s[i-1]-s[j] \rbrace</script><p>由于$max$函数的循环变量是$j$，所以<strong>只与$i$相关的变量</strong>$s[i-1]$可以作为常数提出到$max$函数之外，即：</p><script type="math/tex; mode=display">f[i]=\max_{i-K-1\le j \le i-1}\lbrace f[j]-s[j]\rbrace +s[i-1]</script><p>将状态转移方程化简到这样，就已经可以用单调队列进行优化了。我们可以用单调队列维护$f[j]-s[j]$的最值，在循环时将其最大值取出再加上$s[i-1]$即为$f[i]$。</p><p>如果想不到该如何操作，也可以这样理解：</p><script type="math/tex; mode=display">g[i]=f[i]-s[i]</script><script type="math/tex; mode=display">f[i]=\max_{i-K-1\le j \le i-1}\lbrace g[j]\rbrace+s[i-1]</script><p>由于我们定义$f[i]$是第$i$个数不取的最优解，可以强行求解$f[N+1]$（虽然它似乎没有实际意义）作为本题的最终答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line">ll s[<span class="number">100005</span>], f[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; q[l] &lt; i - K - <span class="number">1</span>) l++;</span><br><span class="line">        f[i] = f[q[l]] - s[q[l]] + s[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; f[q[r - <span class="number">1</span>]] - s[q[r - <span class="number">1</span>]] &lt; f[i] - s[i]) r--;</span><br><span class="line">        q[r++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[N + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2627&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;读入$n$个整数，选取其中若干个数，最多连续取$k$个，求取到数字和的最大值&lt;/p&gt;
&lt;p&gt;$1\le k \le n \le 100000$&lt;/p&gt;
&lt;p&gt;感谢@oy 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="单调队列" scheme="https://tth37.cn/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1600天天爱跑步(Beta)</title>
    <link href="https://tth37.cn/2019/06/07/solution-luogu-p1600/"/>
    <id>https://tth37.cn/2019/06/07/solution-luogu-p1600/</id>
    <published>2019-06-07T15:41:27.000Z</published>
    <updated>2019-07-07T06:50:26.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1600" target="_blank" rel="noopener">题目链接</a></p><p>$n$个点的树上有$m$条路径$(S_i, T_i)$，每条路径上各有一个人从$S_i$跑到$T_i$。他们在第$0$时刻同时跑，每秒能跑一条边。回答$n$个询问，询问恰好在第$W_i$时刻到达节点$i$的人数。</p><p>$1 \le n \le 300000,1 \le m \le 300000 $</p><p>感谢@tth37 的贡献</p></blockquote><a id="more"></a><p>准备写一篇较为详细的题解。部分思路来自《算法竞赛进阶指南》。</p><hr><p>游戏地图构成树形结构，为方便处理，可以取$1$号节点作为根，转化为有根树处理。</p><p>可以发现，从S到T的路径有且只有一条，并且必将经过$lca(S,T)$。</p><p>不妨设$x$节点上有一名观察员，其观察时间为$W[x]$。我们可以对$x$的位置进行分情况讨论。</p><ol><li><p>$x$在$S$到$lca(S,T)$的路径上（该路径包含$lca(S,T)$）。</p><p><img src="https://tth37.cn/images/tmp1.png" alt></p><p>为方便说明，假设$S=6$，$T=4$。那么，此时$x$可能为$1$，$3$或$6$。<strong>如果此观察员可以观察到当前玩家，当且仅当</strong>$W[x]=d[S]-d[x]$（$d$数组表示节点深度）。对上式移项，得到$W[x]+d[x]=d[S]$。</p><p>接下来，我们给每一个节点分配若干个权值，即在每一个节点上开一个一维数组，记录各个权值。根据上式，我们可以将$S$到$lca(S,T)$的路径上每一个节点的$d[S]$号权值加一。按照这种方式处理完所有玩家的信息之后，我们遍历所有节点，每个节点上的$(W[x]+d[x])$号权值即为所求。</p><p><img src="https://tth37.cn/images/tmp2.png" alt></p><p>该方法的正确性应该不难理解。$(W[x]+d[x])$号权值的意义即为该节点上满足前文所述等式的玩家个数，而满足等式意味着玩家将会在观察员探头时经过观察点，符合题意。</p><p>但是这种暴力方法显然还有优化的空间。在有根树的一条链上进行权值更改，可以尝试用树上差分的知识解决。<strong>在节点$S$上的$d[S]$号权值加一，节点$fa[lca(S,T)]$上的$d[S]$号权值减一</strong>（可以在每个节点上开一个不定长数组vector记录当前节点上的加减操作），最后进行统计时，计算<strong>当前子树所有$(W[x]+d[x])$号权值和</strong>即可。但即便如此，答案统计也并不容易实现；我们可以使用以下方法：</p><p>建立全局数组$s$，其中$s[i]$表示$i$号权值之和。深度优先遍历所有节点，在<strong>刚访问到当前节点时，记录$cnt=s[W[x]+d[x]]$</strong>。遍历当前节点上的vector，执行加减操作（例如：vector中的一项操作把$3$号权值减一，则$s[3]=s[3]-1$）。递归访问当前节点的所有子节点。<strong>访问结束后，$(s[W[x]+d[x]]-cnt)$即为所求</strong>。</p><p>结合dfs序的相关知识，访问完当前节点的所有子节点之后，$s$数组已经记录了以$x$为根的子树上所有操作。因此将访问后与访问前的权值相减，即为树上差分所得到的答案。</p><p>别忘了才分类讨论了一半呢……</p></li><li><p>$x$在$lca(S,T)$到$T$的路径上（该路径不包含$lca(S,T)$）。<br><img src="https://tth37.cn/images/tmp3.png" alt><br>同样假设$S=6$，$T=4$。此时$x$可能为$2$或$4$。<strong>如果此观察员可以观察到当前玩家，当且仅当</strong>$W[x]=(d[S]-d[lca(S,T)])+(d[x]-d[lca(S,T)])$。对上式移项，得到$W[x]-d[x]=d[S]-2*d[lca(S,T)]$。</p><p>类似地，我们只需将操作改为对$(d[S]-2*d[lca(S,T)])$号权值的操作即可。由于权值有可能为负，需要将序号整体平移$N$个单位，即改为对$(d[S]-2*d[lca(S,T)]+N)$号权值的操作。在每个节点上另开一个操作vector，统计答案时另开一个$s$数组，将计算出的答案与第一种情况的答案相加即可。</p></li></ol><p> <strong>Q：为什么必须另开操作vector和$s$数组？</strong></p><p> <strong>A：回顾一下提到的两个式子：$W[x]+d[x]=d[S]$，$W[x]-d[x]=d[S]-2*d[lca(S,T)]$如果将两者合起来操作，有可能产生“将$d[S]$号权值加一，碰巧统计答案时$W[x]-d[x]=d[S]$”的情况。然而，上述等式是没有任何意义的：$x$号节点根本无法观察到玩家。为了避免此类错误，必须将两种操作分开处理。</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opt</span> &#123;</span><span class="keyword">int</span> id, op;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;opt&gt; opt1[MAXN], opt2[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> W[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">20</span>], d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa, d[u] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i)</span><br><span class="line">        f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[u] &lt; d[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[f[u][i]] &gt;= d[v]) u = f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1[MAXN*<span class="number">3</span>], s2[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = s1[W[u] + d[u] + N];</span><br><span class="line">    <span class="keyword">int</span> cnt2 = s2[W[u] - d[u] + N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;opt&gt;::iterator it = opt1[u].begin(); it != opt1[u].end(); it++)</span><br><span class="line">        s1[it-&gt;id] += it-&gt;op;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;opt&gt;::iterator it = opt2[u].begin(); it != opt2[u].end(); it++)</span><br><span class="line">        s2[it-&gt;id] += it-&gt;op;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[u] = s1[W[u] + d[u] + N] - cnt1 + s2[W[u] - d[u] + N] - cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;W[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> S, T;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;S, &amp;T);</span><br><span class="line">        <span class="keyword">int</span> lca = Lca(S, T);</span><br><span class="line">        opt1[S].push_back((opt)&#123;d[S] + N, <span class="number">1</span>&#125;);</span><br><span class="line">        opt1[f[lca][<span class="number">0</span>]].push_back((opt)&#123;d[S] + N, <span class="number">-1</span>&#125;);</span><br><span class="line">        opt2[T].push_back((opt)&#123;d[S] - <span class="number">2</span>*d[lca] + N, <span class="number">1</span>&#125;);</span><br><span class="line">        opt2[lca].push_back((opt)&#123;d[S] - <span class="number">2</span>*d[lca] + N, <span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$n$个点的树上有$m$条路径$(S_i, T_i)$，每条路径上各有一个人从$S_i$跑到$T_i$。他们在第$0$时刻同时跑，每秒能跑一条边。回答$n$个询问，询问恰好在第$W_i$时刻到达节点$i$的人数。&lt;/p&gt;
&lt;p&gt;$1 \le n \le 300000,1 \le m \le 300000 $&lt;/p&gt;
&lt;p&gt;感谢@tth37 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上差分" scheme="https://tth37.cn/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
      <category term="最近公共祖先" scheme="https://tth37.cn/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2633 Count on a tree(COT)</title>
    <link href="https://tth37.cn/2019/05/20/solution-luogu-p2633/"/>
    <id>https://tth37.cn/2019/05/20/solution-luogu-p2633/</id>
    <published>2019-05-20T11:04:53.000Z</published>
    <updated>2019-07-03T08:55:45.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2633" target="_blank" rel="noopener">题目链接</a></p><p>给定一棵$n$个节点的树，每个节点上有一个权值。对于$m$次询问，需要输出$u$到$v$的最短路径上第$k$小的点权。</p><p>$1\le n\le 100000,1 \le m\le 100000$</p><p>感谢@tth37 的贡献</p></blockquote><a id="more"></a><blockquote><p>这题不难呀，怎么调了这么久？         ——Mr. G</p></blockquote><p>前置知识是主席树。在利用主席树求解区间第K小数时可以发现，主席树是一种类似前缀和的数据结构，具有和前缀和类似的区间加减及差分等优秀性质。在求解线性区间的第K小数时，我们需要将该区间内的所有数值信息扔到一棵主席树中，并在这棵主席树上左右递归，以找到第K小数；同样的，我们可以类比树上前缀和的操作，定义$s[u]$为从根节点到第$u$号节点的“前缀主席树”（感性理解谢谢）。那么，包含$u$到$v$上所有数值信息的主席树就应该是：</p><script type="math/tex; mode=display">s[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]</script><p>理解上式后，问题基本可以解决了。另外注意离散化和主席树的代码细节。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 离散化操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) (lower_bound(b+1,b+L+1,a[x])-b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid(x) (b[x])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum;</span><br><span class="line">&#125;node[<span class="number">10000005</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, L, lastans;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">19</span>], dep[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Node &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    u.sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(node[u.l = ++cnt], l, mid);</span><br><span class="line">    build(node[u.r = ++cnt], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node c, Node &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    u.sum = c.sum + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid)</span><br><span class="line">        insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(node[c.r], node[u.r = ++cnt], mid+<span class="number">1</span>, r, p), u.l = c.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    insert(node[head[fa]], node[head[u] = ++cnt], <span class="number">1</span>, L, id(u));</span><br><span class="line">    f[u][<span class="number">0</span>] = fa;</span><br><span class="line">    dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)</span><br><span class="line">        f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = *it;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[u][i]] &gt;= dep[v]) u = f[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[u][i] != f[v][i])</span><br><span class="line">            u = f[u][i], v = f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node x, Node y, Node z, Node w, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= k) <span class="keyword">return</span> query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> query(node[x.r], node[y.r], node[z.r], node[w.r], mid+<span class="number">1</span>, r, k - sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">querypath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = Lca(u, v);</span><br><span class="line">    <span class="keyword">return</span> rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][<span class="number">0</span>]]], <span class="number">1</span>, L, k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), b[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + N + <span class="number">1</span>);</span><br><span class="line">    L = unique(b + <span class="number">1</span>, b + N + <span class="number">1</span>) - (b + <span class="number">1</span>);</span><br><span class="line">    build(node[head[<span class="number">0</span>] = ++cnt], <span class="number">1</span>, L);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> nowans = querypath(u^lastans, v, k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nowans);</span><br><span class="line">        lastans = nowans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2633&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一棵$n$个节点的树，每个节点上有一个权值。对于$m$次询问，需要输出$u$到$v$的最短路径上第$k$小的点权。&lt;/p&gt;
&lt;p&gt;$1\le n\le 100000,1 \le m\le 100000$&lt;/p&gt;
&lt;p&gt;感谢@tth37 的贡献&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="树上前缀和" scheme="https://tth37.cn/tags/%E6%A0%91%E4%B8%8A%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>公告 2019-5-18</title>
    <link href="https://tth37.cn/2019/05/18/bulletin-2019-5-18/"/>
    <id>https://tth37.cn/2019/05/18/bulletin-2019-5-18/</id>
    <published>2019-05-18T09:44:02.000Z</published>
    <updated>2019-06-08T18:13:46.614Z</updated>
    
    <content type="html"><![CDATA[<p>Hi~ 访问我网站的小崽子们~</p><p>想在评论区发言的同时留下自己的个人头像吗？<a href="http://cn.gravatar.com/" target="_blank" rel="noopener">速戳这里！（Gravatar.com）</a> 在这个网站注册用户，并在评论区留言时留下在<code>Gravatar</code>的账号邮箱，即可在评论区显示头像！</p><p><a href="https://tth37.cn/message/">可以在这里测试一下</a></p><p>由于网站是国家顶级域名（<code>*.cn</code>），所以缓存可能需要一周（或更长）的时间才能更新，请耐心等待！</p><p>谢谢资瓷！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hi~ 访问我网站的小崽子们~&lt;/p&gt;
&lt;p&gt;想在评论区发言的同时留下自己的个人头像吗？&lt;a href=&quot;http://cn.gravatar.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;速戳这里！（Gravatar.com）&lt;/a&gt; 在这个网
      
    
    </summary>
    
      <category term="公告" scheme="https://tth37.cn/categories/%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1273有线电视网</title>
    <link href="https://tth37.cn/2019/04/25/solution-luogu-p1273/"/>
    <id>https://tth37.cn/2019/04/25/solution-luogu-p1273/</id>
    <published>2019-04-25T09:25:50.000Z</published>
    <updated>2019-08-27T08:10:26.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/fe/problem/P1273" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>背包类树形dp。本题需要运用分组背包模型。</p><p>首先定义状态：$f[u][i]$表示以$u$为根的子树上，选择$i$个用户时的最大利润。由于电视公司可能亏本，因此$f$数组应赋极小初值。</p><p>可以将选择的用户个数看作背包的容量维度，将获得的利润看作背包的价值维度。可以设计出如下的状态转移：</p><script type="math/tex; mode=display">f[u][i]=\max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}</script><p>其中，$v$为$u$的子节点，$w$为这条边的权值。在$u$每个子节点上有许多“物品”，“物品”总数即为以$v$为根的子树上用户的个数；每个“物品”所具有的价值即为其最大利润，即$f[v][j]$。同时不应忽略边权对利润带来的影响。</p><p>注意细节处理及边界。代码如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;mem[<span class="number">3005</span>*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">3005</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> size[<span class="number">3005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    mem[++cnt].v=v;</span><br><span class="line">    mem[cnt].w=w;</span><br><span class="line">    mem[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> leaf[<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leaf[u])&#123;</span><br><span class="line">        f[u][<span class="number">1</span>]=leaf[u];</span><br><span class="line">        size[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=mem[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=mem[i].v,w=mem[i].w;</span><br><span class="line">        dfs(v);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=M;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(size[v],j);++k)</span><br><span class="line">                f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N-M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;c);</span><br><span class="line">            AddEdge(i,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;leaf[N-M+i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=M;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/fe/problem/P1273&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;背包类树形dp。本题需要运用分组背包模型。&lt;/p&gt;
&lt;p&gt;首先定义状态：$f[u][i]$表示以$u$为根的子树上，选择$i$个用户时的最大利润。由于电视公司可能亏本，因此$f$数组应赋极小初值。&lt;/p&gt;
&lt;p&gt;可以将选择的用户个数看作背包的容量维度，将获得的利润看作背包的价值维度。可以设计出如下的状态转移：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i]=\max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}&lt;/script&gt;&lt;p&gt;其中，$v$为$u$的子节点，$w$为这条边的权值。在$u$每个子节点上有许多“物品”，“物品”总数即为以$v$为根的子树上用户的个数；每个“物品”所具有的价值即为其最大利润，即$f[v][j]$。同时不应忽略边权对利润带来的影响。&lt;/p&gt;
&lt;p&gt;注意细节处理及边界。代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-数论专题-素数的判定</title>
    <link href="https://tth37.cn/2019/04/13/algorithm-maths-primecheck/"/>
    <id>https://tth37.cn/2019/04/13/algorithm-maths-primecheck/</id>
    <published>2019-04-13T13:58:41.000Z</published>
    <updated>2019-04-20T09:57:29.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版权声明：本篇文章由特邀讲师胡家睿撰写，tth37只负责搬运、整理和发布；版权归胡家睿所有。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>素数定义：除1和本身以外没有其他因数的数</p></blockquote><p>素数在信息学竞赛中有较多的应用，素数判定是解决复杂数论问题的基础。本篇文章介绍了一些素数判定的方法。</p><a id="more"></a><h2 id="单个素数判定"><a href="#单个素数判定" class="headerlink" title="单个素数判定"></a>单个素数判定</h2><p>朴素判定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//特判1（不为素数）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//除1、n以外还存在因数，所以n为合数；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；<span class="comment">//循环后没有判定为合数，则为素数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$\Theta (n)$</p><p>优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//特判1（不为素数）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$\Theta(\sqrt{n})$</p><p>证明：</p><p>​    若一个数$n$为合数，则它一定拥有一个质因数$k$。可以知道，$n/k$（记为$s$）为$n$的因数，且$s$不等于$n$。$k$和$s$二者必定有一个数小于等于$\sqrt{n}$，否则$k*s$一定大于$n$。所以只要在$\sqrt{n}$以内循环一遍即可。</p><h2 id="埃氏素数筛"><a href="#埃氏素数筛" class="headerlink" title="埃氏素数筛"></a>埃氏素数筛</h2><p>如果用上面的方法判定$1-n$以内所有素数，会发现时间复杂度非常高。那么这个时候就要用筛法了。大致意思是用素数来筛掉合数，然后用$f$数组储存是否是素数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>]=<span class="literal">true</span>;<span class="comment">//特判还是很必要的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i]) <span class="keyword">continue</span>;<span class="comment">//i为合数直接跳过</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i)&#123;</span><br><span class="line">        f[j]=<span class="literal">true</span>;<span class="comment">//i为素数，i的倍数一定为合数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j+=i)&#123;<span class="comment">//这里只变了乘号，但是会快很多喔</span></span><br><span class="line">        f[j]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是：$i*i$以下的所有合数都已经被筛掉了。具体证法，可以接着看下去（在线性筛里有类似的思想，所以看完可以尝试一下自己证明）。</p><h2 id="素数线性筛"><a href="#素数线性筛" class="headerlink" title="素数线性筛"></a>素数线性筛</h2><p>上一个筛法时间复杂度$\Theta(log log n)$非常接近线性。但是要达到线性还差一点（这里不是比赛要求掌握所以就当兴趣学吧）</p><p>上一个筛法的大概想法，是每一个素数的倍数都筛掉，所以是让每一个合数都被它的质因子筛一遍。</p><p>那么接下来的筛法，就是让每个合数的最小质因子筛一遍（要开一个prime数组存所有素数）。先放代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll f[<span class="number">10005</span>],prime[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,i,j,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="comment">//这个地方不用特判1,因为我们判定是否为素数的方法是f[i]是否为0; </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt]=i;<span class="comment">//存入素数; </span></span><br><span class="line">            f[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=cnt;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prime[j]*i&gt;n||prime[j]&gt;f[i]) <span class="keyword">break</span>;<span class="comment">//判定出界或i的因子中有比当前素数更小的（即prime[j]*i已经被f[i]筛过了）; </span></span><br><span class="line">            f[prime[j]*i]=prime[j];<span class="comment">//标记所有未被标记的i的倍数； </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心就在于神奇的判定方法，可以多咀嚼咀嚼</p><p>时间复杂度$\Theta(n)$搞定，还可以找到$1-n$内所有合数的最小质因数。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;版权声明：本篇文章由特邀讲师胡家睿撰写，tth37只负责搬运、整理和发布；版权归胡家睿所有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;素数定义：除1和本身以外没有其他因数的数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;素数在信息学竞赛中有较多的应用，素数判定是解决复杂数论问题的基础。本篇文章介绍了一些素数判定的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数论专题" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E6%95%B0%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="素数" scheme="https://tth37.cn/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p4559列队</title>
    <link href="https://tth37.cn/2019/04/10/solution-luogu-p4559/"/>
    <id>https://tth37.cn/2019/04/10/solution-luogu-p4559/</id>
    <published>2019-04-10T15:42:59.000Z</published>
    <updated>2019-05-12T13:00:53.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P4559" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>本题是主席树的一个简单应用。</p><p>阅读题目，不难得出<strong>贪心策略</strong>。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。<del>（不会证）</del></p><p>对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。</p><p>为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下）</p><p>接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案：</p><ul><li>$r\le ql$ 此时处于当前值域内的所有学生都要往右跑</li><li>$qr\le l$ 此时处于当前值域内的所有学生都要往左跑</li><li>当前值域内没有学生 返回 $0$</li></ul><p>否则，必须将值域拆分，递归到左右子节点进行统计。</p><p>本题最绕的地方在于<strong>学生编号</strong>和<strong>学生位置</strong>是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。</p><p>代码如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L=<span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    ll gl,gr,sum;</span><br><span class="line">&#125;node[L*<span class="number">22</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Node&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    u.sum=u.gl=u.gr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(node[u.l=++cnt],l,mid);</span><br><span class="line">    build(node[u.r=++cnt],mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node c,Node&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    u.sum=c.sum+<span class="number">1</span>;u.gl=u.gr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)</span><br><span class="line">        insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(node[c.r],node[u.r=++cnt],mid+<span class="number">1</span>,r,p),u.l=c.l;</span><br><span class="line">    u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+<span class="number">1</span>);</span><br><span class="line">    u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(Node x,Node y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll ql,ll qr)</span></span>&#123;</span><br><span class="line">    ll sum=y.sum-x.sum; </span><br><span class="line">    ll gl=y.gl-x.gl,gr=y.gr-x.gr;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr&lt;=l)</span><br><span class="line">        <span class="keyword">return</span> gl+(<span class="number">2</span>*l-ql-qr)*(qr-ql+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&gt;=r)</span><br><span class="line">        <span class="keyword">return</span> gr+(ql+qr<span class="number">-2</span>*r)*(qr-ql+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll lsum=node[y.l].sum-node[x.l].sum;</span><br><span class="line">    <span class="keyword">return</span> query(node[x.l],node[y.l],l,mid,ql,ql+lsum<span class="number">-1</span>)+</span><br><span class="line">           query(node[x.r],node[y.r],mid+<span class="number">1</span>,r,ql+lsum,qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    build(node[<span class="number">0</span>],<span class="number">1</span>,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        insert(node[head[i<span class="number">-1</span>]],node[head[i]=++cnt],<span class="number">1</span>,L,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        ll l,r,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(node[head[l<span class="number">-1</span>]],node[head[r]],<span class="number">1</span>,L,k,k+r-l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4559&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本题是主席树的一个简单应用。&lt;/p&gt;
&lt;p&gt;阅读题目，不难得出&lt;strong&gt;贪心策略&lt;/strong&gt;。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。&lt;del&gt;（不会证）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。&lt;/p&gt;
&lt;p&gt;为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下）&lt;/p&gt;
&lt;p&gt;接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$r\le ql$ 此时处于当前值域内的所有学生都要往右跑&lt;/li&gt;
&lt;li&gt;$qr\le l$ 此时处于当前值域内的所有学生都要往左跑&lt;/li&gt;
&lt;li&gt;当前值域内没有学生 返回 $0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;否则，必须将值域拆分，递归到左右子节点进行统计。&lt;/p&gt;
&lt;p&gt;本题最绕的地方在于&lt;strong&gt;学生编号&lt;/strong&gt;和&lt;strong&gt;学生位置&lt;/strong&gt;是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="https://tth37.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p5283异或粽子</title>
    <link href="https://tth37.cn/2019/04/09/solution-luogu-p5283/"/>
    <id>https://tth37.cn/2019/04/09/solution-luogu-p5283/</id>
    <published>2019-04-09T15:41:48.000Z</published>
    <updated>2019-05-12T13:01:05.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P5283" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。</p><p>用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus … \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r] \oplus  s[l-1]$。</p><p>将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。</p><p>将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。</p><p>在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。</p><p>注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。</p><p>另外，在将<code>(1&lt;&lt;d)</code>这样的式子转<code>long long</code>时，不能写成<code>(long long)(1&lt;&lt;d)</code>，而是<code>((long long)1&lt;&lt;d)</code>。</p><p>代码如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEP=<span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line">ll ans,s[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">    ll val;</span><br><span class="line">    <span class="keyword">int</span> r,k;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> State&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> val&lt;rhs.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;State&gt; q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>],sum;</span><br><span class="line">&#125;trie[MAXN*(DEP+<span class="number">2</span>)];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node c,Node&amp; u,ll val,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    u.sum=c.sum+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x=(val&gt;&gt;d)&amp;<span class="number">1</span>;</span><br><span class="line">    u.son[!x]=c.son[!x];</span><br><span class="line">    insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(Node u,ll val,<span class="keyword">int</span> d,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x=(val&gt;&gt;d)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lsum=trie[u.son[!x]].sum;</span><br><span class="line">    <span class="keyword">if</span>(lsum&gt;=k)</span><br><span class="line">      <span class="keyword">return</span> ((ll)<span class="number">1</span>&lt;&lt;d)+(ll)query(trie[u.son[!x]],val,d<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> (ll)query(trie[u.son[x]],val,d<span class="number">-1</span>,k-lsum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    trie[<span class="number">0</span>].son[<span class="number">0</span>]=trie[<span class="number">0</span>].son[<span class="number">1</span>]=trie[<span class="number">0</span>].sum=<span class="number">0</span>;</span><br><span class="line">    insert(trie[<span class="number">0</span>],trie[head[<span class="number">0</span>]=++cnt],<span class="number">0</span>,DEP);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        ll a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]^a;</span><br><span class="line">        insert(trie[head[i<span class="number">-1</span>]],trie[head[i]=++cnt],s[i],DEP);</span><br><span class="line">        q.push((State)&#123;query(trie[head[i<span class="number">-1</span>]],s[i],DEP,<span class="number">1</span>),i,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        ans+=q.top().val;</span><br><span class="line">        <span class="keyword">int</span> r=q.top().r,k=q.top().k;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(k==r) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((State)&#123;query(trie[head[r<span class="number">-1</span>]],s[r],DEP,k+<span class="number">1</span>),r,k+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$p.s.$洛谷评测机有点小慢，不开<code>O2</code>会小概率发生TLE QwQ</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析题意，即找出$n$个数中互不相同且异或和最大的前$k$段区间。&lt;/p&gt;
&lt;p&gt;用异或前缀和$s[i]$表示$a[1]\oplus a[2]\oplus … \oplus a[i]$。根据异或运算的性质，区间$[l,r]$的异或和即为$s[r] \oplus  s[l-1]$。&lt;/p&gt;
&lt;p&gt;将$s[1]$到$s[n]$依次插入$01trie$树中，每次找出对于固定的右端点$r$，与$s[r]$异或值最大的$s[l]$。显然，此次操作找到的是固定右端点为$r$时的最大区间异或和。&lt;/p&gt;
&lt;p&gt;将每个不同的$r$值所对应的最大区间异或和插入堆中，显然堆顶的元素即为$n$个数中任意区间的最大异或和。取出堆顶元素，并同时得到这是以$r$为右端点的第$1$大区间异或和。向堆中插入以$r$为右端点的第$2$大区间异或和。&lt;/p&gt;
&lt;p&gt;在查询以$r$为右端点的第$k$大区间异或和时，只需稍微更改在$01trie$树上查找的方式即可，与主席树查询区间第$k$小数的思想类似。由于需要访问$01trie$树的历史状态，因此$01trie$需要可持久化。&lt;/p&gt;
&lt;p&gt;注意：以$r$为右端点的区间异或和一共只有$r$个，因此查询以$r$为右端点的第$r+1$大区间异或和是没有意义的。&lt;/p&gt;
&lt;p&gt;另外，在将&lt;code&gt;(1&amp;lt;&amp;lt;d)&lt;/code&gt;这样的式子转&lt;code&gt;long long&lt;/code&gt;时，不能写成&lt;code&gt;(long long)(1&amp;lt;&amp;lt;d)&lt;/code&gt;，而是&lt;code&gt;((long long)1&amp;lt;&amp;lt;d)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="可持久化trie" scheme="https://tth37.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie/"/>
    
      <category term="异或" scheme="https://tth37.cn/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="二叉堆" scheme="https://tth37.cn/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>公告 2019-04-08</title>
    <link href="https://tth37.cn/2019/04/08/bulletin-2019-4-8/"/>
    <id>https://tth37.cn/2019/04/08/bulletin-2019-4-8/</id>
    <published>2019-04-08T15:46:27.000Z</published>
    <updated>2019-04-23T15:51:02.197Z</updated>
    
    <content type="html"><![CDATA[<p><strong>tth37 Blog</strong>已经绑定了最新域名：tth37.cn ！(购买自阿里云)</p><p><del>由于一些奇怪的原因（DNS域名解析和CNAME配置问题），我的博客在四月七日至四月八日出现许多异常，现已全部修复。</del></p><p>但在四月九日至四月十日的测试中，我被疯狂打脸；现在已经可以保证，只要在浏览器输入栏输入 tth37.cn，即可自动跳转<a href="https://tth37.cn，并在*CloudFlare*证书授权下安全运行。" target="_blank" rel="noopener">https://tth37.cn，并在*CloudFlare*证书授权下安全运行。</a></p><p>请大佬们在新域名下体验高速加载和流畅访问新体验吧！</p><p>另外，左侧边栏“日程表”已经启用；网站基本搭建完毕。以后将缩减网站维护时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;tth37 Blog&lt;/strong&gt;已经绑定了最新域名：tth37.cn ！(购买自阿里云)&lt;/p&gt;
&lt;p&gt;&lt;del&gt;由于一些奇怪的原因（DNS域名解析和CNAME配置问题），我的博客在四月七日至四月八日出现许多异常，现已全部修复。&lt;/del&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="公告" scheme="https://tth37.cn/categories/%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>算法学习-可持久化数据结构</title>
    <link href="https://tth37.cn/2019/03/29/algorithm-persistentdatastructure/"/>
    <id>https://tth37.cn/2019/03/29/algorithm-persistentdatastructure/</id>
    <published>2019-03-29T11:19:42.000Z</published>
    <updated>2019-07-04T15:32:34.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可持久化数据结构可以存储数据集在任意时间的历史状态。“可持久化”的基本思想是在每项操作结束后，仅创建数据结构中发生改变的部分的副本，不拷贝其他部分。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，可持久化数据结构能够高效地记录一个数据结构的所有历史状态。</p><a id="more"></a><h2 id="可持久化Trie"><a href="#可持久化Trie" class="headerlink" title="可持久化Trie"></a>可持久化Trie</h2><h3 id="【实现过程】"><a href="#【实现过程】" class="headerlink" title="【实现过程】"></a>【实现过程】</h3><ol><li>设当前可持久化Trie的根节点为root，令p=root，i=0</li><li>建立一个新的节点，令root‘=q</li><li>若p!=0，则对于每种字符c，令trie[q,c]=trie[p,c]</li><li>建立一个新的节点q’，令trie[q,s]=q‘</li><li>令p=trie[p,s]，q=trie[q,s]，i=i+1</li><li>重复步骤3-5，直到i到达字符串末尾</li></ol><h3 id="【例题】最大异或和-luogu-p4735"><a href="#【例题】最大异或和-luogu-p4735" class="headerlink" title="【例题】最大异或和 luogu-p4735"></a>【例题】<a href="https://www.luogu.org/problemnew/show/P4735" target="_blank" rel="noopener">最大异或和</a> luogu-p4735</h3><p>给定一个非负整数序列{a}，初始长度为N。 </p><p>有M个操作，有以下两种操作类型： </p><ol><li><code>A x</code>：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。 </li><li><code>Q l r x</code>：询问操作，你需要找到一个位置p，满足l≤p≤r，使得： a[p]⊕a[p+1]⊕…⊕a[N]⊕x 最大，输出最大是多少。 </li></ol><h3 id="【分析】"><a href="#【分析】" class="headerlink" title="【分析】"></a>【分析】</h3><p>考虑异或前缀和。根据异或运算的性质：</p><script type="math/tex; mode=display">a[p]\oplus a[p+1]\oplus ...\oplus a[N]\oplus x=s[p-1]\oplus s[N]\oplus x</script><p>对于添加操作，序列s很容易维护。对于询问操作，问题变为：<strong>已知一个整数val=s[N] xor x，求一个位置p，满足l-1&lt;=p&lt;=r-1，使得s[p] xor val最大。</strong>显然可以将s数组插入可持久化Trie中，每次取出在l与r范围内的数据进行贪心（尽量往相反的节点走），从而求出答案。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)<span class="comment">//QwQ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">600005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEP=<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> trie[MAXN*<span class="number">26</span>][<span class="number">2</span>],sum[MAXN*<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> u,<span class="keyword">int</span> val,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    sum[u]=sum[c]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x=(val&gt;&gt;d)&amp;<span class="number">1</span>;</span><br><span class="line">    trie[u][!x]=trie[c][!x];</span><br><span class="line">    insert(trie[c][x],trie[u][x]=++cnt,val,d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> u,<span class="keyword">int</span> val,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x=(val&gt;&gt;d)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum[trie[u][!x]]&gt;sum[trie[c][!x]])</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;d)+query(trie[c][!x],trie[u][!x],val,d<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> query(trie[c][x],trie[u][x],val,d<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    insert(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,DEP);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]^a;</span><br><span class="line">        insert(head[i<span class="number">-1</span>],head[i]=++cnt,s[i],DEP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> opt;</span><br><span class="line">        getchar(),opt=getchar();</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            N++;</span><br><span class="line">            s[N]=s[N<span class="number">-1</span>]^a;</span><br><span class="line">            insert(head[N<span class="number">-1</span>],head[N]=++cnt,s[N],DEP);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r,a;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;a);</span><br><span class="line">            <span class="keyword">if</span>(l==r) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[l<span class="number">-1</span>]^s[N]^a);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(head[l<span class="number">-2</span>],head[r<span class="number">-1</span>],a^s[N],DEP));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可持久化数组"><a href="#可持久化数组" class="headerlink" title="可持久化数组"></a>可持久化数组</h2><h3 id="【例题】【模板】可持久化数组-luogu-p3919"><a href="#【例题】【模板】可持久化数组-luogu-p3919" class="headerlink" title="【例题】【模板】可持久化数组 luogu-p3919"></a>【例题】<a href="https://www.luogu.org/problemnew/show/P3919" target="_blank" rel="noopener">【模板】可持久化数组</a> luogu-p3919</h3><p>如题，你需要维护这样的一个长度为 N 的数组，支持如下几种操作</p><ol><li>在某个历史版本上修改某一个位置上的值</li><li>访问某个历史版本上的某一位置的值</li></ol><p>此外，每进行一次操作（<strong>对于操作2，即为生成一个完全一样的版本，不作任何改动</strong>），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）</p><h3 id="【分析】-1"><a href="#【分析】-1" class="headerlink" title="【分析】"></a>【分析】</h3><p>在原数组上建立线段树，在叶子节点上记录原数组数值。执行完修改操作后，根据可持久化的思想，只需更改一条链上的节点信息；执行完访问操作后，则可以将目前操作的根节点指针指向被查询的历史状态根节点。</p><p><img src="/images/1.png" alt></p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,val;</span><br><span class="line">&#125;node[MAXN*<span class="number">22</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,cnt;</span><br><span class="line"><span class="keyword">int</span> a[MAXN],head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Node&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        u.val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(node[u.l=++cnt],l,mid);</span><br><span class="line">    build(node[u.r=++cnt],mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Node c,Node&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        u.val=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid)&#123;</span><br><span class="line">        change(node[c.l],node[u.l=++cnt],l,mid,p,val);</span><br><span class="line">        u.r=c.r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        change(node[c.r],node[u.r=++cnt],mid+<span class="number">1</span>,r,p,val);</span><br><span class="line">        u.l=c.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> u.val;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid) <span class="keyword">return</span> query(node[u.l],l,mid,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(node[u.r],mid+<span class="number">1</span>,r,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    build(node[<span class="number">0</span>],<span class="number">1</span>,N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,opt,p,val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;opt);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;val);</span><br><span class="line">            change(node[head[v]],node[head[i]=++cnt],<span class="number">1</span>,N,p,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">            head[i]=head[v];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(node[head[i]],<span class="number">1</span>,N,p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可持久化值域线段树（主席树）"><a href="#可持久化值域线段树（主席树）" class="headerlink" title="可持久化值域线段树（主席树）"></a>可持久化值域线段树（主席树）</h2><h3 id="【例题】【模板】可持久化线段树-luogu-p3834"><a href="#【例题】【模板】可持久化线段树-luogu-p3834" class="headerlink" title="【例题】【模板】可持久化线段树 luogu-p3834"></a>【例题】<a href="https://www.luogu.org/problemnew/show/P3834" target="_blank" rel="noopener">【模板】可持久化线段树</a> luogu-p3834</h3><p>给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。</p><h3 id="【分析】-2"><a href="#【分析】-2" class="headerlink" title="【分析】"></a>【分析】</h3><p>值域有负数出现，考虑离散化。假设离散化后的值域为[1,L]。</p><p>在值域上建立线段树，每个节点上存储该值域内有多少个数据。对线段树进行可持久化处理，与上一题可持久化数组实现方式类似。</p><p>在查询时，如果一个节点的左子节点上的cnt值小于等于正在查询的K，则问题转化为求左半区间内第K小值；否则，转化为求右半区间内第K-cnt小值。</p><p>查询时的操作类似于在值域上的二分，因此复杂度在log级别。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x) (lower_bound(b+1,b+L+1,a[x])-b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rid(x) (b[x])</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;node[MAXN&lt;&lt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,L,cnt;</span><br><span class="line"><span class="keyword">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Node u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    u.sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(node[u.l=++cnt],l,mid);</span><br><span class="line">    build(node[u.r=++cnt],mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node c,Node&amp; u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    u.sum=c.sum+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],<span class="number">1</span>,mid,p),u.r=c.r;</span><br><span class="line">    <span class="keyword">else</span> insert(node[c.r],node[u.r=++cnt],mid+<span class="number">1</span>,r,p),u.l=c.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node c,Node u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> sum=node[u.l].sum-node[c.l].sum,mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> query(node[c.l],node[u.l],<span class="number">1</span>,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(node[c.r],node[u.r],mid+<span class="number">1</span>,r,k-sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+N+<span class="number">1</span>);</span><br><span class="line">    L=unique(b+<span class="number">1</span>,b+N+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">    head[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    build(node[<span class="number">0</span>],<span class="number">1</span>,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">        insert(node[head[i<span class="number">-1</span>]],node[head[i]=++cnt],<span class="number">1</span>,L,id(i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rid(query(node[head[l<span class="number">-1</span>]],node[head[r]],<span class="number">1</span>,L,k)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;可持久化数据结构可以存储数据集在任意时间的历史状态。“可持久化”的基本思想是在每项操作结束后，仅创建数据结构中发生改变的部分的副本，不拷贝其他部分。这样一来，维护数据结构的时间复杂度没有增加，空间复杂度仅增长为与时间同级的规模。换言之，可持久化数据结构能够高效地记录一个数据结构的所有历史状态。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数据结构" scheme="https://tth37.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可持久化trie" scheme="https://tth37.cn/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie/"/>
    
      <category term="主席树" scheme="https://tth37.cn/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="线段树" scheme="https://tth37.cn/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p4516潜入行动</title>
    <link href="https://tth37.cn/2019/03/28/solution-luogu-p4516/"/>
    <id>https://tth37.cn/2019/03/28/solution-luogu-p4516/</id>
    <published>2019-03-27T17:11:44.000Z</published>
    <updated>2019-05-12T13:00:49.081Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个并不简单的背包类树形dp……</p><p><del>很自然地</del>想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。</p><p>状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是：</p><script type="math/tex; mode=display">f[u][i+j]=combine(f[u][i],f[v][j])</script><p>相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为：</p><script type="math/tex; mode=display">f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]</script><script type="math/tex; mode=display">f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])</script><script type="math/tex; mode=display">f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1]</script><script type="math/tex; mode=display">f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))</script><p>具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">105</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">105</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Mod</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    x%=mod,y%=mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(x+y)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=f[u][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=*it;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dp(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=min(size[u],K);++i)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>][<span class="number">0</span>]=f[u][i][<span class="number">0</span>][<span class="number">0</span>],f[u][i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            g[i][<span class="number">0</span>][<span class="number">1</span>]=f[u][i][<span class="number">0</span>][<span class="number">1</span>],f[u][i][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            g[i][<span class="number">1</span>][<span class="number">0</span>]=f[u][i][<span class="number">1</span>][<span class="number">0</span>],f[u][i][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            g[i][<span class="number">1</span>][<span class="number">1</span>]=f[u][i][<span class="number">1</span>][<span class="number">1</span>],f[u][i][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=min(size[u],K);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=min(size[v],K-i);++j)&#123;</span><br><span class="line">                f[u][i+j][<span class="number">0</span>][<span class="number">0</span>]=Mod((ll)f[u][i+j][<span class="number">0</span>][<span class="number">0</span>],(ll)g[i][<span class="number">0</span>][<span class="number">0</span>]*(ll)f[v][j][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                f[u][i+j][<span class="number">0</span>][<span class="number">1</span>]=Mod((ll)f[u][i+j][<span class="number">0</span>][<span class="number">1</span>],(ll)g[i][<span class="number">0</span>][<span class="number">0</span>]*(ll)f[v][j][<span class="number">1</span>][<span class="number">1</span>]+(ll)g[i][<span class="number">0</span>][<span class="number">1</span>]*((ll)f[v][j][<span class="number">1</span>][<span class="number">1</span>]+(ll)f[v][j][<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">                f[u][i+j][<span class="number">1</span>][<span class="number">0</span>]=Mod((ll)f[u][i+j][<span class="number">1</span>][<span class="number">0</span>],(ll)g[i][<span class="number">1</span>][<span class="number">0</span>]*((ll)f[v][j][<span class="number">0</span>][<span class="number">0</span>]+(ll)f[v][j][<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">                f[u][i+j][<span class="number">1</span>][<span class="number">1</span>]=Mod((ll)f[u][i+j][<span class="number">1</span>][<span class="number">1</span>],(ll)g[i][<span class="number">1</span>][<span class="number">0</span>]*((ll)f[v][j][<span class="number">1</span>][<span class="number">0</span>]+(ll)f[v][j][<span class="number">1</span>][<span class="number">1</span>])+(ll)g[i][<span class="number">1</span>][<span class="number">1</span>]*((ll)f[v][j][<span class="number">0</span>][<span class="number">0</span>]+(ll)f[v][j][<span class="number">0</span>][<span class="number">1</span>]+(ll)f[v][j][<span class="number">1</span>][<span class="number">0</span>]+(ll)f[v][j][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(<span class="keyword">int</span>)(f[<span class="number">1</span>][K][<span class="number">0</span>][<span class="number">1</span>]+f[<span class="number">1</span>][K][<span class="number">1</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个并不简单的背包类树形dp……&lt;/p&gt;
&lt;p&gt;&lt;del&gt;很自然地&lt;/del&gt;想到状态定义：$f[u][k][0/1][0/1]$表示以$u$为根的子树中，总共选择$k$个结点，其中除了$u$以外的所有结点均被监听到，$u$结点选或不选，$u$结点是否被覆盖的情况下，一共有多少种方案。&lt;/p&gt;
&lt;p&gt;状态转移看似十分麻烦。每个结点$u$都有许多子结点，很难统计出每个子结点的所有情况（似乎在组合数学的范畴）。但是我们可以用十分巧妙的树形背包来进行状态转移。树上背包的转移套路是：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i+j]=combine(f[u][i],f[v][j])&lt;/script&gt;&lt;p&gt;相当于每递归访问完一个子结点，就把子节点上的状态与当前已经处理的状态一一配对，保证不重不漏且兼顾效率。具体的转移方程为：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1]&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))&lt;/script&gt;&lt;p&gt;具体实现时还应注意：因为阶段（即扫描子结点个数）的划分，在每次转移前都要先记录原始的$u$结点上的数据，否则会导致混乱。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-背包类树形dp</title>
    <link href="https://tth37.cn/2019/03/25/algorithm-knapsacktreedp/"/>
    <id>https://tth37.cn/2019/03/25/algorithm-knapsacktreedp/</id>
    <published>2019-03-25T15:21:45.000Z</published>
    <updated>2019-05-12T11:10:35.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树形分组背包"><a href="#树形分组背包" class="headerlink" title="树形分组背包"></a>树形分组背包</h2><h3 id="【例题】-选课-luogu-p2014"><a href="#【例题】-选课-luogu-p2014" class="headerlink" title="【例题】 选课 luogu-p2014 "></a>【例题】 <a href="https://www.luogu.org/problemnew/show/P2014" target="_blank" rel="noopener"><strong>选课</strong></a> <strong>luogu-p2014 </strong></h3><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p><h3 id="【分析】"><a href="#【分析】" class="headerlink" title="【分析】"></a>【分析】</h3><p>记录状态：$f[u][i]$为以$u$为根的子树上，选择$i$门课所能获得的最大学分。</p><p>记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。那么在$u$上相当于有一个容量为$M$的背包，每个子树中不同的状态相当于不同的物品，例如$f[v][j]$为体积为$j$，价值为$f[v][j]$中存储的数值。</p><p>在本题中，由于所有关系构成森林结构，因此可以设$0$号结点为“没有先修课”的课的先修课。然后以$0$为根，进行状态转移即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">305</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">305</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN],f[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=son[u].begin();it!=son[u].end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=*it;</span><br><span class="line">        dp(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=M;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">                f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=M;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">            f[u][i]=f[u][i<span class="number">-1</span>]+a[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k,s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;s);</span><br><span class="line">        son[k].Pb(i);a[i]=s;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">0</span>][M]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【例题】有线电视网-luogu-p1273"><a href="#【例题】有线电视网-luogu-p1273" class="headerlink" title="【例题】有线电视网 luogu-p1273"></a>【例题】<a href="https://www.luogu.org/fe/problem/P1273" target="_blank" rel="noopener">有线电视网</a> luogu-p1273</h3><p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。</p><p>从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。</p><p>现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。</p><p>写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p><h3 id="【分析】-1"><a href="#【分析】-1" class="headerlink" title="【分析】"></a>【分析】</h3><p>记录状态：$f[i][j]$为以$i$为根，选择$j$个用户最多有多少收入。状态转移时如果无法从正面入手（如本题不知道价格的最值，且价值分布更为稀疏），可以从反面设计状态，在输出答案时进行判断即可。转移时可以记录$size$数组进行优化。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;mem[<span class="number">3005</span>*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">3005</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> size[<span class="number">3005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    mem[++cnt].v=v;</span><br><span class="line">    mem[cnt].w=w;</span><br><span class="line">    mem[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> leaf[<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leaf[u])&#123;</span><br><span class="line">        f[u][<span class="number">1</span>]=leaf[u];</span><br><span class="line">        size[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=mem[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=mem[i].v,w=mem[i].w;</span><br><span class="line">        dfs(v);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=M;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(size[v],j);++k)</span><br><span class="line">                f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N-M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;c);</span><br><span class="line">            AddEdge(i,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;leaf[N-M+i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i) f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=M;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合计数类树形背包"><a href="#组合计数类树形背包" class="headerlink" title="组合计数类树形背包"></a>组合计数类树形背包</h2><h3 id="【例题】树的独立集-（原创）"><a href="#【例题】树的独立集-（原创）" class="headerlink" title="【例题】树的独立集 （原创）"></a>【例题】树的独立集 （原创）</h3><p>给定一棵有$N$个结点的树，输出这棵树中包含$K$个结点的独立集个数。</p><h3 id="【分析】-2"><a href="#【分析】-2" class="headerlink" title="【分析】"></a>【分析】</h3><p>有关组合计数的背包类树形dp问题，一般均可用以下方式解决。</p><p>记录状态：$f[u][k][0/1]$ 为以$u$为根的子树，$u$的状态为选或不选，共选择$k$个结点时独立集的个数。</p><p>记$u$为当前正在处理的结点，$v$为刚刚递归访问结束的结点。每递归访问结束一个子结点，就考虑把该子结点的状态与已经处理一部分的当前结点状态相匹配。每访问完一个结点，就把配对后产生的状态归为已处理的状态。由于需要根据之前的状态推导后续状态，因此不难看出利用到背包的思想。</p><p><img src="/images/2.png" alt></p><p>状态转移方程的基本思想如下：</p><script type="math/tex; mode=display">f[u][i+j][(state)]=combine(f[u][i][(state)]*f[u][j][(state)])</script><p>本题的状态转移方程也不难推出：</p><script type="math/tex; mode=display">f[u][0][i+j]=\sum f[u][0][i]*(f[v][0][j]+f[v][1][j])</script><script type="math/tex; mode=display">f[u][1][i+j]=\sum f[u][1][i]*f[v][0][j]</script><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> fa,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,f[u][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=*it;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dp(u,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=min(K,size[u]);++i)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>]=f[u][i][<span class="number">0</span>],f[u][i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            g[i][<span class="number">1</span>]=f[u][i][<span class="number">1</span>],f[u][i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=min(K,size[u]);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=min(K-i,size[v]);++j)&#123;</span><br><span class="line">                f[u][i+j][<span class="number">0</span>]+=g[i][<span class="number">0</span>]*(f[v][j][<span class="number">0</span>]+f[v][j][<span class="number">1</span>]);</span><br><span class="line">                f[u][i+j][<span class="number">1</span>]+=g[i][<span class="number">1</span>]*f[v][j][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dp(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][K][<span class="number">0</span>]+f[<span class="number">1</span>][K][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><a href="https://www.luogu.org/problemnew/show/P4516" target="_blank" rel="noopener">潜入行动</a></p><p>未完待续~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;树形分组背包&quot;&gt;&lt;a href=&quot;#树形分组背包&quot; class=&quot;headerlink&quot; title=&quot;树形分组背包&quot;&gt;&lt;/a&gt;树形分组背包&lt;/h2&gt;&lt;h3 id=&quot;【例题】-选课-luogu-p2014&quot;&gt;&lt;a href=&quot;#【例题】-选课-luogu-p201
      
    
    </summary>
    
      <category term="算法学习" scheme="https://tth37.cn/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="动态规划" scheme="https://tth37.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包" scheme="https://tth37.cn/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形dp" scheme="https://tth37.cn/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p2774方格取数问题</title>
    <link href="https://tth37.cn/2019/03/24/solution-luogu-p2774/"/>
    <id>https://tth37.cn/2019/03/24/solution-luogu-p2774/</id>
    <published>2019-03-24T14:16:21.000Z</published>
    <updated>2019-07-03T08:35:15.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P2774" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。</p><p>首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。</p><p><img src="https://i.loli.net/2019/03/24/5c979a716191f.png" alt></p><p>源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。</p><p><img src="https://i.loli.net/2019/03/24/5c979a7163abf.png" alt></p><p>如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。</p><p>问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,S,T;</span><br><span class="line">ll sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ny[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;mem[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    mem[++cnt].w=w;</span><br><span class="line">    mem[cnt].v=v;</span><br><span class="line">    mem[cnt].nxt=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[S]=<span class="number">1</span>;d[S]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=mem[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=mem[i].v,w=mem[i].w;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]||(w==<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v]=<span class="number">1</span>;d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rflow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=mem[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=mem[i].v,w=mem[i].w;</span><br><span class="line">        <span class="keyword">if</span>(w==<span class="number">0</span>||d[u]+<span class="number">1</span>!=d[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(rflow=dfs(v,min(flow,w)))&#123;</span><br><span class="line">            mem[i].w-=rflow;</span><br><span class="line">            mem[i^<span class="number">1</span>].w+=rflow;</span><br><span class="line">            <span class="keyword">return</span> rflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>,lowflow;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">while</span>(lowflow=dfs(S,INF)) maxflow+=lowflow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;M,&amp;N);</span><br><span class="line">    S=<span class="number">0</span>,T=M*N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">            sum+=w;</span><br><span class="line">            <span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                AddEdge(S,(i<span class="number">-1</span>)*N+j,w);</span><br><span class="line">                AddEdge((i<span class="number">-1</span>)*N+j,S,INF);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tx=i+nx[k],ty=j+ny[k];</span><br><span class="line">                    <span class="keyword">if</span>(tx&lt;<span class="number">1</span>||tx&gt;M||ty&lt;<span class="number">1</span>||ty&gt;N) <span class="keyword">continue</span>;</span><br><span class="line">                    AddEdge((i<span class="number">-1</span>)*N+j,(tx<span class="number">-1</span>)*N+ty,INF);</span><br><span class="line">                    AddEdge((tx<span class="number">-1</span>)*N+ty,(i<span class="number">-1</span>)*N+j,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                AddEdge((i<span class="number">-1</span>)*N+j,T,w);</span><br><span class="line">                AddEdge(T,(i<span class="number">-1</span>)*N+j,INF);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum-Dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2774&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不难发现，每个方格会与其上下左右四个方格产生矛盾。编程的任务即找到一种不产生矛盾的选择方案，并且使得取出的数总和最大。&lt;/p&gt;
&lt;p&gt;首先对图进行黑白染色，目的是使产生矛盾的两个位置分别位于不同的色块中，方便建图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/24/5c979a716191f.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;源点与所有白色位置相连，权值为该位置上的数字；所有黑色位置与汇点相连，权值也为该位置上的数字；所有白色位置与其上下左右（注意边界情况）的黑色位置相连，权值为无穷大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/24/5c979a7163abf.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;如此建图后，可以发现存在源点到汇点的增广路，这也意味着原图中存在产生矛盾的两个位置。假设一开始选取M*N网格中的所有方块，我们的任务是割掉网络中的一些边（即删去一些方块），使得割去的边权最小。割去网络中的边就相当于删掉两个矛盾位置中的其中一个，因此当网络中不再有源点到汇点的增广路，就意味着矛盾全部消除。&lt;/p&gt;
&lt;p&gt;问题便转化为求解最小割（最大流）的问题。输出答案为全局和减去最小割。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="网络流" scheme="https://tth37.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>题目列表-网络流</title>
    <link href="https://tth37.cn/2019/03/24/list-networkflow/"/>
    <id>https://tth37.cn/2019/03/24/list-networkflow/</id>
    <published>2019-03-24T14:07:49.000Z</published>
    <updated>2019-05-12T11:10:53.718Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h5 id="方格取数问题（二分图-建模技巧）"><a href="#方格取数问题（二分图-建模技巧）" class="headerlink" title="方格取数问题（二分图+建模技巧）"></a><a href="https://www.luogu.org/problemnew/show/P2774" target="_blank" rel="noopener">方格取数问题</a>（二分图+建模技巧）</h5><p>将原图黑白染色，并保证产生矛盾的两个位置颜色不同。源点连接黑点，白点连接汇点，黑点连接与之产生矛盾的白点。通过 最大和=全局和-最小割，在建立的网络上跑最小割（最大流）即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;++j)&#123;</span><br><span class="line">           <span class="keyword">int</span> w;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">           sum+=w;</span><br><span class="line">           <span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">               AddEdge(S,(i<span class="number">-1</span>)*N+j,w);</span><br><span class="line">               AddEdge((i<span class="number">-1</span>)*N+j,S,INF);</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;++k)&#123;</span><br><span class="line">                   <span class="keyword">int</span> tx=i+nx[k],ty=j+ny[k];</span><br><span class="line">                   <span class="keyword">if</span>(tx&lt;<span class="number">1</span>||tx&gt;M||ty&lt;<span class="number">1</span>||ty&gt;N) <span class="keyword">continue</span>;</span><br><span class="line">                   AddEdge((i<span class="number">-1</span>)*N+j,(tx<span class="number">-1</span>)*N+ty,INF);</span><br><span class="line">                   AddEdge((tx<span class="number">-1</span>)*N+ty,(i<span class="number">-1</span>)*N+j,<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               AddEdge((i<span class="number">-1</span>)*N+j,T,w);</span><br><span class="line">               AddEdge(T,(i<span class="number">-1</span>)*N+j,INF);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;方格取数问题（二分图-建模技巧）&quot;&gt;&lt;a href=&quot;#方格取数问题（二分图-建模技巧）&quot; class=&quot;headerlink&quot; title=&quot;方格取数问题（二分图+建模技巧）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.or
      
    
    </summary>
    
      <category term="题目列表" scheme="https://tth37.cn/categories/%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>公告 2019-03-24</title>
    <link href="https://tth37.cn/2019/03/24/bulletin-2019-3-24/"/>
    <id>https://tth37.cn/2019/03/24/bulletin-2019-3-24/</id>
    <published>2019-03-24T05:13:13.000Z</published>
    <updated>2019-04-08T15:47:56.942Z</updated>
    
    <content type="html"><![CDATA[<p>2019/3/24，tth37搭建了这个github博客。</p><p>tth37希望在这个博客里记录一些自己学习OI的心得，并发布一些题解，贴出学习规划。</p><p>但tth37实在是太弱了，因此他会更新得十分缓慢。</p><p>另外，还请shiwt巨佬多多指教。</p><blockquote><p>任何一个伟大的思想，都有一个微不足道的开始。</p></blockquote><p>p.s. 可能会将洛谷博客上的文章搬运过来，所以有些文章的发布时间可能在此之前，请别见怪。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019/3/24，tth37搭建了这个github博客。&lt;/p&gt;
&lt;p&gt;tth37希望在这个博客里记录一些自己学习OI的心得，并发布一些题解，贴出学习规划。&lt;/p&gt;
&lt;p&gt;但tth37实在是太弱了，因此他会更新得十分缓慢。&lt;/p&gt;
&lt;p&gt;另外，还请shiwt巨佬多多指教。
      
    
    </summary>
    
      <category term="公告" scheme="https://tth37.cn/categories/%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>题目列表-动态规划</title>
    <link href="https://tth37.cn/2019/03/20/list-dp/"/>
    <id>https://tth37.cn/2019/03/20/list-dp/</id>
    <published>2019-03-20T11:24:57.000Z</published>
    <updated>2019-05-12T11:10:50.859Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h5 id="任务安排（斜率优化-费用提前计算）"><a href="#任务安排（斜率优化-费用提前计算）" class="headerlink" title="任务安排（斜率优化+费用提前计算）"></a><a href="https://loj.ac/problem/10185" target="_blank" rel="noopener">任务安排</a>（斜率优化+费用提前计算）</h5><script type="math/tex; mode=display">f[i]=min_{0\le j<i}\{f[j]-(S+T[i])\*C[i]+T[i]\*C[i]+S\*C[N]\}</script></li></ol><hr><ol><li><h5 id="特别行动队（斜率优化）"><a href="#特别行动队（斜率优化）" class="headerlink" title="特别行动队（斜率优化）"></a><a href="https://www.luogu.org/problemnew/show/P3628" target="_blank" rel="noopener">特别行动队</a>（斜率优化）</h5><script type="math/tex; mode=display">f[i]=max_{0\le j<i}\{f[j]+A\*(S[i]-S[j])^2+B\*(S[i]-S[j])+C\}</script></li></ol><hr><ol><li><h5 id="玩具装箱（斜率优化）"><a href="#玩具装箱（斜率优化）" class="headerlink" title="玩具装箱（斜率优化）"></a><a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener">玩具装箱</a>（斜率优化）</h5><script type="math/tex; mode=display">f[i]=min_{0\le j<i}\{f[j]+(A[i]-A[j]-L-1)^2\}</script><p>斜率优化的适用范围是只有一个自变量。</p><p>形如这样的转移方程：</p><script type="math/tex; mode=display">f[i]=min_{0\le j<i}\{f[j]+(i-j+S[i]-S[j]-L-1)^2\}</script><p>操作难度较大，可以将$S[i]+i$存在$A$数组中，即可全部化为一个自变量。</p></li></ol><hr><ol><li><h5 id="锯木厂选址（斜率优化）"><a href="#锯木厂选址（斜率优化）" class="headerlink" title="锯木厂选址（斜率优化）"></a><a href="https://www.luogu.org/problemnew/show/P4360" target="_blank" rel="noopener">锯木厂选址</a>（斜率优化）</h5><script type="math/tex; mode=display">f[i]=min_{1\le j<i}\{C[i-1]-W[j]*(D[i]-D[j])\}</script></li></ol><hr><ol><li><h5 id="打印文章（斜率优化）"><a href="#打印文章（斜率优化）" class="headerlink" title="打印文章（斜率优化）"></a><a href="https://loj.ac/problem/10191" target="_blank" rel="noopener">打印文章</a>（斜率优化）</h5><script type="math/tex; mode=display">f[i]=min_{0\le j<i}\{f[j]+(S[i]-S[j])^2+M\}</script>调到心态爆炸……getK函数中如果除数为0则要返回1e100</li></ol><hr><ol><li><h5 id="序列分割（斜率优化）"><a href="#序列分割（斜率优化）" class="headerlink" title="序列分割（斜率优化）"></a><a href="https://www.luogu.org/problemnew/show/P3648" target="_blank" rel="noopener">序列分割</a>（斜率优化）</h5><script type="math/tex; mode=display">f[i][j]=max_{0 \le k<j}\{f[i-1][k]+S[k]*(S[j]-S[k])\}</script><p>不开long long见祖宗。题目中如果说“非负整数”一定记得判断除数是否为0。</p><p>对于转移方程中的第一维，稍加观察就会发现可以使用滚动数组。（虽然也需要一些额外的数组记录状态）</p></li></ol><hr><ol><li><h5 id="绿色通道（二分答案-单调队列）"><a href="#绿色通道（二分答案-单调队列）" class="headerlink" title="绿色通道（二分答案+单调队列）"></a><a href="https://loj.ac/problem/10181" target="_blank" rel="noopener">绿色通道</a>（二分答案+单调队列）</h5><script type="math/tex; mode=display">f[i]=min_{i-M-1 \le j <i}\{f[j]+a[i]\}</script></li></ol><p>   二分发怒程度$M$，$f$数组中存储选择当前题目最少多少体力。统计最终答案只需检验最后$M$个状态即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=N-M;i&lt;=N;++i) ans=min(ans,f[i]);</span><br></pre></td></tr></table></figure><hr><ol><li><h5 id="股票交易（单调队列-很多条件）"><a href="#股票交易（单调队列-很多条件）" class="headerlink" title="股票交易（单调队列+很多条件）"></a><a href="https://www.luogu.org/problemnew/show/P2569" target="_blank" rel="noopener">股票交易</a>（单调队列+很多条件）</h5><script type="math/tex; mode=display">f[i][j]=-AP[i]*j(0 \le j \le AS[i])</script><script type="math/tex; mode=display">f[i][j]=max\{f[i][j],f[i-1][j]\}(0 \le j \le M)</script><script type="math/tex; mode=display">f[i][j]=max_{j-AS[i] \le k<j}\{f[i-W-1][k]-(j-k)*AP[i]\}(0 \le j \le M)</script><script type="math/tex; mode=display">f[i][j]=max_{j<k \le j+BS[i]}\{f[i-W-1][k]+(k-j)*BP[i]\}(0 \le j \le M)</script><p>条件特别多，需要仔细分析题意并且列出状态转移方程。先进行较简单的转移，再利用单调队列进行复杂转移。注意第四种状态转移要使用逆序循环。</p><p><del>如此恶心的状态转移让我不禁想起<a href="https://www.luogu.org/problemnew/show/P1941" target="_blank" rel="noopener">飞扬的小鸟</a></del></p></li></ol><hr><ol><li><h5 id="潜入行动（背包类树形dp）"><a href="#潜入行动（背包类树形dp）" class="headerlink" title="潜入行动（背包类树形dp）"></a><a href="https://www.luogu.org/problemnew/show/P4516" target="_blank" rel="noopener">潜入行动</a>（背包类树形dp）</h5><script type="math/tex; mode=display">f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1]</script><script type="math/tex; mode=display">f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1])</script><script type="math/tex; mode=display">f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1]</script><script type="math/tex; mode=display">f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))</script><p><a href="https://tth37.cn/2019/03/28/solution-luogu-p4516/">题解链接</a></p><p>特别注意空间问题，中间运算转<code>long long</code>，保存时再转<code>int</code></p></li></ol><hr><ol><li><h5 id="子串（线性dp-滚动数组）"><a href="#子串（线性dp-滚动数组）" class="headerlink" title="子串（线性dp+滚动数组）"></a><a href="https://www.luogu.org/fe/problem/P2679" target="_blank" rel="noopener">子串</a>（线性dp+滚动数组）</h5><script type="math/tex; mode=display">f[i][0][0][0]=1</script><script type="math/tex; mode=display">f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][k][1]</script><script type="math/tex; mode=display">a[i]=b[j]:f[i][j][k][1]=f[i-1][j-1][k][1]+f[i-1][j-1][k-1][0]+f[i-1][j-1][k-1][1]</script><script type="math/tex; mode=display">a[i] \ne b[j]:f[i][j][k][1]=0</script><p>滚动数组注意点：</p><ul><li>状态转移方程只依赖前一维或前两维状态</li><li>状态数组要被滚动的一维只开1或2</li><li>对于0/1滚动数组，可以结合位运算<code>&amp;</code>和<code>^</code>进行判断奇偶性和减一操作</li></ul></li></ol><hr><ol><li><h5 id="换教室（期望dp）"><a href="#换教室（期望dp）" class="headerlink" title="换教室（期望dp）"></a><a href="https://www.luogu.org/fe/problem/P1850" target="_blank" rel="noopener">换教室</a>（期望dp）</h5><script type="math/tex; mode=display">f[i][j][0]=min\{f[i-1][j][0]+dis[C[i-1]][C[i]],f[i-1][j][1]+K[i-1]\*dis[D[i-1]][C[i]]+(1-K[i-1])\*dis[C[i-1]][C[i]]\}</script><script type="math/tex; mode=display">f[i][j][1]=min\{f[i-1][j-1][0]+K[i]\*dis[C[i-1]][D[i]]+(1-K[i])\*dis[C[i-1]][C[i]],f[i-1][j-1][1]+K[i-1]\*K[i]\*dis[D[i-1]][D[i]]+K[i-1]\*(1-K[i])\*dis[D[i-1]][C[i]]+(1-K[i-1])\*K[i]\*dis[C[i-1]][D[i]]+(1-K[i-1])\*(1-K[i])\*dis[C[i-1]][C[i]]\}</script><p>期望dp可以单独开一维表示状态，以便于列举出所有情况。本题的转移方程是一个很好的例子。<del>如果tth37开心的话，Ta可能会写一篇数学期望专题具体讲解此类题目。</del></p></li></ol><hr><ol><li><h5 id="过河（线性dp-玄学离散化）"><a href="#过河（线性dp-玄学离散化）" class="headerlink" title="过河（线性dp+玄学离散化）"></a><a href="https://www.luogu.org/problemnew/show/P1052" target="_blank" rel="noopener">过河</a>（线性dp+玄学离散化）</h5><script type="math/tex; mode=display">f[i]=min_{S \le j \le T}\{f[i-j]+flag[i]\}</script><p>由于m非常小，因此采用2520缩点，即两点之间距离超过2520的，可以将距离改为$dis % 2520$，从而离散化。</p></li></ol><hr><ol><li><h5 id="统计单词个数（线性dp-字符串）"><a href="#统计单词个数（线性dp-字符串）" class="headerlink" title="统计单词个数（线性dp+字符串）"></a><a href="https://www.luogu.org/problemnew/show/P1026" target="_blank" rel="noopener">统计单词个数</a>（线性dp+字符串）</h5><script type="math/tex; mode=display">f[i][j]=max\{f[i][j],f[r][j-1]+g[r+1][i]\}</script><p>字符串处理使用string类find函数。</p><p>线性dp时再次强调，需要分清阶段、状态和决策变量；阶段在最外层循环，决策在最内层。在寻找关系时可以从推导或定义角度辨析，也可以根据转移方程进行识别。</p></li></ol><hr><ol><li><h5 id="有线电视网（背包类树形dp）"><a href="#有线电视网（背包类树形dp）" class="headerlink" title="有线电视网（背包类树形dp）"></a><a href="https://www.luogu.org/fe/problem/P1273" target="_blank" rel="noopener">有线电视网</a>（背包类树形dp）</h5><script type="math/tex; mode=display">f[u][i]=max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}</script><p><a href="https://tth37.cn/2019/04/25/solution-luogu-p1273/">题解链接</a></p></li></ol><hr><ol><li><h5 id="棋盘制作（单调栈）"><a href="#棋盘制作（单调栈）" class="headerlink" title="棋盘制作（单调栈）"></a><a href="https://www.luogu.org/problemnew/show/P1169" target="_blank" rel="noopener">棋盘制作</a>（单调栈）</h5><p>似乎没有转移方程</p><p>注意单调栈的处理方式（玄学方法或通用方法），在退栈时务必退干净。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//玄学方法：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N+<span class="number">1</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>&amp;&amp;a[s[cnt]]&gt;=a[i])&#123;</span><br><span class="line">        ans=max(ans,(i-s[cnt<span class="number">-1</span>]<span class="number">-1</span>)*a[s[cnt]]);</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    s[++cnt]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用方法：</span></span><br><span class="line">先处理出每个位置左边第一个比它小的，再处理出右边第一个比它小的，最后枚举</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;任务安排（斜率优化-费用提前计算）&quot;&gt;&lt;a href=&quot;#任务安排（斜率优化-费用提前计算）&quot; class=&quot;headerlink&quot; title=&quot;任务安排（斜率优化+费用提前计算）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://loj.ac/pr
      
    
    </summary>
    
      <category term="题目列表" scheme="https://tth37.cn/categories/%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1080国王游戏</title>
    <link href="https://tth37.cn/2019/01/26/solution-luogu-p1080/"/>
    <id>https://tth37.cn/2019/01/26/solution-luogu-p1080/</id>
    <published>2019-01-26T02:58:39.000Z</published>
    <updated>2019-05-12T13:00:29.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1080" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>高精度怎能少了Python3题解。。。</p><p>贪心策略一楼dalao已经讲得很清楚了，上一发超短代码（学Python就是为了水高精）</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">N=int(input())</span><br><span class="line">s=input().split()</span><br><span class="line">S=int(s[<span class="number">0</span>])</span><br><span class="line">T=int(s[<span class="number">1</span>])</span><br><span class="line">a=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">    k=input().split()</span><br><span class="line">    a.append((int(k[<span class="number">0</span>]),int(k[<span class="number">1</span>])))</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]*x[<span class="number">1</span>])</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,N):</span><br><span class="line">    <span class="keyword">if</span>(S//(a[i])[<span class="number">1</span>]&gt;ans):</span><br><span class="line">        ans=S//(a[i])[<span class="number">1</span>]</span><br><span class="line">    S*=(a[i])[<span class="number">0</span>]</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1080&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高精度怎能少了Python3题解。。。&lt;/p&gt;
&lt;p&gt;贪心策略一楼dalao已经讲得很清楚了，上一发超短代码（学Python就是为了水高精）&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="python" scheme="https://tth37.cn/tags/python/"/>
    
      <category term="贪心" scheme="https://tth37.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1022计算器的改良</title>
    <link href="https://tth37.cn/2018/12/19/solution-luogu-p1022/"/>
    <id>https://tth37.cn/2018/12/19/solution-luogu-p1022/</id>
    <published>2018-12-19T06:14:46.000Z</published>
    <updated>2019-07-18T14:47:45.284Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.org/problemnew/show/P1022" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>本题是一道非常漂亮的模拟。只要能理清思路，代码并不会特别复杂。</p><p>首先分析题目。解一元一次方程最简单的方法就是移项，把常数移到等号右侧，把一次项系数移到等号左侧，用常数除以系数即为答案。那么在读入字符串的过程中，便可以进行操作。</p><p>对于字符串中的数据，我们可以用类似快读的方法读入。然而，要判断这些数据从哪里来，到哪里去，便是本题的关键所在。</p><p>对于每个数据，要想清楚地辨别它的身份，我们只需解决<strong>三个问题</strong>：</p><p><strong>1.该数据是正数还是负数？</strong></p><p><strong>3.该数据在等号左侧还是在等号右侧？</strong></p><p><strong>2.该数据是常数还是系数？</strong></p><p>第一个问题看似十分无脑，用一个变量f1来存储符号即可（将f1赋值为1或-1，在读入数据结束时将得到的数据乘以f1）。但需<strong>特别注意</strong>，在一个表达式的开头（等号左侧和等号右侧的表达式）不会有‘+’、‘-’符号，所以在程序的开头和读入‘=’号是，要将f1赋值为1。</p><p>第二个问题也非常简单，可以用变量f2来存储。因为这个问题与移项运算的符号有关，因此也可以将f2赋值为1或-1，并约定在等号左侧时f2为1，在等号右侧时f2为-1。（当然你也可以反着约定）</p><p>第三个问题同样不难解决。在读入数据结束后（<strong>即读入了一个符号</strong>），判断这个符号是运算符还是字母即可。如果是字母，则将得到的数据移到等号右侧，否则将数据移到等号左侧。但是还有一个<strong>注意点</strong>：如果一个未知数的系数为1，我们会将系数省略。因此在读入数据为0时，我们要将其更改为1。</p><p>经过分析，你会发现本题一点也不难实现。其关键在于对数据状态的准确描述。用清晰、简洁的变量描述状态，根据不同的状态采取不同的措施，这便是编程学习的一大基本素养。</p><p>代码如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,r;<span class="comment">//l代表系数，r代表常数 </span></span><br><span class="line"><span class="keyword">char</span> x; <span class="comment">//用x存储字母 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> f1=<span class="number">1</span>,f2=<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)<span class="comment">//类似快读的读入方式 </span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp*=<span class="number">10</span>;</span><br><span class="line">            tmp+=c-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>) l+=(tmp==<span class="number">0</span>)?f2*f1:tmp*f2*f1,x=c;<span class="comment">//判断系数是否为1 </span></span><br><span class="line">            <span class="keyword">else</span> r+=tmp*(-f2)*f1;</span><br><span class="line">            tmp=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'+'</span>) &#123;f1=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) &#123;f1=<span class="number">-1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'='</span>) &#123;f2=<span class="number">-1</span>;f1=<span class="number">1</span>;<span class="keyword">continue</span>;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    solve(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c=%0.3f"</span>,x,(<span class="keyword">float</span>)r/l==<span class="number">0</span>?<span class="built_in">abs</span>((<span class="keyword">float</span>)r/l):(<span class="keyword">float</span>)r/l);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1022&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本题是一道非常漂亮的模拟。只要能理清思路，代码并不会特别复杂。&lt;/p&gt;
&lt;p&gt;首先分析题目。解一元一次方程最简单的方法就是移项，把常数移到等号右侧，把一次项系数移到等号左侧，用常数除以系数即为答案。那么在读入字符串的过程中，便可以进行操作。&lt;/p&gt;
&lt;p&gt;对于字符串中的数据，我们可以用类似快读的方法读入。然而，要判断这些数据从哪里来，到哪里去，便是本题的关键所在。&lt;/p&gt;
&lt;p&gt;对于每个数据，要想清楚地辨别它的身份，我们只需解决&lt;strong&gt;三个问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.该数据是正数还是负数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.该数据在等号左侧还是在等号右侧？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.该数据是常数还是系数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一个问题看似十分无脑，用一个变量f1来存储符号即可（将f1赋值为1或-1，在读入数据结束时将得到的数据乘以f1）。但需&lt;strong&gt;特别注意&lt;/strong&gt;，在一个表达式的开头（等号左侧和等号右侧的表达式）不会有‘+’、‘-’符号，所以在程序的开头和读入‘=’号是，要将f1赋值为1。&lt;/p&gt;
&lt;p&gt;第二个问题也非常简单，可以用变量f2来存储。因为这个问题与移项运算的符号有关，因此也可以将f2赋值为1或-1，并约定在等号左侧时f2为1，在等号右侧时f2为-1。（当然你也可以反着约定）&lt;/p&gt;
&lt;p&gt;第三个问题同样不难解决。在读入数据结束后（&lt;strong&gt;即读入了一个符号&lt;/strong&gt;），判断这个符号是运算符还是字母即可。如果是字母，则将得到的数据移到等号右侧，否则将数据移到等号左侧。但是还有一个&lt;strong&gt;注意点&lt;/strong&gt;：如果一个未知数的系数为1，我们会将系数省略。因此在读入数据为0时，我们要将其更改为1。&lt;/p&gt;
&lt;p&gt;经过分析，你会发现本题一点也不难实现。其关键在于对数据状态的准确描述。用清晰、简洁的变量描述状态，根据不同的状态采取不同的措施，这便是编程学习的一大基本素养。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="https://tth37.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="https://tth37.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>题解-luogu-p1204挤牛奶</title>
    <link href="https://tth37.cn/2018/12/15/solution-luogu-p1204/"/>
    <id>https://tth37.cn/2018/12/15/solution-luogu-p1204/</id>
    <published>2018-12-15T06:51:52.000Z</published>
    <updated>2019-05-12T13:00:14.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href>题目链接</a></p></blockquote><p>介绍一种本题的贪心解法。</p><p>本题要求读入一些挤牛奶的时间段，求最长至少有一人在挤牛奶的时间段和最长没有人在挤牛奶的时间段。把读入的区间视作线段，则题意转变为<strong>求至少有一条线段覆盖的最大区间和没有线段覆盖的区间</strong>。</p><p>假设读入数据如下：<br><img src="https://cdn.luogu.org/upload/pic/46260.png" alt="fig"></p><p>首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。</p><p>然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。</p><p>程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。</p><p>程序如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> begin,end;</span><br><span class="line">&#125;m[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.begin&lt;b.begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m[i].begin,&amp;m[i].end);</span><br><span class="line">sort(m+<span class="number">1</span>,m+<span class="number">1</span>+N,cmp);</span><br><span class="line"><span class="keyword">int</span> begin=m[<span class="number">1</span>].begin;</span><br><span class="line"><span class="keyword">int</span> end=m[<span class="number">1</span>].end;</span><br><span class="line"><span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(m[i].begin&lt;=end)</span><br><span class="line">end=max(end,m[i].end);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans1=max(ans1,end-begin);</span><br><span class="line">ans2=max(ans2,m[i].begin-end);</span><br><span class="line">begin=m[i].begin;</span><br><span class="line">end=m[i].end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans1=max(ans1,end-begin);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,ans1,ans2);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;介绍一种本题的贪心解法。&lt;/p&gt;
&lt;p&gt;本题要求读入一些挤牛奶的时间段，求最长至少有一人在挤牛奶的时间段和最长没有人在挤牛奶的时间段。把读入的区间视作线段，则题意转变为&lt;strong&gt;求至少有一条线段覆盖的最大区间和没有线段覆盖的区间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设读入数据如下：&lt;br&gt;&lt;img src=&quot;https://cdn.luogu.org/upload/pic/46260.png&quot; alt=&quot;fig&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。&lt;/p&gt;
&lt;p&gt;然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。&lt;/p&gt;
&lt;p&gt;程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。&lt;/p&gt;
&lt;p&gt;程序如下：&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://tth37.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="https://tth37.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="排序" scheme="https://tth37.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
