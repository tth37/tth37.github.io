<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p3960åˆ—é˜Ÿ]]></title>
    <url>%2F2019%2F09%2F24%2Fsolution-luogu-p3960%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ é¢˜ç›®æ¦‚æ‹¬å¾é›†ä¸­~ ä¸€é“éå¸¸æœ‰æ„æ€çš„é¢˜ã€‚ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç¥å¥‡çš„æ•°æ®ç»“æ„ï¼Œå®ƒå¯ä»¥åŠ¨æ€åœ°ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„é˜Ÿåˆ—ï¼Œå…¶åˆå§‹å…ƒç´ ä¸º $1,2,â€¦,n$ ã€‚è¯¥é˜Ÿåˆ—å¯ä»¥æ”¯æŒä¸¤ç§æ“ä½œï¼Œç¬¬ä¸€ç§ä¸ºåˆ é™¤é˜Ÿåˆ—çš„ç¬¬ $k$ é¡¹å…ƒç´ ï¼Œæ‰§è¡Œâ€œå‘å‰çœ‹é½â€æ“ä½œï¼Œå¹¶åœ¨é˜Ÿåˆ—çš„æœ«å°¾è¡¥å…… $n+1$ ï¼ˆä»¥æ­¤ç±»æ¨ï¼‰ã€‚ç¬¬äºŒç§ä¸ºæŸ¥è¯¢é˜Ÿåˆ—çš„ç¬¬ $k$ é¡¹å…ƒç´ çš„æ•°å€¼ã€‚ æ‹¥æœ‰è¿™æ ·ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæœ¬é¢˜å°±ç®€å•å¤šäº†ï¼›è§‚å¯Ÿåˆ°â€œå‘å‰çœ‹é½â€å‘½ä»¤åªå¯¹æœ€åä¸€åˆ—äº§ç”Ÿå½±å“ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸€è¡Œç»´æŠ¤ä¸€ä¸ªåŠ¨æ€é˜Ÿåˆ—ï¼Œæœ€åä¸€åˆ—ç”¨å¦ä¸€ä¸ªåŠ¨æ€é˜Ÿåˆ—å•ç‹¬å¤„ç†ã€‚ å¦‚æœå‡ºåˆ—çš„åŒå­¦ä½äºæœ€åä¸€åˆ—ï¼Œåˆ™åªéœ€å¯¹æœ€åä¸€åˆ—è¿›è¡Œä¸€æ¬¡åˆ é™¤æ“ä½œå³å¯ï¼›å¦‚æœå‡ºåˆ—çš„åŒå­¦ä¸åœ¨æœ€åä¸€åˆ—ï¼Œåˆ™éœ€è¦å¯¹å‡ºåˆ—åŒå­¦æ‰€åœ¨çš„é‚£ä¸€è¡Œä¸æœ€åä¸€åˆ—åŒæ—¶è¿›è¡Œæ“ä½œã€‚å®ç°ç»†èŠ‚ä¸å†èµ˜è¿°ã€‚ ç°åœ¨æˆ‘ä»¬æ¥è€ƒè™‘ä¸€ä¸‹å¦‚ä½•å®ç°ç¥å¥‡çš„åŠ¨æ€é˜Ÿåˆ—ã€‚åœ¨æœ¬é¢˜çš„æƒ…å†µä¸­ï¼Œå‡è®¾æ¯ä¸ªåŠ¨æ€é˜Ÿåˆ—æœ€å¤šæœ‰ $Q$ æ¬¡åˆ é™¤æ“ä½œï¼Œé‚£ä¹ˆåŠ¨æ€é˜Ÿåˆ—çš„æ—¶ç©ºå¤æ‚åº¦å¿…é¡»åªä¸ $Q$ ç›¸å…³ï¼Œå¦åˆ™ $O(n^2)$ çš„æ—¶ç©ºå¤æ‚åº¦æ— æ³•æ‰¿å—ã€‚ä¼¼ä¹è¿™é‡Œå¯ä»¥ç”¨å¹³è¡¡æ ‘å®ç°ï¼Œè€Œæˆ‘é‡‡ç”¨äº†è¾ƒä¸ºå¥½å†™çš„åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘æ¥ç»´æŠ¤åŠ¨æ€é˜Ÿåˆ—ã€‚ åˆå§‹çŠ¶æ€ï¼Œæƒå€¼çº¿æ®µæ ‘ä¸‹æ ‡ä¸º $1,2,â€¦,n$ çš„èŠ‚ç‚¹å¤§å°å‡ä¸º $1$ ã€‚å¯¹äºåˆ é™¤æ“ä½œï¼Œæˆ‘ä»¬åªéœ€å°†å¯¹åº”çš„æƒå€¼å¤§å°å‡ä¸€ï¼Œå¹¶åœ¨æƒå€¼ $n+1$ çš„å¤§å°åŠ ä¸€å³å¯ã€‚å¯¹äºæŸ¥è¯¢æ“ä½œï¼Œåªéœ€åœ¨æƒå€¼çº¿æ®µæ ‘ä¸­æŸ¥è¯¢ç¬¬ $k$ å°å…ƒç´ å³ä¸ºå¯¹åº”æ•°å€¼ã€‚å®ç°ç»†èŠ‚åŒæ ·ä¸å†èµ˜è¿°ã€‚ è®°å¾—å¼€ long long ã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define lson(u) (node[u].l)#define rson(u) (node[u].r)#define sum(u) (node[u].sum)using namespace std;typedef long long ll;const int MAXN = 300005;struct Node &#123; int l, r, sum;&#125;node[MAXN * 42];int cnt;int root[MAXN], size[MAXN];vector&lt;ll&gt; ins[MAXN];int N, M, Q, T;void modify(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; if (l == r) &#123; sum(u) += val; return; &#125; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) modify(lson(u), l, mid, p, val); else modify(rson(u), mid + 1, r, p, val); sum(u) = sum(lson(u)) + sum(rson(u));&#125;int query(int u, int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; int lsum = sum(lson(u)); if (l &lt;= T) &#123; lsum += (mid &gt; T) ? T - l + 1 : mid - l + 1; &#125; if (k &lt;= lsum) return query(lson(u), l, mid, k); else return query(rson(u), mid + 1, r, k - lsum);&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;Q); int Case = Q; while (Case--) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); ll ans = 0, tmp = 0; if (y == M) &#123; T = N; ans = query(root[N + 1], 1, N + Q, x); modify(root[N + 1], 1, N + Q, ans, -1); modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1); if (ans &lt;= N) ans = ans * (ll)M; else ans = ins[N + 1][ans - N - 1]; ins[N + 1].push_back(ans); printf("%lld\n", ans); &#125; else &#123; T = M - 1; ans = query(root[x], 1, M + Q, y); modify(root[x], 1, M + Q, ans, -1); modify(root[x], 1, M + Q, M - 1 + (++size[x]), 1); if (ans &lt;= M - 1) ans += (ll)(x - 1) * M; else ans = ins[x][ans - M]; T = N; tmp = query(root[N + 1], 1, N + Q, x); modify(root[N + 1], 1, N + Q, tmp, -1); modify(root[N + 1], 1, N + Q, N + (++size[N + 1]), 1); if (tmp &lt;= N) tmp = tmp * (ll)M; else tmp = ins[N + 1][tmp - N - 1]; ins[N + 1].push_back(ans); ins[x].push_back(tmp); printf("%lld\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ä¸»å¸­æ ‘</tag>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2680è¿è¾“è®¡åˆ’(Beta)]]></title>
    <url>%2F2019%2F09%2F20%2Fsolution-luogu-p2680%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ è¯æ˜åŠä¼˜åŒ–æ ‘ä¸Šè·¯å¾„æ±‚äº¤ç®—æ³•å å°†ä¼šåœ¨æ´›è°·åšå®¢ä¸Šå‘å¸ƒ è¿™æ˜¯ä¸€é“æš‘å‡é›†è®­è¢«åŠé€€çš„ç¥ä»™é¢˜ åœ¨ä»Šå¤©çš„ä¿¡æ¯è¯¾ä¸Šå¥‡è¿¹èˆ¬åœ°ä¸€éè¿‡ æ ¹æ®é¢˜æ„ï¼Œå°†æŸä¸€æ¡è¾¹çš„è¾¹æƒä» $w$ æ”¹ä¸º $0$ï¼Œå³ä¸ºå°†ç»è¿‡è¯¥æ¡è¾¹çš„è·¯å¾„æ€»é•¿åº¦å‡å» $w$ã€‚è€Œæˆ‘ä»¬è¦åšçš„ï¼Œå°±æ˜¯æ”¹é€ æ ‘ä¸Šçš„æŸä¸€æ¡è¾¹ï¼Œä½¿å¾—æœ€é•¿çš„è·¯å¾„é•¿åº¦æœ€çŸ­ã€‚ é¢˜ç›®ä¹ä¸€çœ‹å¯ä»¥äºŒåˆ†ï¼Œä½†åœ¨è¿™ç¯‡é¢˜è§£ä¸­é‡‡ç”¨è´ªå¿ƒç­–ç•¥ã€‚ é¦–å…ˆå°†æ‰€æœ‰è·¯å¾„æŒ‰ç…§é•¿åº¦é™åºæ’åºã€‚ä¸éš¾å‘ç°ï¼Œåªæœ‰åœ¨â€œæ”¹é€ â€æ“ä½œèƒ½å¤ŸåŒæ—¶å‡å°å‰ $x$ æ¡è·¯å¾„çš„é•¿åº¦ï¼Œè¯¥æ“ä½œæ‰æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå¦åˆ™ä¸ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®ã€‚ é‚£ä¹ˆå¦‚ä½•ä½¿â€œæ”¹é€ â€æ“ä½œåŒæ—¶å‡å°å‰ $x$ æ¡è·¯å¾„çš„é•¿åº¦å‘¢ï¼Ÿæ˜¾ç„¶ï¼Œæ­¤æ—¶é€‰å–çš„è¾¹ä¸€å®šå±äºå‰ $x$ æ¡è·¯å¾„çš„äº¤ã€‚è·¯å¾„çš„äº¤ä¸€å®šä»æ˜¯è·¯å¾„ï¼Œæ ¹æ®è´ªå¿ƒï¼Œåªéœ€åœ¨è·¯å¾„çš„äº¤ä¸Šé€‰å–æœ€å¤§çš„è¾¹æƒï¼Œå°†è¿™æ¡è¾¹çš„è¾¹æƒæ”¹ä¸º $0$ï¼Œç„¶åæ›´æ–°ç­”æ¡ˆå³å¯ã€‚ ä»…å‰©çš„é—®é¢˜åœ¨äºå¦‚ä½•å¿«é€Ÿæ±‚å‡ºå‰ $x$ æ¡è·¯å¾„çš„äº¤ã€‚è¿™é‡Œä»‹ç»ä¸€ç§ tth37 ç®—æ³•ã€‚ï¼ˆå¼€å§‹å£èƒ¡ï¼‰ å¼•ç†ï¼šè·¯å¾„ $p(u1,v1)$ ä¸ $p(u2,v2)$ å¦‚æœå­˜åœ¨äº¤ï¼Œåˆ™è·¯å¾„çš„äº¤çš„ç«¯ç‚¹ä¸€å®šä¸º $lca(u1,u2),lca(u1,v2),lca(v1,u2),lca(v1,v2)$ ä¸­åŒæ—¶å±äºä¸¤æ¡è·¯å¾„çš„æœ€è¿œç‚¹å¯¹ã€‚ å°šæœªè¯æ˜ã€‚æœªå®Œå¾…ç»­ã€‚]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å€å¢</tag>
        <tag>æœ€è¿‘å…¬å…±ç¥–å…ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1941é£æ‰¬çš„å°é¸Ÿ]]></title>
    <url>%2F2019%2F09%2F19%2Fsolution-luogu-p1941%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®š $n*m$ çš„æ¸¸æˆç•Œé¢ï¼Œæ±‚æ˜¯å¦å¯ä»¥é€šè¿‡æ“ä½œä½¿å°é¸Ÿé€šè¿‡æ‰€æœ‰ç®¡é“ä»¥åŠæœ€å°‘æ“ä½œæ¬¡æ•°ã€‚ $n\le 10000,m\le 1000$ è¿™ç¯‡åšå®¢ä¸ä¼šåœ¨æ´›è°·å‘è¡¨ï¼Œæ‰€ä»¥å†…å®¹å¯èƒ½æ¯”è¾ƒæ”¾é£è‡ªæˆ‘ã€‚ ç¥ä»™shiwtå·¨ä½¬æ—©åœ¨å»å¹´çš„è¿™ä¸ªæ—¶å€™å°±å·²ç»åˆ‡æ‰äº†è¿™ä¸ªç¥ä»™é¢˜ã€‚ è®° $f[i][j]$ è¡¨ç¤ºä»èµ·ç‚¹é£åˆ°åæ ‡ $(i,j)$ æ‰€éœ€çš„æœ€å°æ­¥æ•°ã€‚è€ƒè™‘ $f[i][j]$ çš„è½¬ç§»ã€‚å®ƒè¦ä¹ˆæ˜¯ä» $(i-1,j+Y)$ é‚£é‡Œæ‰ä¸‹æ¥çš„ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ä» $(i-1,j-kX)$ é‚£é‡Œå‡ä¸Šæ¥çš„ã€‚ è€ƒè™‘ä¼˜åŒ–ã€‚ $(i-1,j-kX)$ çš„æšä¸¾è¾ƒä¸ºå•°å—¦ï¼›ä¸éš¾å‘ç°å¦‚æœå°é¸ŸğŸ¦å¯ä»¥é£åˆ° $(i,j-X)$ ï¼Œé‚£ä¹ˆå®ƒå†é£ä¸€ä¸‹ä¸å°±åˆ° $(i,j)$ äº†å—ï¼Ÿ çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š f[i][j]=\min \{f[i-1][j+Y],f[i][j-X]+1,f[i-1][j-X]+1\}ä¸å¦¨å†™ä¸ªæ»šåŠ¨æ•°ç»„ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10005;const int MAXM = 1005;const int INF = 0x3f3f3f3f;int N, M, K;int X[MAXN], Y[MAXN];int L[MAXN], R[MAXN];int f[2][MAXM * 2];int cnt, minn;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;K); for (register int i = 1; i &lt;= N; ++i) scanf("%d%d", &amp;X[i], &amp;Y[i]); for (register int i = 1; i &lt;= K; ++i) &#123; int p, l, h; scanf("%d%d%d", &amp;p, &amp;l, &amp;h); L[p] = l, R[p] = h; &#125; for (register int i = 1; i &lt;= N; ++i) &#123; int cur = i &amp; 1; minn = INF; for (register int j = 0; j &lt;= M + X[i]; ++j) f[cur][j] = INF; for (register int j = X[i]; j &lt;= M + X[i]; ++j) f[cur][j] = min(f[cur][j], min(f[cur ^ 1][j - X[i]] + 1, f[cur][j - X[i]] + 1)); for (register int j = M + 1; j &lt;= M + X[i]; ++j) f[cur][M] = min(f[cur][M], f[cur][j]); for (register int j = 0; j &lt;= M - Y[i]; ++j) f[cur][j] = min(f[cur][j], f[cur ^ 1][j + Y[i]]); if (L[i] || R[i]) &#123; for (register int j = 0; j &lt;= L[i]; ++j) f[cur][j] = INF; for (register int j = R[i]; j &lt;= M; ++j) f[cur][j] = INF; &#125; f[cur][0] = INF; for (register int j = 0; j &lt;= M; ++j) minn = min(minn, f[cur][j]); if (minn == INF) &#123; puts("0"); printf("%d", cnt); return 0; &#125; cnt += L[i] || R[i]; &#125; puts("1"); printf("%d", minn); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1979åå®¹é“]]></title>
    <url>%2F2019%2F09%2F18%2Fsolution-luogu-p1979%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ª $n * m$ çš„æ£‹ç›˜ï¼Œå…± $q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®åœ¨åå®¹é“æ¸¸æˆä¸­å°†ç›®æ ‡å—ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®çš„æœ€å°‘æ­¥æ•° $n,m\le 30, q\le 300$ æœ¬é¢˜çš„æ­£è§£æ¯”è¾ƒéš¾æƒ³ï¼Œæ­£å¸¸äººçœ‹åˆ°è¿™é¢˜å¯èƒ½éƒ½ä¼šåœ¨æœç´¢å‰ªæçš„ä¸å½’è·¯ä¸Šè¶Šèµ°è¶Šè¿œã€‚ å¦‚æœé‡‡ç”¨æœç´¢çš„ç­–ç•¥ï¼Œæ¯æ¬¡éœ€è¦è®°å½•ä¸‹æ£‹ç›˜çš„å®Œæ•´çŠ¶æ€ï¼ŒçŠ¶æ€æ•°é‡å’Œè½¬ç§»æ•°é‡è¿‡äºåºå¤§ï¼Œä»¥è‡´äºæ— æ³•åœ¨è§„å®šæ—¶é—´å†…æ±‚è§£ã€‚ è§‚å¯Ÿåˆ°æ£‹ç›˜ä¸­çš„ééšœç¢ä½ç½®åªå¯èƒ½æœ‰ç©ºæ ¼ã€æ™®é€šæ£‹å­æˆ–ç›®æ ‡æ£‹å­ä¸‰ç§å¯èƒ½ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€ç¡®å®šç›®æ ‡æ£‹å­å’Œç©ºæ ¼çš„ä½ç½®ï¼Œå°±å¯ä»¥å°†æ•´å¼ æ£‹ç›˜çš„çŠ¶æ€ç¡®å®šä¸‹æ¥ã€‚ æ˜¾ç„¶ï¼Œå¦‚æœæƒ³è¦æŒªåŠ¨ç›®æ ‡æ£‹å­ï¼Œåˆ™ç›®æ ‡æ£‹å­çš„ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¹‹ä¸€å¿…é¡»ä¸ºç©ºæ ¼ã€‚å¯ä»¥å®šä¹‰çŠ¶æ€ä¸ºä¸‰å…ƒç»„ $(x,y,d)$ ï¼Œè¡¨ç¤ºç›®æ ‡æ£‹å­ä½äº $(x,y)$ ï¼Œå¹¶ä¸”å…¶ $d(0\le d\le 3)$ æ–¹å‘ä¸ºç©ºæ ¼ã€‚ å‡è®¾ä½äº $(x1,y1)$ çš„ç›®æ ‡æ£‹å­å‘ $d1$ æ–¹å‘ç§»åŠ¨ä¸€ä¸ªå•ä½ååˆ°è¾¾ $(x2,y2)$ ï¼Œä¸éš¾å‘ç°çŠ¶æ€ $(x1,y1,d1)$ å¯ä»¥è½¬ç§»åˆ°çŠ¶æ€ $(x2,y2,d2)$ã€‚è€Œæ­¤æ¬¡è½¬ç§»éœ€è¦çš„ä»£ä»·ï¼Œå³ä¸ºå°†ç©ºæ ¼ä»åŸå§‹ä½ç½®ç§»åŠ¨åˆ° $(x2,y2)$ çš„ $d2$ æ–¹å‘æ‰€éœ€çš„æœ€å°æ­¥æ•°ã€‚è¿™é‡Œå¯ä»¥ç”¨ bfs æ±‚è§£ã€‚ï¼ˆæ³¨æ„éšœç¢æ–¹å—å’Œ $(x2,y2)$ ä½ç½®æ˜¯ä¸å¯ä»¥ç»è¿‡çš„ï¼‰ å°†æ¯ä¸ªçŠ¶æ€ $(x,y,d)$ æŠ½è±¡ä¸ºèŠ‚ç‚¹ï¼Œå¯ä»¥è½¬ç§»çš„çŠ¶æ€ä¹‹é—´è¿ä¸€æ¡æœ‰å‘è¾¹ï¼Œè¾¹æƒå³ä¸ºè½¬ç§»çš„æœ€å°æ­¥æ•°ã€‚å¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œè®¡ç®—å‡ºæŠ½è±¡åçš„å›¾ä¸­æœ€çŸ­è·¯å¾„å³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼šï¼ˆç•¥ä¸‘ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x, y, d) ((x - 1) * M + y) + N * M * (d)const int INF = 0x3f3f3f3f;struct Edge &#123; int v, w; Edge(int v, int w): v(v), w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; G[35 * 35 * 5];int nx[] = &#123;0, -1, 0, 1&#125;;int ny[] = &#123;-1, 0, 1, 0&#125;;int N, M, Q;int h[35][35];int t[35][35];bool vis[35][35];void getdis(int x, int y, int px, int py) &#123; memset(t, 0x3f, sizeof(t)); memset(vis, 0, sizeof(vis)); if (h[x][y] == 0) return; queue&lt;pair&lt;int, int&gt; &gt; q; t[x][y] = 1, vis[x][y] = 1; q.push(make_pair(x, y)); while (q.size()) &#123; int ux = q.front().first, uy = q.front().second; q.pop(); for (int d = 0; d &lt;= 3; ++d) &#123; int tx = ux + nx[d], ty = uy + ny[d]; if (tx &lt; 1 || tx &gt; N || ty &lt; 1 || ty &gt; M) continue; if (tx == px &amp;&amp; ty == py) continue; if (h[tx][ty] == 0 || vis[tx][ty]) continue; t[tx][ty] = t[ux][uy] + 1; q.push(make_pair(tx, ty)); vis[tx][ty] = 1; &#125; &#125;&#125;inline void AddEdge(int u, int v, int w) &#123; G[u].push_back(Edge(v, w));&#125;bool v[35 * 35 * 5];int d[35 * 35 * 5];void Dijkstra(int S) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); d[S] = 0; priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(0, S)); while (q.size()) &#123; int u = q.top().second; q.pop(); if (v[u]) continue; v[u] = 1; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it-&gt;v, w = it-&gt;w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; q.push(make_pair(-d[v], v)); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;N, &amp;M, &amp;Q); for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= M; ++j) scanf("%d", &amp;h[i][j]); for (int x = 1; x &lt;= N; ++x) &#123; for (int y = 1; y &lt;= M; ++y) &#123; if (h[x][y] == 0) continue; for (int d = 0; d &lt;= 3; ++d) &#123; int tx = x + nx[d], ty = y + ny[d]; if (tx &lt; 1 || tx &gt; N || ty &lt; 1 || ty &gt; M) continue; if (h[tx][ty] == 0) continue; getdis(x, y, tx, ty); for (int d2 = 0; d2 &lt;= 3; ++d2) &#123; int tx2 = tx + nx[d2], ty2 = ty + ny[d2]; if (tx2 &lt; 1 || tx2 &gt; N || ty2 &lt; 1 || ty2 &gt; M) continue; if (t[tx2][ty2] &gt;= INF) continue; AddEdge(id(x, y, d), id(tx, ty, d2), t[tx2][ty2]); &#125; &#125; &#125; &#125; while (Q--) &#123; int ex, ey, sx, sy, tx, ty; scanf("%d%d%d%d%d%d", &amp;ex, &amp;ey, &amp;sx, &amp;sy, &amp;tx, &amp;ty); if (sx == tx &amp;&amp; sy == ty) &#123; puts("0"); continue; &#125; getdis(ex, ey, sx, sy); int ans = INF; for (int d1 = 0; d1 &lt;= 3; ++d1) &#123; int fx = sx + nx[d1], fy = sy + ny[d1]; if (fx &lt; 1 || fx &gt; N || fy &lt; 1 || fy &gt; M) continue; if (t[fx][fy] &gt;= INF) continue; int cur = INF; Dijkstra(id(sx, sy, d1)); for (int d2 = 0; d2 &lt;= 3; ++d2) cur = min(cur, d[id(tx, ty, d2)]); cur += t[fx][fy] - 1; ans = min(ans, cur); &#125; if (ans &gt;= INF) puts("-1"); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p5290æ˜¥èŠ‚åäºŒå“]]></title>
    <url>%2F2019%2F09%2F12%2Fsolution-luogu-p5290%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œå°†æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹åˆ†ä¸ºè‹¥å¹²ç»„ï¼Œå…¶ä¸­æ¯ä¸€ç»„ä¸­çš„ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¸èƒ½å­˜åœ¨ç¥–å…ˆ-åä»£å…³ç³»ï¼Œæ¯ä¸€ç»„çš„æƒå€¼ä¸ºè¯¥ç»„ä¸­æ‰€æœ‰èŠ‚ç‚¹æƒå€¼çš„æœ€å¤§å€¼ï¼Œæ±‚æ‰€æœ‰ç»„çš„æƒå€¼æ€»å’Œæœ€å°å€¼ã€‚ $1 \le n \le 200000$ æˆ‘æ„Ÿè°¢æˆ‘è‡ªå·± é¦–å…ˆè€ƒè™‘æ ‘é€€åŒ–ä¸ºé“¾çš„æƒ…å†µã€‚æ ‘æ ¹æœ€å¤šæœ‰ä¸¤æ£µå­æ ‘ï¼Œæ ‘æ ¹éœ€è¦è¢«å•ç‹¬åˆ†ä¸ºä¸€æ®µï¼Œå…¶ä½™æ®µä¸­ä¸èƒ½å‡ºç°åŒä¸€æ£µå­æ ‘å†…çš„ä¸¤ä¸ªç‚¹ã€‚ è¿™æ—¶æˆ‘ä»¬éœ€è¦å°†å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹ä¸å³å­æ ‘ä¸­çš„èŠ‚ç‚¹é…å¯¹ã€‚å¯ä»¥è¯æ˜ï¼Œå°†å·¦å­æ ‘ä¸­çš„æœ€å¤§å€¼ä¸å³å­æ ‘ä¸­çš„æœ€å¤§å€¼ã€å·¦å­æ ‘ä¸­çš„æ¬¡å¤§å€¼ä¸å³å­æ ‘ä¸­çš„æ¬¡å¤§å€¼ä»¥æ­¤ç±»æ¨ä¸¤ä¸¤é…å¯¹ï¼Œå¯ä»¥ä½¿æ‰€æœ‰æ®µçš„æƒå€¼æ€»å’Œæœ€å°ã€‚ å¦‚æ­¤ä¸€æ¥ï¼Œä¸¤æ¡é“¾å®åˆ™è¢«åˆå¹¶æˆä¸ºä¸€æ¡é“¾ã€‚åŒç†ï¼Œå¤šæ¡é“¾ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„æ–¹å¼åˆå¹¶ä¸ºä¸€æ¡é“¾ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„ä¸€æ¡ç­‰æ•ˆé“¾ï¼Œå¹¶ä¸”è¦æ±‚é«˜æ•ˆåœ°å°†ä¸¤æ¡é“¾åˆå¹¶ä¸ºä¸€æ¡æ–°é“¾ã€‚ ä¸éš¾çœ‹å‡ºï¼Œç”±äºæˆ‘ä»¬éœ€è¦å–æœ€å¤§å€¼çš„æ€§è´¨ï¼Œå¯ä»¥ä½¿ç”¨å †æ¥ç»´æŠ¤é“¾ä¿¡æ¯ã€‚å³ï¼Œåœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šå»ºç«‹ä¸€ä¸ªå †ï¼Œå †ä¸­å­˜å‚¨ä»å½“å‰èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„ç­‰æ•ˆé“¾ä¸Šæ‰€æœ‰æƒå€¼ä¿¡æ¯ã€‚ æ¥ä¸‹æ¥éœ€è¦è§£å†³çš„å³ä¸ºé“¾çš„åˆå¹¶å³å †çš„åˆå¹¶é—®é¢˜ã€‚å‡è®¾éœ€è¦åˆå¹¶å † $q1$ ï¼Œ$q2$ ã€‚ å¦‚æœ $q1.size()&gt;q2.size()$ï¼Œé‚£ä¹ˆåªéœ€å–å‡º $q1$ çš„å‰ $q2.size()$ é¡¹ï¼Œå¹¶å°†å®ƒä»¬ä¸ $q2$ ä¸­çš„æ‰€æœ‰å…ƒç´ å–æœ€å¤§å€¼å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ $O(q2.size()\log q2.size())$ ã€‚ å¦‚æœ $q1.size()&lt;q2.size()$ï¼Œé‚£ä¹ˆä¸ä»…éœ€è¦å–å‡º $q1$ çš„æ‰€æœ‰é¡¹ï¼Œå¹¶å°†å®ƒä»¬ä¸ $q2$ ä¸­çš„å‰ $q1.size()$ é¡¹å–æœ€å¤§å€¼ï¼Œè¿˜éœ€å°† $q2$ ä¸­å‰©ä½™çš„å…ƒç´ æ’å…¥ $q1$ ä¸­ã€‚æ—¶é—´å¤æ‚åº¦ $O(q2.size()\log q2.size())$ ã€‚ ä¸éš¾çœ‹å‡ºï¼Œå°†å¤§å †åˆå¹¶è¿›å…¥å°å †ï¼Œæ—¶é—´å¤æ‚åº¦åœ¨ $O(max(q1.size(),q2.size()))$ çº§åˆ«ã€‚ä½†å¦‚æœæ¢ä¸€ç§æ€è·¯ï¼Œå°†å°å †åˆå¹¶è¿›å…¥å¤§å †ï¼Œæ—¶é—´å¤æ‚åº¦å°±é™åˆ° $O(min(q1.size(),q2.size()))$ çº§åˆ«ã€‚æ­¤æ–¹æ³•ä¸å¹¶æŸ¥é›†çš„æŒ‰ç§©åˆå¹¶æœ‰å¼‚æ›²åŒå·¥ä¹‹å¦™ï¼Œè¢«æˆä¸ºå¯å‘å¼åˆå¹¶ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;vector&lt;int&gt; G[200005];int M[200005];priority_queue&lt;int&gt; q[200005];int tmp[200005], cnt;void dfs(int u) &#123; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; dfs(v); cnt = 0; if (q[u].size() &lt; q[v].size()) swap(q[u], q[v]); while(q[v].size()) &#123; tmp[++cnt] = max(q[u].top(), q[v].top()); q[u].pop(), q[v].pop(); &#125; for (int i = 1; i &lt;= cnt; ++i) q[u].push(tmp[i]); &#125; q[u].push(M[u]);&#125;int main() &#123; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;M[i]); for (register int i = 2; i &lt;= N; ++i) &#123; int f; scanf("%d", &amp;f); G[f].push_back(i); &#125; dfs(1); ll ans = 0; while (q[1].size()) ans += q[1].top(), q[1].pop(); printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å¯å‘å¼åˆå¹¶</tag>
        <tag>å †</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -ç‚¹åˆ†æ²»&åŠ¨æ€ç‚¹åˆ†æ²»]]></title>
    <url>%2F2019%2F09%2F11%2Falgorithm-treedivide%2F</url>
    <content type="text"><![CDATA[ç‚¹åˆ†æ²»æ¦‚è¿°ç‚¹åˆ†æ²»é€‚åˆå¤„ç†å¤§è§„æ¨¡çš„æ ‘ä¸Šè·¯å¾„ä¿¡æ¯é—®é¢˜ã€‚ ç‚¹åˆ†æ²»çš„å®ç°åŸºäºä»¥ä¸‹ç»“è®ºï¼šä¸€æ£µå­æ ‘ä¸Šçš„ä»»æ„ä¸€æ¡è·¯å¾„ï¼Œè¦ä¹ˆç»è¿‡æ ‘æ ¹ï¼Œè¦ä¹ˆè¢«å®Œå…¨åŒ…å«åœ¨æ ‘æ ¹çš„ä¸€æ£µå­æ ‘ä¸­ã€‚ å®šä¹‰ $solve()$ å‡½æ•°ï¼Œå¯¹æ¯æ£µå­æ ‘è¿›è¡Œåˆ†å€¼å¤„ç†ï¼Œå¹¶ä¿è¯ $O(n\log n)$ çš„æ—¶é—´å¤æ‚åº¦ã€‚ æ¨¡æ¿è¿™ä¹ˆç®€å•è¿˜è¦æ¨¡æ¿ï¼Ÿ åŠ¨æ€ç‚¹åˆ†æ²»ï¼ˆç‚¹åˆ†æ ‘ï¼‰æ¦‚è¿°åœ¨æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šå»ºç«‹æ•°æ®ç»“æ„ï¼Œå­˜å‚¨å…¶æ§åˆ¶èŒƒå›´å†…æ‰€æœ‰ç‚¹ä¸ä¹‹çš„è·ç¦»ä¿¡æ¯ã€‚åœ¨è¿›è¡Œä¿®æ”¹æˆ–æŸ¥è¯¢æ“ä½œæ—¶ï¼Œåªéœ€è®¿é—®å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆï¼ˆæœ€å¤š $O(\log n)$ ä¸ªï¼‰å³å¯ã€‚ æ¨¡æ¿ä»£ç è¿‡äºæ¯’ç˜¤ ä¸è´´äº†]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>ç‚¹åˆ†æ²»</tag>
        <tag>åŠ¨æ€ç‚¹åˆ†æ²»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1311é€‰æ‹©å®¢æ ˆ]]></title>
    <url>%2F2019%2F09%2F09%2Fsolution-luogu-p1311%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç°åœ¨æˆ‘éšæœº@ä¸€ä¸ªäºº è¿™ä¸ªäººå¿…é¡»å¸®æˆ‘å†™é¢˜ç›®æ¦‚æ‹¬ @gzn7264 è¿™ç¯‡é¢˜è§£å°±ä¸åœ¨æ´›è°·åšå®¢ä¸Šå‘å¸ƒäº†ã€‚ é¦–å…ˆæšä¸¾ç‚¹å¯¹çš„å³ç«¯ç‚¹ã€‚æ˜¾è€Œæ˜“è§ï¼Œåˆæ³•çš„å·¦ç«¯ç‚¹å¿…é¡»æ»¡è¶³ï¼š å·¦ç«¯ç‚¹ä¸å³ç«¯ç‚¹é¢œè‰²ç›¸åŒ å·¦ç«¯ç‚¹åˆ°å³ç«¯ç‚¹ä¹‹é—´å¿…é¡»å­˜åœ¨è‡³å°‘ä¸€ä¸ªå®¢æ ˆï¼Œä½¿å¾—å…¶è´¹ç”¨å°äºç­‰äº $P$ ç¬¬äºŒä¸ªæ¡ä»¶æœ‰ç‚¹éº»çƒ¦ï¼Œæˆ‘ä»¬å¯ä»¥ç¨å¾®è½¬åŒ–ä¸€ä¸‹ã€‚è®° $l_i$ ä¸ºå®¢æ ˆ $i$ çš„å·¦ä¾§ç¬¬ä¸€ä¸ªè´¹ç”¨å°äºç­‰äº $P$ çš„å®¢æ ˆç¼–å·ã€‚é‚£ä¹ˆï¼Œä»¥ $i$ ä¸ºå³ç«¯ç‚¹çš„æƒ…å†µä¸‹ï¼Œå·¦ç«¯ç‚¹çš„å¯é€‰ä½ç½®å³ä¸º $1-l_i$ ç§æ‰€æœ‰é¢œè‰²ä¸å®¢æ ˆ $i$ ç›¸åŒçš„å®¢æ ˆä¸ªæ•°ã€‚ ç”±äºæœ¬é¢˜å¡ç©ºé—´ï¼Œå¿…é¡»é‡‡ç”¨æ»šåŠ¨æ•°ç»„ã€‚æ•°ç»„ $s_i$ è®°å½•é¢œè‰² $i$ çš„å‡ºç°æ¬¡æ•°ï¼Œæ•°ç»„ $c_i$ è®°å½•é¢œè‰² $i$ çš„å¯é€‰å·¦ç«¯ç‚¹ä¸ªæ•°ã€‚æ¯æ¬¡æ›´æ–°ç­”æ¡ˆæ—¶ï¼ŒåŠ ä¸Š $c_{color}$ å³å¯ã€‚ åœ¨ç¤ºä¾‹ä»£ç ä¸­ï¼Œå¯é€‰çš„å·¦ç«¯ç‚¹åŒ…æ‹¬å…¶æœ¬èº«ï¼Œå› æ­¤å½“ $money\le P$ æ—¶å­˜åœ¨é‡å¤è®¡ç®—ï¼Œç­”æ¡ˆå‡ä¸€ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;long long ans;int N, K, P;int c[50], s[50];int main() &#123; scanf("%d%d%d", &amp;N, &amp;K, &amp;P); for (register int i = 1; i &lt;= N; ++i) &#123; int color, money; scanf("%d%d", &amp;color, &amp;money); s[color]++; if (money &lt;= P) for (register int j = 0; j &lt; K; ++j) c[j] = s[j]; ans += c[color] - (money &lt;= P); &#125; printf("%I64d", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å‰ç¼€å’Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2495æ¶ˆè€—æˆ˜]]></title>
    <url>%2F2019%2F08%2F30%2Fsolution-luogu-p2495%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç°åœ¨æˆ‘éšæœº@ä¸€ä¸ªäºº è¿™ä¸ªäººå¿…é¡»å¸®æˆ‘å†™é¢˜ç›®æ¦‚æ‹¬ @xj è¿™æ˜¯ä¸€ç¯‡è™šæ ‘å…¥é—¨é¢˜è§£ã€‚ è€ƒè™‘é¢˜ç›®ä¸­ $m=1$ çš„æƒ…å†µã€‚æ ‘ä¸ŠåŠ¨è§„ï¼Œå®šä¹‰çŠ¶æ€ $f[u]$ è¡¨ç¤ºåˆ‡æ–­èŠ‚ç‚¹ $u$ ä¸è¯¥å­æ ‘å†…æ‰€æœ‰å…³é”®ç‚¹çš„è·¯å¾„ï¼Œæœ€å°æ€»ä»£ä»·ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š f[u]= \begin{equation} \begin{cases} w(u,v) \ \texttt{if h[v]=1} \\ \min(w(u,v),f[v])\ \texttt{if h[v]=0} \end{cases} \end{equation}åŠ¨æ€è§„åˆ’éƒ¨åˆ†ä¸å†èµ˜è¿°ã€‚è¯¥ç®—æ³•å¤æ‚åº¦ä¸º $O(n)$ ã€‚ è€ƒè™‘é¢˜ç›®ä¸­ $m\not= 1$ çš„æƒ…å†µã€‚å¦‚æœå¯¹äºæ¯ä¸€æ¬¡æŸ¥è¯¢ï¼Œéƒ½è¿›è¡Œä¸€æ¬¡ $O(n)$ å¤æ‚åº¦çš„éå†æ˜¾ç„¶æ— æ³•æ¥å—ã€‚è§‚å¯Ÿåˆ°é¢˜ç›®ä¸­ $\Sigma{k}$ çš„å–å€¼ä¸å¤§ï¼Œå¯ä»¥è€ƒè™‘é’ˆå¯¹æ²¡ä¸ªè¯¢é—®ï¼Œèˆå¼ƒæ ‘ä¸Šçš„ä¸€äº›éå…³é”®ç‚¹ï¼Œä»…ä¿ç•™ä¸€æ£µåŒ…å«åŸæ ‘ä¸Šéƒ¨åˆ†èŠ‚ç‚¹çš„è™šæ ‘ï¼Œå¹¶åœ¨è™šæ ‘ä¸Šè¿›è¡ŒåŠ¨æ€è§„åˆ’ã€‚ é‚£ä¹ˆï¼Œåœ¨è™šæ ‘ä¸Šåº”è¯¥ä¿ç•™åŸæ ‘ä¸Šçš„å“ªäº›ç‚¹å‘¢ï¼Ÿ é¦–å…ˆï¼Œæ¯æ¬¡è®¯é—®ä¸­ç»™å‡ºçš„ $k$ ä¸ªå…³é”®ç‚¹ï¼ˆèµ„æºä¸°å¯Œçš„å²›å±¿ï¼‰æ˜¾ç„¶åº”è¯¥åŒ…å«åœ¨è™šæ ‘ä¸­ã€‚å…¶æ¬¡ï¼Œä»»æ„ä¸¤ä¸ªå…³é”®ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¹Ÿåº”è¯¥åŒ…å«åœ¨è™šæ ‘ä¸­ï¼›å› ä¸ºåœ¨æœ¬é¢˜ä¸­ï¼Œåˆ‡æ–­ä¸€æ¡è¾¹å¯ä»¥åŒæ—¶åˆ‡æ–­æ ¹èŠ‚ç‚¹ä¸å¤šä¸ªå…³é”®ç‚¹é—´çš„è·¯å¾„ï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆçš„å­˜åœ¨ä¸ºåŠ¨æ€è§„åˆ’æä¾›äº†è¿™ç§çŠ¶æ€è½¬ç§»ã€‚æœ€åä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å¯ä»¥å°† $1$ å·èŠ‚ç‚¹ï¼ˆå³æ ¹èŠ‚ç‚¹ï¼‰ä¹ŸåŠ å…¥åˆ°è™šæ ‘ä¸­ã€‚ æ„é€ è™šæ ‘çš„æ–¹æ³•å¾ˆå¤šï¼Œåœ¨è¿™é‡Œä»‹ç»ä¸€ç§ç”¨æ ˆå»ºæ ‘çš„ç®—æ³•æµç¨‹ã€‚ ä»¤ $1$ å·èŠ‚ç‚¹ä¸ºè™šæ ‘çš„æ ¹ã€‚ å°†æ‰€æœ‰å…³é”®ç‚¹æŒ‰ç…§å…¶åœ¨åŸæ ‘ä¸­çš„ dfs åºå‡åºæ’åºã€‚å‡è®¾å½“å‰æ­£åœ¨å¤„ç†çš„å…³é”®ç‚¹ä¸º $u$ ã€‚ ç»´æŠ¤ä¸€ä¸ªæ ˆï¼Œä½¿å¾—æ ˆåº•åˆ°æ ˆé¡¶çš„å…ƒç´ ä¾æ¬¡ä¸ºè™šæ ‘ä¸Šä»æ ¹èŠ‚ç‚¹åˆ°èŠ‚ç‚¹ $u$ çš„ä¸€æ¡é“¾ã€‚ è¿™é‡Œä¸ºä»€ä¹ˆè¦ç»´æŠ¤ä¸€ä¸ªæ ˆå‘¢ï¼Ÿ å¦‚å›¾ï¼šåœ¨å¤„ç†å®Œ $3$ å·å…³é”®ç‚¹åï¼Œè™šæ ‘ä¸­åªæœ‰ $1$ ã€ $3$ ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œæ ˆä¸­çš„å…ƒç´ ä¾æ¬¡ä¸º $1$ ã€ $3$ ã€‚ä½†æ˜¯è¿™æ¡é“¾æ˜¯ä¸å®Œæ•´çš„ï¼Œå¯ä»¥è§‚å¯Ÿåˆ°åœ¨å¤„ç† $4$ å·å…³é”®ç‚¹æ—¶ï¼Œè¿˜éœ€è¦å°† $2$ å·èŠ‚ç‚¹æ·»åŠ åˆ°è™šæ ‘ä¸­ã€‚åˆ©ç”¨æ ˆçš„æ€§è´¨ï¼Œæˆ‘ä»¬å¯ä»¥åŠ¨æ€ç»´æŠ¤ä¸€æ¡è™šæ ‘ä¸Šçš„é“¾ï¼Œå¹¶åœ¨å¿…è¦çš„æ—¶å€™æ·»åŠ èŠ‚ç‚¹ã€‚ å›åˆ°åˆšæ‰çš„å™è¿°ï¼Œå½“å‰æ­£åœ¨å¤„ç†å…³é”®ç‚¹ $u$ ã€‚æ ¹æ®æ ˆçš„å®šä¹‰ï¼Œä¸Šä¸€ä¸ªå¤„ç†çš„å…³é”®ç‚¹ä¸€å®šä¸º $stack.top()$ ã€‚ ç”±äºè¿›è¡Œè¿‡æ’åºï¼Œå³èŠ‚ç‚¹ $u$ çš„ dfs åºå¤§äºä¸Šä¸€ä¸ªå…³é”®ç‚¹çš„ dfs åºï¼Œå› æ­¤èŠ‚ç‚¹ $u$ è¦ä¹ˆæ˜¯ä¸Šä¸€ä¸ªå…³é”®ç‚¹çš„åä»£ï¼Œè¦ä¹ˆä¸å…¶æ²¡æœ‰ç¥–å…ˆ-åä»£çš„å…³ç³»ã€‚ æ˜¾ç„¶ï¼Œå¦‚æœèŠ‚ç‚¹ $u$ æ˜¯ $stack.top()$ çš„åä»£ï¼Œé‚£ä¹ˆåªéœ€å°†èŠ‚ç‚¹ $u$ å…¥æ ˆå³å¯ï¼Œå› ä¸º $u$ åœ¨è™šæ ‘ä¸­ï¼Œä¸€å®šæ˜¯ä¸Šä¸€ä¸ªå…³é”®ç‚¹çš„å„¿å­ã€‚ ä½†æ˜¯å¦‚æœèŠ‚ç‚¹ $u$ ä¸ $stack.top()$ æ²¡æœ‰ç¥–å…ˆ-åä»£çš„å…³ç³»ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„è®¨è®ºå°†æ¯”è¾ƒå¤æ‚ã€‚ å¯ä»¥ç»“åˆä¸Šå›¾è§‚å¯Ÿï¼Œå‡è®¾å½“å‰æ­£åœ¨å¤„ç† $4$ å·å…³é”®ç‚¹ã€‚æˆ‘ä»¬å¯ä»¥é¦–å…ˆå°†æ ˆé¡¶å¼¹å‡ºï¼Œå› ä¸º $stack.top()$ ä¸€å®šä¸åœ¨æ ¹èŠ‚ç‚¹åˆ°èŠ‚ç‚¹ $u$ çš„é“¾ä¸Šã€‚æ­¤æ—¶ï¼Œæ ˆä¸­å‰©ä½™çš„å…ƒç´ åªæœ‰ $1$ ã€‚ç„¶è€Œï¼Œ $3$ ä¸ $4$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ $2$ å·èŠ‚ç‚¹è¿˜ä¸åœ¨æ ˆä¸­ï¼›å› æ­¤æˆ‘ä»¬éœ€è¦æŠŠ $2$ å·èŠ‚ç‚¹å…¥æ ˆï¼Œå¹¶å°†åˆšåˆšå¼¹å‡ºçš„èŠ‚ç‚¹ä¸æ–°çš„æ ˆé¡¶åœ¨è™šæ ‘ä¸­è¿è¾¹ã€‚å¤„ç†ç»“æŸåï¼Œå°† $4$ å…¥æ ˆã€‚ æ¥ä¸‹æ¥å¤„ç† $5$ å·å…³é”®ç‚¹ï¼Œæ­¤æ—¶æ ˆä¸­çš„å…ƒç´ ä¾æ¬¡ä¸º $1$ ã€$2$ ã€$4$ ã€‚é¦–å…ˆå°†æ ˆé¡¶å¼¹å‡ºï¼Œä½†ç”±äºæˆ‘ä»¬æ¥ä¸‹æ¥éœ€è¦ç»´æŠ¤çš„é“¾ä¸º $1-&gt;5$ ï¼Œæ ˆä¸­ä»ç„¶æœ‰èŠ‚ç‚¹ $2$ ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°† $2$ å’Œåˆšåˆšå¼¹å‡ºçš„èŠ‚ç‚¹ $4$ è¿è¾¹ï¼Œå¹¶ä¸”é‡å¤ä»¥ä¸Šæ“ä½œã€‚å°†æ–°çš„æ ˆé¡¶ $2$ å¼¹å‡ºåï¼Œæ ˆä¸­åªå‰©ä¸‹èŠ‚ç‚¹ $1$ ã€‚è¿™æ—¶å‘ç° $1$ å·èŠ‚ç‚¹æ°å¥½ä¸º $5$ ä¸ä¸Šä¸€æ¬¡å¤„ç†çš„å…³é”®ç‚¹ $4$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå› æ­¤å°† $1$ ä¸ $2$ è¿è¾¹åï¼Œå¼¹æ ˆå¯ä»¥ä¸­æ­¢äº†ã€‚å¤„ç†ç»“æŸåï¼Œå°† $5$ å…¥æ ˆã€‚ æ­¤æ—¶æˆ‘ä»¬å·²ç»å¤„ç†å®Œäº†æ‰€æœ‰å…³é”®ç‚¹ï¼Œä½†æ˜¯æ ˆä¸­çš„å…ƒç´ é—´è¿˜æ²¡æœ‰è¿è¾¹ã€‚å°†æ ˆä¸­çš„èŠ‚ç‚¹ä¾æ¬¡è¿è¾¹åï¼Œè™šæ ‘çš„æ„å»ºå°±å®Œæˆäº†ã€‚ ä¼ªä»£ç å¦‚ä¸‹ï¼š 123456789101112131415å°†å…³é”®ç‚¹æŒ‰ç…§ dfs åºæ’åºstack.push(1)for u = 1 ~ k: // å‡è®¾å½“å‰æ­£åœ¨å¤„ç†èŠ‚ç‚¹ u lca = Lca(u, stack.top()) while stack.top() != lca: tmp = stack.top() stack.pop() if dfn[stack.top()] &lt; dfn[lca] stack.push(lca) AddEdge(stack.top(), tmp) stack.push(u)while stack.top() != 1: tmp = stack.top() stack.pop() AddEdge(stack.top(), tmp) å¯ä»¥è¯æ˜ï¼Œå¯¹äºæœ¬é¢˜ï¼Œè™šæ ‘ä¸Šçš„è¾¹æƒä¸€å®šå¯¹åº”åŸæ ‘ä¸Šä¸¤èŠ‚ç‚¹ä¹‹é—´è¾¹æƒçš„æœ€å°å€¼ã€‚è¯æ˜ä¸å†èµ˜è¿°ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge &#123;int v;ll w;Edge(int a, ll b) &#123;v = a, w = b;&#125;&#125;;struct Key &#123;int u, dfn;&#125;keys[250005];int keys_cnt;inline bool cmp(Key a, Key b) &#123; return a.dfn &lt; b.dfn;&#125;int N, M;vector&lt;Edge&gt; G[250005], VT[250005];int f[250005][19], g[250005][19], dep[250005];ll d[250005];bool h[250005];int dfn[250005], dfn_idx;int lg[250005];void dfs(int u, int fa, ll w) &#123; dep[u] = dep[fa] + 1; dfn[u] = ++dfn_idx; f[u][0] = fa, g[u][0] = w; for (int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i - 1]][i - 1], g[u][i] = min(g[f[u][i - 1]][i - 1], g[u][i - 1]); for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v; ll w = it -&gt; w; if (v == fa) continue; dfs(v, u, w); &#125;&#125;void dp(int u) &#123; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v; ll w = it -&gt; w; dp(v); if (h[v]) d[u] += w; else d[u] += min(w, d[v]); h[v] = 0; d[v] = 0; &#125; VT[u].clear();&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] &gt; dep[v]) &#123; u = f[u][lg[dep[u] - dep[v]]]; &#125; if (u == v) return u; for (int i = lg[dep[u]]; i &gt;= 0; --i) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];&#125;inline int query(int u, int v) &#123; int ans = 0x3f3f3f3f; while (dep[u] &gt; dep[v]) &#123; ans = min(ans, g[u][lg[dep[u] - dep[v]]]); u = f[u][lg[dep[u] - dep[v]]]; &#125; return ans;&#125;inline void AddEdge(int u, int v) &#123; int w = query(v, u); VT[u].push_back(Edge(v, w));&#125;int main() &#123; for (register int i = 2; i &lt;= 250000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; memset(g, 0x3f, sizeof(g)); scanf("%d", &amp;N); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; ll w; scanf("%d%d%lld", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); G[v].push_back(Edge(u, w)); &#125; dfs(1, 0, 0); scanf("%d", &amp;M); while (M--) &#123; int k; keys_cnt = 0; scanf("%d", &amp;k); for (register int i = 1; i &lt;= k; ++i) &#123; scanf("%d", &amp;keys[++keys_cnt].u); h[keys[keys_cnt].u] = 1; keys[keys_cnt].dfn = dfn[keys[keys_cnt].u]; &#125; stack&lt;int&gt; s; sort(keys + 1, keys + keys_cnt + 1); s.push(1); for (register int i = 1; i &lt;= keys_cnt; ++i) &#123; int u = keys[i].u; int lca = Lca(u, s.top()); while (s.top() != lca) &#123; int tmp = s.top(); s.pop(); if (dfn[s.top()] &lt; dfn[lca]) s.push(lca); AddEdge(s.top(), tmp); &#125; s.push(u); &#125; while (s.top() != 1) &#123; int tmp = s.top(); s.pop(); AddEdge(s.top(), tmp); &#125; dp(1); printf("%lld\n", d[1]); d[1] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ ‘å½¢dp</tag>
        <tag>è™šæ ‘</tag>
        <tag>æ ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p4103å¤§å·¥ç¨‹]]></title>
    <url>%2F2019%2F08%2F30%2Fsolution-luogu-p4103%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œè¾¹æƒä¸º $1$ ã€‚å…±æœ‰ $q$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡ç»™å‡º $k$ ä¸ªèŠ‚ç‚¹ï¼Œæ±‚ï¼š $k$ ä¸ªèŠ‚ç‚¹é—´ä¸¤ä¸¤è·ç¦»ä¹‹æ€»å’Œï¼›æœ€çŸ­è·ç¦»ï¼›æœ€é•¿è·ç¦»ã€‚ $1\le n \le 1000000,1 \le q \le 1000000, \Sigma{k}\le 2 * n$ æ„Ÿè°¢@tth37 çš„è´¡çŒ® æœ¬é¢˜ç”¨åˆ°äº†ä¸€äº›ç‚¹åˆ†æ²»çš„æ€æƒ³ã€‚ è€ƒè™‘ $q=1$ çš„æƒ…å†µã€‚ä¸€ç§æœ´ç´ çš„åšæ³•æ˜¯ï¼šæšä¸¾å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œå¹¶è®¡ç®—å­æ ‘é—´å…³é”®ç‚¹å½¢æˆçš„è·¯å¾„ã€æ›´æ–°ç­”æ¡ˆã€‚ä½†æ˜¯æœ¬é¢˜ä¸ä¸€èˆ¬ç‚¹åˆ†æ²»é¢˜ç›®ç•¥æœ‰ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é¢„å¤„ç†å­æ ‘ä¿¡æ¯æ¥ä¼˜åŒ–ç‚¹åˆ†æ²»è¿‡ç¨‹ã€‚ ç¨åŠ è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œåªéœ€é¢„å¤„ç†æ¯ä¸ªå­æ ‘ä¸­æ ‘æ ¹åˆ°å…³é”®ç‚¹çš„æœ€å°è·ç¦»ã€æœ€å¤§è·ç¦»ï¼Œä»¥åŠå­æ ‘ä¸­å…³é”®ç‚¹çš„ä¸ªæ•°ã€æ‰€æœ‰å…³é”®ç‚¹åˆ°æ ‘æ ¹çš„è·ç¦»æ€»å’Œå³å¯å®Œæˆç‚¹åˆ†æ²»å…¨éƒ¨è¿‡ç¨‹ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$ ã€‚ å¯¹äº $q\not=1$ çš„æƒ…å†µï¼Œè§‚å¯Ÿåˆ° $\Sigma{k}$ ä¸ $n$ åŒé˜¶ï¼Œå¯ä»¥å¯¹æ¯æ¬¡æŸ¥è¯¢å»ºç«‹ä¸€æ£µè™šæ ‘ï¼Œåœ¨è™šæ ‘ä¸Šç‚¹åˆ†æ²»å³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000005;typedef long long ll;struct Edge &#123;int v, w; Edge(int a, int b) &#123;v = a, w = b;&#125;&#125;;struct Key &#123;int u, dfn;&#125;keys[MAXN];bool cmp(Key a, Key b) &#123;return a.dfn &lt; b.dfn;&#125;vector&lt;Edge&gt; G[MAXN], VT[MAXN];int N, Q, K;int f[MAXN][21], dep[MAXN], dfn[MAXN], dfn_idx;int lg[MAXN];bool h[MAXN];ll g[MAXN];int m[MAXN], n[MAXN];int c[MAXN];ll ans1;int ans2, ans3;inline void dfs0(int u, int fa) &#123; dfn[u] = ++dfn_idx; dep[u] = dep[fa] + 1; f[u][0] = fa; for (int i = 1; i &lt;= lg[dep[u]]; ++i) f[u][i] = f[f[u][i - 1]][i - 1]; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v; if (v == fa) continue; dfs0(v, u); &#125;&#125;void dfs1(int u) &#123; g[u] = 0; c[u] = h[u]; m[u] = 0x3f3f3f3f; n[u] = -0x3f3f3f3f; if (h[u]) m[u] = n[u] = 0; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; dfs1(v); c[u] += c[v]; g[u] += g[v] + 1ll * w * c[v]; m[u] = min(m[u], w + m[v]); n[u] = max(n[u], w + n[v]); &#125;&#125;void dfs2(int u) &#123; ll sum = 0; int cnt = h[u]; int minn = 0x3f3f3f3f, maxx = -0x3f3f3f3f; if (h[u]) minn = maxx = 0; for (vector&lt;Edge&gt;::iterator it = VT[u].begin(); it != VT[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; ans1 += 1ll * sum * c[v] + 1ll * w * cnt * c[v] + 1ll * g[v] * cnt; ans2 = min(ans2, minn + w + m[v]); ans3 = max(ans3, maxx + w + n[v]); sum += g[v] + 1ll * c[v] * w; cnt += c[v]; minn = min(minn, w + m[v]); maxx = max(maxx, w + n[v]); dfs2(v); &#125; h[u] = 0; VT[u].clear();&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] &gt; dep[v]) u = f[u][lg[dep[u] - dep[v]]]; if (u == v) return u; for (int i = lg[dep[u]]; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main() &#123; for (register int i = 2; i &lt;= 1000000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; scanf("%d", &amp;N); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(Edge(v, 1)); G[v].push_back(Edge(u, 1)); &#125; dfs0(1, 0); scanf("%d", &amp;Q); while (Q--) &#123; scanf("%d", &amp;K); for (register int i = 1; i &lt;= K; ++i) &#123; int u; scanf("%d", &amp;u); h[u] = 1; keys[i].u = u, keys[i].dfn = dfn[u]; &#125; sort(keys + 1, keys + K + 1, cmp); stack&lt;int&gt; s; s.push(1); for (register int i = 1; i &lt;= K; ++i) &#123; int u = keys[i].u; if (u == 1) continue; int lca = Lca(u, s.top()); while (s.top() != lca) &#123; int tmp = s.top(); s.pop(); if (dfn[s.top()] &lt; lca) s.push(lca); VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()])); &#125; s.push(u); &#125; while (s.top() != 1) &#123; int tmp = s.top(); s.pop(); VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()])); &#125; dfs1(1); ans1 = ans3 = 0; ans2 = 0x3f3f3f3f; dfs2(1); printf("%lld %d %d\n", ans1, ans2, ans3); &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ ‘å½¢dp</tag>
        <tag>ç‚¹åˆ†æ²»</tag>
        <tag>è™šæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -è™šæ ‘]]></title>
    <url>%2F2019%2F08%2F29%2Falgorithm-virtualtree%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°åœ¨å¤„ç†æŸäº›æ ‘ä¸Šé—®é¢˜æ—¶ï¼Œå¹¶éæ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½èµ·ä½œç”¨ï¼›è¿™æ—¶å¯ä»¥å€ŸåŠ©è™šæ ‘ï¼Œå°†æ ‘ä¸Šé‡è¦çš„ç‚¹æ„é€ æˆä¸€æ£µæ ‘ï¼Œåœ¨è™šæ ‘ä¸Šå¤„ç†é—®é¢˜ï¼Œä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ã€‚ æ¨¡æ¿ç”¨æ ˆæ¥ç»´æŠ¤è™šæ ‘ä¸Šçš„ä¸€æ¡ä»æ ¹åˆ° $u$ çš„é“¾ã€‚å¦‚æœ $u$ æ˜¯æ ˆé¡¶èŠ‚ç‚¹çš„å„¿å­ï¼Œåˆ™å…¥æ ˆï¼›å¦åˆ™å°†æ ˆä¸­ dfn å€¼å¤§äº $lca(u,s.top())$ çš„å…ƒç´ å‡ºæ ˆã€‚ ä¼ªä»£ç 1234567891011å°†æ ‘ä¸Šæ‰€æœ‰å…³é”®ç‚¹æŒ‰ç…§ dfs åºæ’åºstack.push(1)for u = 1 ~ n: //å‡è®¾å½“å‰æ­£åœ¨å¤„ç†èŠ‚ç‚¹ u lca = Lca(u, stack.top()) while stack.top != lca: tmp = stack.top() stack.pop() if (dfn[stack.top()] &lt; dfn[lca]): stack.push(lca) AddEdge(stack.top(), tmp) stack.push(u)]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>è™šæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoodbyeOy!]]></title>
    <url>%2F2019%2F08%2F27%2FGoodbyeOy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1314èªæ˜çš„è´¨ç›‘å‘˜]]></title>
    <url>%2F2019%2F08%2F27%2Fsolution-luogu-p1314%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ å’•å’•å’• æœ¬é¢˜éš¾åº¦ä¸å¤§ï¼Œç¬¬ä¸€çœ¼å°±èƒ½çœ‹å‡ºéœ€è¦ç”¨äºŒåˆ†ç­”æ¡ˆæˆ–å€å¢ç­”æ¡ˆè§£å†³ã€‚ éœ€è¦è§£å†³çš„ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¦‚ä½•æ ¹æ®ä¸€ä¸ªçŒœæµ‹çš„å‚æ•° $W$ ï¼Œå¿«é€Ÿè®¡ç®—å‡ºæ£€éªŒç»“æœ $Y$ ã€‚ç”±äºåªæœ‰ $w_j \ge W$ çš„çŸ¿çŸ³æ‰ä¼šå¯¹æ£€éªŒç»“æœåšå‡ºè´¡çŒ®ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°† $w_j &lt; W$ çš„çŸ¿çŸ³å¿½ç•¥å¹¶é¢„å¤„ç†å‰ç¼€å’Œï¼Œå¹¶ä¸”å›ç­” $M$ ä¸ªè¯¢é—®å³å¯ã€‚ æ¥ä¸‹æ¥åº”è¯¥è€ƒè™‘å¦‚ä½•è®¡ç®—çŒœæµ‹å€¼ $W$ ã€‚è§‚å¯Ÿåˆ° $Y(W)$ æ˜¯å•è°ƒä¸å¢çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å€å¢æ±‚å‡ºæ»¡è¶³ $Y \ge S$ çš„æœ€å¤§ $W$ å€¼ï¼Œé‚£ä¹ˆæ»¡è¶³ $Y&lt;S$ çš„æœ€å° $W$ å€¼ä¸€å®šä¸º $W+1$ ã€‚ æœ€ç»ˆç­”æ¡ˆå³ä¸º $\min\lbrace |Y(W)-S|,|Y(W+1)-S|\rbrace$ ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, M, ans = 1; ll S;int w[200005], v[200005], l[200005], r[200005]; ll s1[200005], s2[200005];inline ll Y(int W) &#123; for (register int i = 1; i &lt;= N; ++i) s1[i] = w[i] &gt;= W ? s1[i - 1] + 1 : s1[i - 1], s2[i] = w[i] &gt;= W ? s2[i - 1] + v[i] : s2[i - 1]; ll ret = 0; for (register int i = 1; i &lt;= M; ++i) ret += (s1[r[i]] - s1[l[i] - 1]) * (s2[r[i]] - s2[l[i] - 1]); return ret;&#125;int main() &#123; scanf("%d%d%lld", &amp;N, &amp;M, &amp;S); for (register int i = 1; i &lt;= N; ++i) scanf("%d%d", &amp;w[i], &amp;v[i]); for (register int i = 1; i &lt;= M; ++i) scanf("%d%d", &amp;l[i], &amp;r[i]); for (register int i = 17; i &gt;= 0; --i) ans += Y(ans + (1 &lt;&lt; i)) &gt;= S ? (1 &lt;&lt; i) : 0; printf("%lld", min(Y(ans) - S, S - Y(ans + 1)));&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å‰ç¼€å’Œ</tag>
        <tag>äºŒåˆ†ç­”æ¡ˆ</tag>
        <tag>å€å¢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p5503ç¯å¡”]]></title>
    <url>%2F2019%2F08%2F26%2Fsolution-luogu-p5503%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ å’•å’•å’• ç”±äºæ ¹å·çš„å­˜åœ¨ï¼Œæœ¬é¢˜å¹¶æ²¡æœ‰ä»€ä¹ˆæ˜æ˜¾çš„å•è°ƒæ€§ï¼Œä¸èƒ½é€šè¿‡äºŒåˆ†æˆ–å•è°ƒé˜Ÿåˆ—å®ç°ã€‚ æœ¬é¢˜çš„å…³é”®åœ¨äºé—®é¢˜è½¬åŒ–ã€‚è®° $l_i$ è¡¨ç¤ºåœ¨å±±å³° $i$ ä¸Šå»ºç¯å¡”ï¼Œå¹¶ä½¿å¾—å±±å³° $1â€¦i$ å…¨éƒ¨è¢«ç…§äº®çš„æœ€å°é«˜åº¦ã€‚ h_j\le h_i+l_i - \sqrt{i-j} (1\le j\le i) h_j+\sqrt{i-j}-h_i\le l_i(1\le j\le i) l_i=\max_{1\le j\le i}\lbrace h_j+\lceil (\sqrt{i-j}) \rceil \rbrace-h_iè¿™æ · ${l}$ æ•°ç»„çš„æ±‚è§£å³è½¬åŒ–ä¸ºåŒºé—´æ±‚è§£æœ€å€¼é—®é¢˜ï¼Œç„¶è€Œ $\max$ å‡½æ•°ä¸­çš„ $\lceil (\sqrt{i-j}) \rceil$ ä¼¼ä¹æœ‰äº›æ£˜æ‰‹ã€‚ç„¶è€Œè§‚å¯Ÿåˆ°å½“ $\lceil (\sqrt{i-j}) \rceil$ ç›¸ç­‰æ—¶ï¼Œåªæœ‰è¯¥åŒºé—´å†…æœ€å¤§çš„ $h_j$ æ‰ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥æšä¸¾ $\lceil (\sqrt{i-j}) \rceil$ çš„å€¼ï¼Œæ±‚å‡ºå¯¹åº”çš„ $j$ åŒºé—´å†… $h_j$ çš„æœ€å€¼ä½œä¸º $l_i$ çš„å€™é€‰ç­”æ¡ˆã€‚ $r_i$ çš„å®šä¹‰ä¸ $l_i$ ç±»ä¼¼ï¼Œæœ€ç»ˆçš„ $p_i$ å³ä¸º $\max \lbrace l_i,r_i\rbrace$ ã€‚ æ±‚è§£åŒºé—´æœ€å€¼å¯ä»¥ç”¨ ST è¡¨å®ç°ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int st[100005][18];int lg[100005];int power[320];int p[100005];int N;inline int query(int l, int r) &#123; int s = lg[r - l + 1]; return max(st[l][s], st[r - (1 &lt;&lt; s) + 1][s]);&#125;int main() &#123; lg[1] = 0; for (register int i = 2; i &lt;= 100000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; for (register int i = 1; i &lt;= 319; ++i) &#123; power[i] = i * i; &#125; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;st[i][0]); for (register int j = 1; j &lt;= lg[N]; ++j) for (register int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= N; ++i) st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for (register int i = 1; i &lt;= N; ++i) &#123; int delta = 0, l = i, r = i; while (l &gt;= 1) &#123; p[i] = max(p[i], query(l, r) + delta - st[i][0]); r = l - 1, l = i - power[++delta]; &#125; if (r &gt;= 1) p[i] = max(p[i], query(1, r) + delta - st[i][0]); &#125; for (register int i = N; i &gt;= 1; --i) &#123; int delta = 0, l = i, r = i; while (r &lt;= N) &#123; p[i] = max(p[i], query(l, r) + delta - st[i][0]); l = r + 1, r = i + power[++delta]; &#125; if (l &lt;= N) p[i] = max(p[i], query(l, N) + delta - st[i][0]); &#125; for (register int i = 1; i &lt;= N; ++i) printf("%d\n", p[i]); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>STç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¨¡æ¿-å¸¸æ•°ä¼˜åŒ–]]></title>
    <url>%2F2019%2F08%2F26%2Ftemplate-optimization%2F</url>
    <content type="text"><![CDATA[å®ç”¨æŠ€å·§ å‡å°‘å‡½æ•°å‚æ•°ä¼ é€’ï¼Œå¼€å…¨å±€å˜é‡ è¡€çš„æ•™è®­ memset å®åœ¨æ˜¯å¤ªæ…¢äº†ï¼é¿å…å¤§æ•°ç»„çš„å¤šæ¬¡ memsetï¼Œå¯ä»¥åœ¨ç¨‹åºçš„å…¶ä»–ä½ç½®ï¼ˆå¦‚éå†ï¼‰é¡ºæ‰‹å°†æ•°ç»„æ¸…ç©º è¡€çš„æ•™è®­ å¿«é€Ÿè¯»å…¥123456789void readint() &#123;&#125;template&lt;class T1, class ...T2&gt;void readint(T1 &amp;i, T2&amp;... rest)&#123; i=0;char c;bool f=false; while (!isdigit(c=getchar())) f=c=='-'; do i=(i&lt;&lt;3)+(i&lt;&lt;1)+c-'0'; while (isdigit(c=getchar())); if (f) i=-i; readint(rest...);&#125; å¿«é€Ÿè¾“å‡º1æš‚æ— ]]></content>
      <categories>
        <category>æ¨¡æ¿</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[å…¬å‘Š 2019-8-26]]></title>
    <url>%2F2019%2F08%2F26%2Fbulletin-2019-8-26%2F</url>
    <content type="text"><![CDATA[ä¸Šä¸€ç¯‡å…¬å‘Š Hi~ è®¿é—®æˆ‘ç½‘ç«™çš„å°å´½å­ä»¬~ æƒ³åœ¨è¯„è®ºåŒºå‘è¨€çš„åŒæ—¶ç•™ä¸‹è‡ªå·±çš„ä¸ªäººå¤´åƒå—ï¼Ÿå¿«å¿«æ³¨å†Œä¸€ä¸ªGithubè´¦å·å§ï¼å­¦ä¿¡æ¯æ²¡ä¸ªGithubè´¦å·æ€ä¹ˆè¡Œ æˆ‘çš„ç½‘ç«™ä¸Githubå®Œå…¨å…¼å®¹ï¼Œå¯ä»¥ä½¿ç”¨Githubç™»å½•æˆ‘çš„ç½‘ç«™ï¼Œå¹¶ä¸”åœ¨æ–‡ç« ä¸‹æ–¹è¯„è®ºï¼ å¯ä»¥åœ¨è¿™é‡Œæµ‹è¯•ä¸€ä¸‹ è™½ç„¶ç½‘ç«™æ˜¯å›½å®¶é¡¶çº§åŸŸåï¼ˆ*.cnï¼‰ï¼Œä½†æ˜¯Githubå¤´åƒçš„æ›´æ–°æ˜¯å®æ—¶çš„ï¼Œæ³¨å†ŒGithubè´¦å·ä¹‹åç«‹åˆ»å¯ä»¥åˆ°æˆ‘çš„åšå®¢è¯„è®ºï¼ è°¢è°¢èµ„ç“·ï¼]]></content>
      <categories>
        <category>å…¬å‘Š</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p5502æœ€å¤§å…¬çº¦æ•°]]></title>
    <url>%2F2019%2F08%2F23%2Fsolution-luogu-p5502%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ å’•å’•å’• å¯¹äºæ±‚è§£åŒºé—´æƒå€¼ $=value *length$ çš„æœ€å€¼é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸å¯ä»¥æšä¸¾åŒºé—´å·¦ç«¯ç‚¹ï¼Œç„¶åé«˜æ•ˆåœ°æ‰¾å‡ºå³ç«¯ç‚¹æ›´æ–°ç­”æ¡ˆã€‚ æœ´ç´ çš„æƒ³æ³•æ˜¯æšä¸¾å³ç«¯ç‚¹ $r\in [l,n]$ ã€‚æ ¹æ®æ˜¾ç„¶çš„è´ªå¿ƒç­–ç•¥ï¼Œå¦‚æœå³ç«¯ç‚¹åœ¨æŸä¸€åŒºé—´ç§»åŠ¨æ—¶ï¼Œ$\gcd(a_l,a_{l+1},â€¦,a_r)$ ä¿æŒä¸å˜ï¼Œåˆ™å³ç«¯ç‚¹è¶Šå¤§è¶Šå¥½ã€‚ å› æ­¤å¯ä»¥ç”¨å€å¢ä¼˜åŒ–å³ç«¯ç‚¹çš„ç¡®å®šã€‚ä½†æ˜¯åœ¨å€å¢çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦å¤šæ¬¡æŸ¥è¯¢åŒºé—´æœ€å¤§å…¬çº¦æ•°ï¼›æˆ‘ä»¬å¯ä»¥ç”¨STè¡¨çš„æ€è·¯å¯¹åºåˆ—é¢„å¤„ç†ï¼Œåšåˆ° $O(1)$ å¤æ‚åº¦æŸ¥è¯¢ã€‚ ä½†æ˜¯ï¼Œå¦‚æœå·²ç»ç¡®å®šå·¦ç«¯ç‚¹ $l$ ï¼Œä¸åŒçš„å³ç«¯ç‚¹é€‰å–ä¼šå¯¹åº”è®¸å¤šä¸åŒçš„æœ€å¤§å…¬çº¦æ•°å€¼ï¼Œé‚£ä¹ˆè¯¥ç®—æ³•çš„å¤æ‚åº¦å°†æ— æ³•æ‰¿å—ã€‚ ç¨åŠ è§‚å¯Ÿï¼Œå¯ä»¥å‘ç°å½“å·¦ç«¯ç‚¹ç¡®å®šæ—¶ï¼Œå³ç«¯ç‚¹å³ç§»ä¸€ä¸ªå•ä½ï¼ŒåŸå­æ®µçš„æœ€å¤§å…¬çº¦æ•°è¦ä¹ˆç»´æŒä¸å˜ï¼›è¦ä¹ˆå˜ä¸ºåŸæœ€å¤§å…¬çº¦æ•°çš„ä¸€ä¸ªçº¦æ•°ã€‚æ¢è¨€ä¹‹ï¼Œå½“å·¦ç«¯ç‚¹ç¡®å®šæ—¶ï¼Œä¸åŒçš„å³ç«¯ç‚¹æœ€å¤šå¯¹åº” $\log_2n$ ä¸ªä¸åŒçš„æœ€å¤§å…¬çº¦æ•°å€¼ã€‚ç®—æ³•å¤æ‚åº¦å¾—ä»¥æ§åˆ¶åœ¨ $O(n(\log n)^2)$ ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int T, N;ll ans;ll a[100005];ll st[100005][18];int lg[100005];inline ll query(int l, int r) &#123; int k = lg[r - l + 1]; return gcd(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]);&#125;int main() &#123; lg[1] = 0; for (register int i = 2; i &lt;= 100000; ++i) lg[i] = lg[i &gt;&gt; 1] + 1; scanf("%d", &amp;N); for (register int i = 1; i &lt;= N; ++i) scanf("%lld", &amp;st[i][0]); for (register int j = 1; j &lt;= lg[N]; ++j) for (register int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= N; ++i) st[i][j] = gcd(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); for (register int l = 1; l &lt;= N; ++l) &#123; int r = l; while (r &lt;= N) &#123; ll cur = query(l, r); for (register int i = lg[N]; i &gt;= 0; --i) &#123; if (r + (1 &lt;&lt; i) &lt;= N &amp;&amp; query(l, r + (1 &lt;&lt; i)) == cur) r += (1 &lt;&lt; i); &#125; ans = max(ans, cur * (r - l + 1)); r += 1; &#125; &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>å€å¢</tag>
        <tag>STç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-uva11021éº»çƒç¹è¡]]></title>
    <url>%2F2019%2F08%2F23%2Fsolution-luogu-uva11021%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ æœ‰ $k$ åªéº»çƒï¼Œæ¯åªæ´»ä¸€å¤©å°±ä¼šæ­»äº¡ï¼Œä¸´æ­»å‰å¯èƒ½ä¼šç”Ÿå‡ºä¸€äº›æ–°çš„éº»çƒã€‚å…·ä½“æ¥è¯´ï¼Œç”Ÿ $i$ åªéº»çƒçš„æ¦‚ç‡ä¸º $P_i$ ã€‚ç»™å®š $m$ ï¼Œæ±‚ $m$ å¤©åæ‰€æœ‰éº»çƒå‡æ­»äº¡çš„æ¦‚ç‡ã€‚ æˆ‘æ„Ÿè°¢æˆ‘è‡ªå·± æ¯åªéº»çƒå‡å¯è§†ä¸ºä¸€ä¸ªç‹¬ç«‹çš„é—®é¢˜ã€‚è®¾ $f[i]$ è¡¨ç¤ºç¬¬ä¸€å¤©åªæœ‰ $1$ åªéº»çƒï¼Œåœ¨ç¬¬ $i$ å¤©å®ƒåŠå®ƒçš„åä»£å…¨éƒ¨æ­»äº¡çš„æ¦‚ç‡ã€‚ç”±å…¨æ¦‚ç‡å…¬å¼ï¼Œæœ‰ f[i]=P_0+P_1f[i-1]+P_2f[i-1]^2+P_3f[i-1]^3+...+P_{n-1}f[i-1]^{n-1}å…¶ä¸­ $P_jf[i-j]^j$ çš„å«ä¹‰æ˜¯è¿™ä¸ªéº»çƒç”Ÿäº† $j$ ä¸ªåä»£ï¼Œå¹¶ä¸”å®ƒä»¬åœ¨ $i-1$ å¤©åå…¨éƒ¨æ­»äº¡çš„æ¦‚ç‡ã€‚ç”±äºä¸€å¼€å§‹æœ‰ $k$ åªéº»çƒï¼Œæœ€ç»ˆç­”æ¡ˆä¸º $f[m]^k$ ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int T;int N, K, M;double P[1005];double f[1005];int main() &#123; cin &gt;&gt; T; for (register int Case = 1; Case &lt;= T; ++Case) &#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; M; for (register int i = 0; i &lt; N; ++i) cin &gt;&gt; P[i]; f[0] = 0; for (register int i = 1; i &lt;= M; ++i) &#123; f[i] = 0; for (register int j = 0; j &lt; N; ++j) f[i] += P[j] * pow(f[i - 1], j); &#125; cout &lt;&lt; "Case #" &lt;&lt; Case &lt;&lt; ": "; cout &lt;&lt; fixed &lt;&lt; setprecision(8) &lt;&lt; pow(f[M], K) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ¦‚ç‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2279æ¶ˆé˜²å±€çš„è®¾ç«‹]]></title>
    <url>%2F2019%2F08%2F19%2Fsolution-luogu-p2279%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€æ£µæœ‰ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ±‚è‡³å°‘éœ€è¦æ ‡è®°å¤šå°‘ä¸ªç‚¹ä½¿å¾—æ ‘ä¸Šä»»æ„ä¸¤ä¸ªç‚¹çš„è·ç¦»å‡å°äºç­‰äº $2$ $n \le 1000$ æ„Ÿè°¢@oyçš„è´¡çŒ® å®é™…ä¸Šå°±æ˜¯è¿™é“é¢˜çš„ç®€åŒ–ç‰ˆã€‚ é¦–å…ˆå®šä¹‰çŠ¶æ€ã€‚$f[u][4]$ è¡¨ç¤ºèŠ‚ç‚¹ $u$ çš„äºŒçº§ç¥–å…ˆï¼ˆçˆ¶äº²çš„çˆ¶äº²ï¼‰åŠä»¥ä¸‹èŠ‚ç‚¹è¢«å®Œå…¨è¦†ç›–ï¼Œæ‰€éœ€çš„æœ€å°ä»£ä»·ã€‚$f[u][3]$ è¡¨ç¤ºèŠ‚ç‚¹ $u$ çš„ä¸€çº§ç¥–å…ˆåŠä»¥ä¸‹èŠ‚ç‚¹è¢«å®Œå…¨è¦†ç›–æ‰€éœ€æœ€å°ä»£ä»·ã€‚ä»¥æ­¤ç±»æ¨ï¼Œ $f[u][0]$ è¡¨ç¤ºèŠ‚ç‚¹ $u$ çš„äºŒçº§å„¿å­ï¼ˆå„¿å­çš„å„¿å­ï¼‰åŠä»¥ä¸‹èŠ‚ç‚¹è¢«å®Œå…¨è¦†ç›–æ‰€éœ€çš„æœ€å°ä»£ä»·ã€‚ è€ƒè™‘ $f[u][4]$ çš„æ¨å¯¼ã€‚ç”±äºæ¯ä¸ªèŠ‚ç‚¹è¢«é€‰ä¸­ååªèƒ½è¦†ç›–åˆ°ä¸å…¶è·ç¦»å°äºç­‰äºäºŒçš„èŠ‚ç‚¹ï¼Œè¦ä½¿ $u$ çš„äºŒçº§ç¥–å…ˆè¢«è¦†ç›–åˆ°ï¼Œåˆ™èŠ‚ç‚¹ $u$ å¿…é¡»è¢«é€‰å–ã€‚å¯¹èŠ‚ç‚¹ $u$ çš„å„ä¸ªå„¿å­æ²¡æœ‰è¦æ±‚ã€‚å› æ­¤ï¼Œ$f[u][4]=1+\Sigma f[v][0â€¦4]$ ã€‚ è€ƒè™‘ $f[u][3]$ã€‚ç”±äºåªéœ€è¦è¦†ç›–åˆ°èŠ‚ç‚¹ $u$ çš„çˆ¶äº²ï¼Œåªéœ€ä½¿èŠ‚ç‚¹ $u$ çš„è‡³å°‘ä¸€ä¸ªå­èŠ‚ç‚¹å¯ä»¥è¦†ç›–åˆ°å…¶äºŒçº§ç¥–å…ˆå³å¯ã€‚åŒæ—¶ï¼Œè¯¥å­èŠ‚ç‚¹åœ¨è¦†ç›–åˆ°èŠ‚ç‚¹ $u$ çš„äºŒçº§ç¥–å…ˆæ—¶ï¼Œå¯ä»¥åŒæ—¶è¦†ç›–åˆ°èŠ‚ç‚¹ $u$ çš„å…¶ä»–å„¿å­ï¼Œå› æ­¤èŠ‚ç‚¹ $u$ çš„å…¶ä»–å„¿å­ä¸å¿…è¢«è¦†ç›–ã€‚$f[u][3]=f[k][4]+\Sigma f[v][1â€¦4]$ã€‚ $f[u][2]$ çš„æƒ…å†µä¸ $f[u][3]$ ç±»ä¼¼ï¼Œåªéœ€ä¿è¯ä¸€ä¸ªå„¿å­èƒ½å°†èŠ‚ç‚¹ $u$ è¦†ç›–å³å¯ã€‚ $f[u][2]=f[k][3]+\Sigma f[v][2â€¦4]$ ã€‚ $f[u][1]$ ä¸ $f[u][0]$ çš„æ¨å¯¼ç›¸å¯¹ç®€å•ï¼Œå› ä¸ºå„ä¸ªå­èŠ‚ç‚¹ä¹‹é—´ä¸ä¼šç›¸äº’å½±å“ã€‚ $f[u][1]=\Sigma f[v][2â€¦4]$ï¼Œ$f[u][0]=\Sigma f[v][1â€¦4]$ã€‚ å¯¹è½¬ç§»æ–¹ç¨‹è¿›è¡Œç®€å•ä¼˜åŒ–å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; G[1005];int N;int f[1005][10];void dp(int u, int fa) &#123; f[u][3] = 0x3f3f3f3f; f[u][2] = 0x3f3f3f3f; f[u][4] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dp(v, u); f[u][0] += f[v][1]; f[u][1] += f[v][2]; f[u][2] = min(f[u][2], f[v][3] - f[v][2]); f[u][3] = min(f[u][3], f[v][4] - f[v][1]); f[u][4] += f[v][0]; &#125; f[u][2] += f[u][1]; f[u][3] += f[u][0]; f[u][3] = min(f[u][3], f[u][4]); f[u][2] = min(f[u][2], f[u][3]); f[u][1] = min(f[u][1], f[u][2]); f[u][0] = min(f[u][0], f[u][1]); &#125;int main() &#123; scanf("%d", &amp;N); for (register int u = 2; u &lt;= N; ++u) &#123; int v; scanf("%d", &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1, 0); printf("%d", f[1][2]); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>æ ‘å½¢dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -PÃ³lyaè®¡æ•°ä¸Burnsideå¼•ç†]]></title>
    <url>%2F2019%2F08%2F13%2Falgorithm-polya%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°å¦‚æœé¢˜ç›®ä¸­å®šä¹‰ä¸€ç§ç­‰ä»·å…³ç³»ï¼Œæ»¡è¶³ç­‰ä»·å…³ç³»çš„å…ƒç´ è¢«çœ‹æˆåŒä¸€ç±»ï¼Œåªç»Ÿè®¡ä¸€æ¬¡ï¼›è¿™æ ·çš„é—®é¢˜ç§°ä¸ºç­‰ä»·ç±»è®¡æ•°é—®é¢˜ã€‚ä¸€èˆ¬çš„ç­‰ä»·ç±»è®¡æ•°é—®é¢˜å¯ä»¥ç”¨ Burnside å¼•ç†æˆ– PÃ³lyaå®šç†è§£å†³ã€‚ æ¨¡æ¿ç½®æ¢ç½®æ¢å®é™…ä¸Šå°±æ˜¯ä¸€ä¸€æ˜ å°„ï¼Œ$f$ å¯ä»¥çœ‹æˆå®šä¹‰åŸŸå’Œå€¼åŸŸä¸º $\lbrace 1,2,3,â€¦,n\rbrace$ çš„å‡½æ•°ï¼Œå…¶ä¸­ $f(1)=a_1$ï¼Œ $f(2)=a_2$ ç­‰ç­‰ã€‚ f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)å‡½æ•°å¤åˆå¦‚æœ f= \left(\begin{array}{cccc} 1&2&...&n \\ a_1&a_2&...&a_n \\ \end{array}\right)ä¸” g=\left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)æ˜¯ $\lbrace 1,2,3,â€¦,n\rbrace$ çš„ä¸¤ä¸ªç½®æ¢ï¼Œåˆ™ä»–ä»¬çš„å¤åˆæŒ‰ç…§å…ˆ $f$ å $g$ çš„é¡ºåºæ”¾ç½®å¾—åˆ°ä¸€ä¸ªæ–°ç½®æ¢ï¼š g\circ f= \left(\begin{array}{cccc} 1&2&...&n \\\ a_1&a_2&...&a_n \\ \end{array}\right) \circ \left(\begin{array}{cccc} 1&2&...&n \\ b_1&b_2&...&b_n \\ \end{array}\right)å¾ªç¯ä¸ºäº†å¤„ç†æ–¹ä¾¿ï¼Œå¸¸å¸¸æŠŠç½®æ¢åˆ†è§£æˆå¾ªç¯çš„ä¹˜ç§¯ï¼Œå…¶ä¸­æ¯ä¸ªå¾ªç¯ä»£è¡¨ä¸€äº›å…ƒç´ â€œå¾ªç¯ç§»ä½â€ã€‚æ¯”å¦‚ $(1,4,3)$ è¿™ä¸ªå¾ªç¯è¡¨ç¤º $1\rightarrow 4$ï¼Œ$4\rightarrow 3$ï¼Œ$3\rightarrow 1$ã€‚ æ˜“è¯ä»»æ„ç½®æ¢éƒ½å¯ä»¥åˆ†è§£ä¸ºå¾ªç¯ä¹˜ç§¯çš„å½¢å¼ã€‚ ä¾‹é¢˜ åœ¨ 2*2 æ–¹æ ¼ä¸­æ¶‚é»‘ç™½ä¸¤è‰²ï¼Œæ–¹æ ¼å…è®¸æ—‹è½¬ï¼Œæœ‰å‡ ç§æ–¹æ³•ï¼Ÿ å‡è®¾ä¸è€ƒè™‘æ–¹æ ¼å…è®¸æ—‹è½¬ï¼Œåˆ™å…±æœ‰ 16 ç§ä¸Šè‰²æ–¹æ¡ˆã€‚æœ¬é¢˜ä¸­â€œæ—‹è½¬åç›¸åŒâ€å³ä¸ºä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œæœ‰äº†ç­‰ä»·å…³ç³»ï¼Œæ‰€æœ‰å…ƒç´ ä¼šè¢«åˆ†ä¸ºè‹¥å¹²ä¸ªç­‰ä»·ç±»ï¼Œæˆ‘ä»¬éœ€è¦ç»Ÿè®¡çš„å³ä¸ºç­‰ä»·ç±»çš„ä¸ªæ•°ã€‚ å¯¹äºä¸€ä¸ªç½®æ¢ $f$ ï¼Œè‹¥ä¸€ä¸ªç€è‰²æ–¹æ¡ˆ $s$ ç»è¿‡ç½®æ¢åä¸å˜ï¼Œç§° $s$ ä¸º $f$ çš„ä¸åŠ¨ç‚¹ã€‚å°† $f$ çš„ä¸åŠ¨ç‚¹æ•°ç›®è®°ä¸º $C(f)$ï¼Œåˆ™å¯ä»¥è¯æ˜ç­‰ä»·ç±»æ•°ç›®ä¸ºç½®æ¢ç¾¤ä¸­æ‰€æœ‰ $C(f)$ çš„å¹³å‡å€¼ã€‚æ­¤ç»“è®ºç§°ä¸º Burnside å¼•ç†ã€‚ ä¸€èˆ¬åœ°ï¼Œå¦‚æœç½®æ¢ $f$ è¢«åˆ†è§£ä¸º $m(f)$ ä¸ªå¾ªç¯çš„ä¹˜ç§¯ï¼Œé‚£ä¹ˆæ¯ä¸ªå¾ªç¯å†…æ‰€æœ‰ä½ç½®çš„é¢œè‰²å¿…é¡»ç›¸åŒï¼Œå‡è®¾æ¶‚ $k$ ç§é¢œè‰²ï¼Œåˆ™æœ‰ $C(f)=k^{m(f)}$ã€‚å¸¦å…¥ Burnside å¼•ç†çš„è¡¨è¾¾å¼ä¹‹åå¾—åˆ° PÃ³lya å®šç†ï¼šç­‰ä»·ç±»çš„ä¸ªæ•°ç­‰äºç½®æ¢ç¾¤ç§æ‰€æœ‰ç½®æ¢ $f$ çš„ $k^{m(f)}$ çš„å¹³å‡æ•°ã€‚ å°† $t$ ç§é¢œè‰²çš„ $n$ ä¸ªå°çƒæ’æˆä¸€ä¸ªç¯ï¼Œå…è®¸æ—‹è½¬å’Œç¿»è½¬ï¼Œæœ‰å‡ ç§æ–¹æ³•ï¼Ÿ é¦–å…ˆè€ƒè™‘æ—‹è½¬ç½®æ¢ã€‚è®°ç½®æ¢ $f_i$ ä¸ºå°†ç¯å½¢é¡ºæ—¶é’ˆæ—‹è½¬ $i$ ä¸ªå•ä½é•¿åº¦ã€‚æ˜¾ç„¶ï¼Œ$m(f_i)=gcd(i,n)$ ã€‚ å…¶æ¬¡è€ƒè™‘ç¿»è½¬ç½®æ¢ã€‚å½“ $n$ ä¸ºå¥‡æ•°æ—¶ï¼Œ$|G|=n$ï¼Œä¸” $m(f)=(n-1)/2+1$ï¼›å½“ $n$ ä¸ºå¶æ•°æ—¶ï¼Œ$|G|=n$ï¼Œä¸” $m(f)=n/2+1$ã€‚ è®°ï¼š a=\Sigma_{i=0}^{n-1} t^{gcd(i,n)}\\ b=\begin{cases} t^{(n-1)/2+1} , n=2k+1\\ t^{n/2+1},n=2k \end{cases}æœ€ç»ˆç­”æ¡ˆ $ans=(a+b)/2n$ã€‚]]></content>
      <tags>
        <tag>æ•°è®º</tag>
        <tag>ç¾¤è®º</tag>
        <tag>PÃ³lyaè®¡æ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -KMPæ¨¡å¼åŒ¹é…]]></title>
    <url>%2F2019%2F08%2F07%2Falgorithm-kmp%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°ç»™å®šä¸€ä¸ªæ–‡æœ¬ $A$ å’Œä¸€ä¸ªå­—ç¬¦ä¸² $B$ ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ KMP ç®—æ³•å°è¯•æ‰¾åˆ°å¹¶å±•ç¤º $B$ åœ¨ $A$ ä¸­çš„æ‰€æœ‰å‡ºç°ï¼ˆoccurrenceï¼‰ã€‚ æ¨¡æ¿é¢„å¤„ç†å‰ç¼€å‡½æ•°é¢„å¤„ç†å‡ºå­—ç¬¦ä¸² $B$ çš„å‰ç¼€å‡½æ•° $next$ æ•°ç»„ï¼Œå…¶ä¸­ $next[i]$ ä¸ºæ—¢æ˜¯å­ä¸² $B[1â€¦i]$ çš„å‰ç¼€åŒæ—¶ä¹Ÿæ˜¯è¯¥å­ä¸²çš„åç¼€çš„æœ€é•¿çœŸå‰ç¼€é•¿åº¦ã€‚ä¸€ä¸ªå­—ç¬¦ä¸²çš„çœŸå‰ç¼€æ˜¯å…¶å‰ç¼€ä½†ä¸ç­‰äºè¯¥å­—ç¬¦ä¸²æœ¬èº«ã€‚æ ¹æ®å®šä¹‰ï¼Œ $next[1]=0$ ã€‚ ç®—æ³•æµç¨‹ åœ¨å¾ªç¯ä¸­ä»¥ $i=2$ åˆ° $i=n$çš„é¡ºåºè®¡ç®—å‰ç¼€å‡½æ•° $next[i]$ çš„å€¼ã€‚ï¼ˆ$next[1]$ è¢«èµ‹å€¼ä¸º0ï¼‰ ä¸ºäº†è®¡ç®—å½“å‰çš„å‰ç¼€å‡½æ•°å€¼ $next[i]$ï¼Œæˆ‘ä»¬ä»¤å˜é‡ $j$ è¡¨ç¤ºå³ç«¯ç‚¹ä½äº $i-1$ çš„æœ€é•¿åŒ¹é…å‰åç¼€çš„é•¿åº¦ã€‚åˆå§‹æ—¶ $j=next[i-1]$ ã€‚ é€šè¿‡æ¯”è¾ƒ $B[j+1]$ å’Œ $B[i]$ æ¥æ£€æŸ¥é•¿åº¦ä¸º $j+1$ çš„åç¼€æ˜¯å¦åŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªå‰ç¼€ã€‚å¦‚æœäºŒè€…ç›¸ç­‰ï¼Œé‚£ä¹ˆç½® $next[i]=j+1$ï¼Œå¦åˆ™å‡å°‘ $j$ è‡³ $next[j]$ å¹¶é‡å¤è¯¥è¿‡ç¨‹ã€‚ å¦‚æœ $j=0$ å¹¶ä¸”ä»æ²¡æœ‰ä»»ä½•ä¸€æ¬¡åŒ¹é…ï¼Œåˆ™ç½® $next[i]=0$ å¹¶ç§»è‡³ä¸‹ä¸€ä¸ªä¸‹æ ‡ $i+1$ ã€‚ F.A.Qç®—æ³•æµç¨‹ä¸­çš„æ­¥éª¤ä¸‰ï¼Œä¸ºä»€ä¹ˆè¦å°† $j$ å‡å°‘è‡³ $next[j]$ ï¼Ÿ è€ƒè™‘æˆ‘ä»¬æ­£åœ¨è®¡ç®—çš„ $next[i]$ ã€‚æˆ‘ä»¬è¦ä½¿ $k$ æœ€å¤§åŒ–ï¼Œå¹¶ä¸”ä¿è¯ $B[1â€¦k]$ ä¸ $B[i-k+1â€¦i]$ ç›¸ç­‰ã€‚å°†å…¶æ‹†æˆä¸¤éƒ¨åˆ†çœ‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ $B[1â€¦k-1]$ ä¸ $B[i-k+1â€¦i-1]$ ç›¸ç­‰çš„åŒæ—¶ï¼Œä¿è¯ $B[k]=B[i]$ ï¼Œä¸” $k$ å–åˆ°æœ€å¤§å€¼ã€‚ ä¸éš¾å‘ç°ï¼Œå¦‚æœåªéœ€è¦æœ€å¤§åŒ– $k-1$ ä½¿å¾— $B[1â€¦k-1]$ ä¸ $B[i-k+1â€¦i-1]$ ç›¸ç­‰ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå¿«å¾—å‡ºç­”æ¡ˆã€‚å›é¡¾ä¸€ä¸‹å‰ç¼€å‡½æ•°çš„å®šä¹‰å³å¯å‘ç°ï¼Œè®° $j$ ä¸º $next[i-1]$ï¼Œåˆ™æ­¤æ—¶çš„ $j$ å³ä¸ºæˆ‘ä»¬éœ€è¦æœ€å¤§åŒ–çš„ $k-1$ çš„å€¼ã€‚å¦‚æœè¿™æ—¶åˆæ°å¥½æ»¡è¶³ $B[j+1]=B[i]$ ï¼Œåˆ™æˆ‘ä»¬éœ€è¦æœ€å¤§åŒ–çš„ $k$ å³ä¸º $j+1$ ã€‚ ç„¶è€Œæ­¤æ—¶å¦‚æœä¸èƒ½æ»¡è¶³ $B[j+1]=B[i]$ ï¼Œæˆ‘ä»¬å°±åªèƒ½è€ƒè™‘å‡å° $j$ çš„å€¼ã€‚åœ¨å‡å° $j$ å€¼çš„åŒæ—¶ï¼Œæˆ‘ä»¬è¦å§‹ç»ˆä¿è¯å‡å°åçš„ $jâ€™$ æ»¡è¶³ $B[1â€¦jâ€™]=B[j-jâ€™+1â€¦j]$ ã€‚ ç»“åˆä¸Šå›¾ä¸éš¾çœ‹å‡ºï¼Œè¦ä½¿å¾— $B[1â€¦jâ€™]=B[i-jâ€™â€¦i-1]$ï¼Œå³ä¿è¯ $B[1â€¦jâ€™]=B[j-jâ€™+1â€¦j]$ ã€‚è€Œ $jâ€™$ çš„ç¡®å®šä¹Ÿååˆ†ç®€å•ï¼Œå†æ¬¡ç»“åˆå‰ç¼€å‡½æ•°çš„å®šä¹‰å¯å¾—ï¼Œ $jâ€™$ çš„å–å€¼åº”ä¸º $next[j]$ ã€‚ ä»£ç å®ç°123456next[1] = 0;for (int i = 2, j = 0; i &lt;= M; ++i) &#123; while (j &gt; 0 &amp;&amp; B[i] != B[j + 1]) j = next[j]; if (B[i] == B[j + 1]) j++; next[i] = j;&#125; åœ¨ç›®æ ‡ä¸²ä¸­æŸ¥æ‰¾å­ä¸²è®¡ç®—å‡º $f$ æ•°ç»„ï¼Œå…¶ä¸­ $f[i]$ ä¸ºæ—¢æ˜¯å­ä¸² $B[1â€¦i]$ çš„å‰ç¼€åŒæ—¶ä¹Ÿæ˜¯å­ä¸² $A[1â€¦i]$ çš„åç¼€çš„æœ€é•¿å‰ç¼€é•¿åº¦ã€‚ï¼ˆæ³¨æ„è¿™é‡Œä¸ä¸€å®šæ˜¯çœŸå‰ç¼€ï¼‰åœ¨é¢„å¤„ç†å‰ç¼€å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œç›¸å½“äº $B$ ä¸²ä¸è‡ªå·±æœ¬èº«åšäº†ä¸€æ¬¡æ¨¡å¼åŒ¹é…ï¼Œå› æ­¤æ­¤å¤„çš„ç®—æ³•æµç¨‹ä¸ä¸Šä¸€ä¸ªæ“ä½œååˆ†ç±»ä¼¼ã€‚ ç®—æ³•æµç¨‹ åœ¨å¾ªç¯ä¸­ä»¥ $i=1$ åˆ° $i=n$çš„é¡ºåºè®¡ç®— $f[i]$ çš„å€¼ã€‚ ä¸ºäº†è®¡ç®—å½“å‰çš„ $f[i]$ ï¼Œæˆ‘ä»¬ä»¤å˜é‡ $j$ è¡¨ç¤ºå³ç«¯ç‚¹ä½äº $i-1$ çš„æœ€é•¿åŒ¹é…å‰åç¼€çš„é•¿åº¦ã€‚åˆå§‹æ—¶ $j=f[i-1]$ ã€‚ é€šè¿‡æ¯”è¾ƒ $B[j+1]$ å’Œ $A[i]$ æ¥æ£€æŸ¥ $B$ ä¸²ä¸­é•¿åº¦ä¸º $j+1$ çš„å‰ç¼€æ˜¯å¦ä¹Ÿæ˜¯ $A$ ä¸²ä¸­é•¿åº¦ä¸º $j+1$ çš„åç¼€ã€‚å¦‚æœäºŒè€…ç›¸ç­‰ï¼Œé‚£ä¹ˆç½® $f[i]=j+1$ï¼Œå¦åˆ™å‡å°‘ $j$ è‡³ $next[j-1]$ å¹¶é‡å¤è¯¥è¿‡ç¨‹ã€‚ å¦‚æœ $j=0$ å¹¶ä¸”ä»æ²¡æœ‰ä»»ä½•ä¸€æ¬¡åŒ¹é…ï¼Œåˆ™ç½® $f[i]=0$ å¹¶ç§»è‡³ä¸‹ä¸€ä¸ªä¸‹æ ‡ $i+1$ ã€‚ å¦‚æœ $j=M$ï¼Œå³æ‰¾åˆ° $B$ åœ¨ $A$ ä¸­çš„ä¸€æ¬¡å‡ºç°ã€‚ ä»£ç å®ç°123456for (int i = 1, j = 0; i &lt;= N; ++i) &#123; while (j &gt; 0 &amp;&amp; A[i] != B[j + 1]) j = next[j]; if (A[i] == B[j + 1]) j++; f[i] = p; // if (f[i] == M) do something... &#125;]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFæ¸¸è®°-Codeforces Round]]></title>
    <url>%2F2019%2F08%2F01%2Fcodeforces-1199%2F</url>
    <content type="text"><![CDATA[æ¯”èµ›é“¾æ¥ äººç”Ÿç¬¬äºŒæ¬¡è§‰å¾—CFçš„é¢˜è¿˜æ˜¯å¯åšçš„ã€‚ç›®å‰åªå¼„äº†5é“ï¼Œå‰©ä¸‹ä¸€é¢˜å’•ç€ã€‚ #A City Dayç®€å•æ¨¡æ‹Ÿï¼Œå¼€å¿ƒçš„è¯å¯ä»¥å†™ä¸ªå•è°ƒé˜Ÿåˆ—ã€‚ #B Water Lilyåˆä¸­æ•°å­¦é¢˜ï¼Œå‹¾è‚¡å®šç†ã€‚ (x+H)^2=x^2+L^2 \\ x=(L^2-H^2)/2H#C MP3æ—¢ç„¶ç¡¬ç›˜çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œé‚£ä¹ˆ $K$ åº”è¯¥å°½å¯èƒ½å¤§ã€‚ä¸ºäº†è®© $K$ å°½å¯èƒ½å¤§ï¼Œ $k$ ä¹Ÿè¦å°½å¯èƒ½å¤§ã€‚ æ‰€ä»¥ï¼š k=\lfloor(I*8)/n\rfloor \\ K=2^kæŠŠ $K$ æ±‚å‡ºæ¥ä¹‹åï¼Œæˆ‘ä»¬å®é™…ä¸Šåªéœ€ä¿ç•™ $K$ ç§ä¸åŒçš„æ•°å­—ï¼Œå¹¶ä½¿åˆ é™¤çš„æ•°å­—æœ€å°‘ã€‚ æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬åªèƒ½åˆ é™¤æœ€å¤§çš„æˆ–æœ€å°çš„æ•°ã€‚è€ƒè™‘å¯¹ $a$ æ•°ç»„ç¦»æ•£åŒ–ï¼Œå¹¶ç”¨ $b$ æ•°ç»„è®°å½•æ¯ä¸ªæ•°å€¼å‡ºç°çš„æ¬¡æ•°ã€‚ä¿ç•™ä¸‹æ¥çš„æ•°å€¼ä¸€å®šæ˜¯è¿ç»­çš„$K$ä¸ªï¼Œåªéœ€åœ¨ $b$æ•°ç»„ä¸Šè¿›è¡Œå‰ç¼€å’Œé¢„å¤„ç†ï¼Œæšä¸¾ä¿ç•™çš„ $K$ ä¸ªæ•°å€¼ä½ç½®å³å¯ã€‚ #D Welfare Stateéä¸»æµè­¦å‘Šâš  è§‚å¯Ÿåˆ°åªæœ‰ä¸€æ¬¡æŸ¥è¯¢ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é’ˆå¯¹æ¯ä¸ªä½ç½®ï¼Œæ±‚å‡ºå½“å‰ä½ç½®åœ¨ç»è¿‡ $q$ æ¬¡æ“ä½œåçš„å€¼å¹¶è¾“å‡ºã€‚ å…ˆæ¥çœ‹ä¸¤ä¸ªç»“è®ºï¼š å¯ä»¥å¿½ç•¥å¯¹å½“å‰ä½ç½®çš„æœ€åä¸€æ¬¡ä¸€å·æ“ä½œä¹‹å‰çš„æ‰€æœ‰æ“ä½œã€‚ ç®¡ä½ ä¹‹å‰è¢«æ”¹æˆä»€ä¹ˆäº†ï¼Œç»è¿‡ä¸€æ¬¡ä¸€å·æ“ä½œå°±å¾—é‡æ–°æ¥è¿‡ã€‚ å¯¹äºè¿ç»­çš„å‡ æ¬¡äºŒå·æ“ä½œï¼Œåªéœ€ä¿ç•™ $x$ æœ€å¤§çš„é‚£ä¸€æ¬¡æ“ä½œã€‚ åºŸè¯ã€‚ æœ¬é¢˜ä¸­äºŒå·æ“ä½œæ˜¯é’ˆå¯¹æ•´ä½“çš„ï¼Œæ‰€ä»¥è€ƒè™‘å¼€æ•°ç»„ $s$ è®°å½•æ‰€æœ‰äºŒå·æ“ä½œçš„åç¼€æœ€å¤§å€¼ã€‚åœ¨é’ˆå¯¹æ¯ä¸€ä½ç½®è¿›è¡Œè®¡ç®—æ—¶ï¼Œåªéœ€å°†æœ€åä¸€æ¬¡ä¸€å·æ“ä½œä¹‹å‰çš„æ“ä½œåˆ é™¤åï¼Œä¸äºŒå·æ“ä½œçš„åç¼€æœ€å¤§å€¼æ¯”è¾ƒå³å¯å¾—å‡ºç­”æ¡ˆã€‚ #E Matching vs Independent Set#F Rectangle Painting 1è¶…æ°´çš„ä¸€é“ F é¢˜ï¼ $f[x1][y1][x2][y2]$è¡¨ç¤ºå°†ä¸€ä¸ªçŸ©å½¢å…¨éƒ¨æ¶‚æˆç™½è‰²çš„æœ€å°è´¹ç”¨ï¼ŒçŠ¶æ€è½¬ç§»è€ƒè™‘ç”±ä¸¤ä¸ªå­çŸ©å½¢åˆå¹¶æˆ–å°†ä¸€æ•´å—ä¸Šè‰²å³å¯ã€‚]]></content>
      <categories>
        <category>CFæ¸¸è®°</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -splayä¼¸å±•æ ‘]]></title>
    <url>%2F2019%2F07%2F24%2Falgorithm-splay%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡éƒ¨åˆ†å†…å®¹è½¬è½½è‡ª OI Wiki Splay $\LaTeX$ å°±å…ˆå’•ç€å§â€¦â€¦æœ‰æ—¶é—´æ…¢æ…¢æ æ¦‚è¿°Splayæ˜¯ä¸€ç§äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œå®ƒé€šè¿‡ä¸æ–­å°†æŸä¸ªèŠ‚ç‚¹æ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹ï¼Œä½¿å¾—æ•´æ£µæ ‘ä»ç„¶æ»¡è¶³äºŒå‰æŸ¥æ‰¾æ ‘çš„æ€§è´¨ï¼Œå¹¶ä¸”ä¿æŒå¹³è¡¡è€Œä¸è‡³äºé€€åŒ–ä¸ºé“¾ï¼Œå®ƒç”± Daniel Sleator å’Œ Robert Tarjan å‘æ˜ã€‚ ç»“æ„èŠ‚ç‚¹ç»´æŠ¤ä¿¡æ¯ root æ ¹èŠ‚ç‚¹ç¼–å· cnt èŠ‚ç‚¹ä¸ªæ•° node[] èŠ‚ç‚¹å†…éƒ¨ä¿¡æ¯ fa çˆ¶äº² ch[0/1] å·¦å³å„¿å­ç¼–å· val èŠ‚ç‚¹æƒå€¼ cnt æƒå€¼å‡ºç°æ¬¡æ•° sum å­æ ‘å¤§å° 1234struct Node &#123; int fa, ch[2], val, cnt, sum;&#125;node[MAXN];int root, cnt; åŸºæœ¬æ“ä½œ update(u) åœ¨æ”¹å˜èŠ‚ç‚¹ä½ç½®åï¼Œå°†èŠ‚ç‚¹uçš„sumå€¼æ›´æ–° identify(u) åˆ¤æ–­èŠ‚ç‚¹uæ˜¯çˆ¶äº²çš„å·¦å„¿å­è¿˜æ˜¯å³å„¿å­ clear(u) é”€æ¯èŠ‚ç‚¹u 123456789void update(int u) &#123; node[u].sum = node[u].cnt + node[node[u].ch[0]].sum + node[node[u].ch[1]].sum;&#125;bool identify(int u) &#123; return u == node[node[u].fa].ch[1];&#125;void clear(int u) &#123; node[u].fa = node[u].ch[0] = node[u].ch[1] = node[u].val = node[u].cnt = node[u].sum = 0;&#125; è¿æ¥æ“ä½œ connect(u, f, p) å°†uè¿æ¥åœ¨fçš„ä¸‹æ–¹ï¼Œè¿æ¥æ–¹å‘ä¸ºp 1234void connect(int u, int f, int p) &#123; node[u].fa = f; node[f].ch[p] = u;&#125; æ—‹è½¬æ“ä½œåˆ†æå’•å’•å’• 1234567891011void rotate(int x) &#123; int y = node[x].fa; int r = node[y].fa; int rp = identify(y); int yp = identify(x); int b = node[x].ch[yp ^ 1]; connect(b, y, yp); connect(y, x, yp ^ 1); connect(x, r, rp); update(y), update(x);&#125; æ—‹è½¬éœ€è¦ä¿è¯ï¼š å¹³è¡¡æ ‘çš„ä¸­åºéå†ä¸å˜ï¼ˆä¸èƒ½ç ´åBSTçš„æ€§è´¨ï¼‰ å—å½±å“çš„èŠ‚ç‚¹ç»´æŠ¤çš„ä¿¡æ¯ä¾ç„¶æ­£ç¡®æœ‰æ•ˆ rootå¿…é¡»æŒ‡å‘æ—‹è½¬åçš„æ ¹èŠ‚ç‚¹ å…·ä½“åˆ†ææ—‹è½¬æ­¥éª¤ï¼ˆå‡è®¾éœ€è¦æ—‹è½¬çš„èŠ‚ç‚¹ä¸ºxï¼Œå…¶çˆ¶äº²ä¸ºyï¼Œä»¥å³æ—‹ä¸ºä¾‹ï¼‰ï¼š å°†yçš„å·¦å„¿å­æŒ‡å‘xçš„å³å„¿å­ï¼Œä¸”xçš„å³å„¿å­çš„çˆ¶äº²æŒ‡å‘y å°†xçš„å³å„¿å­æŒ‡å‘yï¼Œä¸”yçš„çˆ¶äº²æŒ‡å‘x å¦‚æœåŸæ¥çš„yè¿˜æœ‰çˆ¶äº²zï¼Œé‚£ä¹ˆæŠŠzçš„æŸä¸ªå„¿å­ï¼ˆåŸæ¥yæ‰€åœ¨çš„å„¿å­ä½ç½®ï¼‰æŒ‡å‘xï¼Œä¸”xçš„çˆ¶äº²æŒ‡å‘z 1234567891011void rotate(int x) &#123; int y = node[x].fa, z = node[y].fa, p = identify(x); node[y].ch[p] = node[x].ch[p ^ 1]; node[node[x].ch[p ^ 1]].fa = y; node[x].ch[p ^ 1] = y; node[y].fa = x; node[x].fa = z; if (z) node[z].ch[y == node[z].ch[1]] = x; update(y); update(x);&#125; Splay æ“ä½œSplayè§„å®šï¼šæ¯è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹åéƒ½è¦å¼ºåˆ¶å°†å…¶æ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹ã€‚æ­¤æ—¶æ—‹è½¬æ“ä½œå…·ä½“åˆ†ä¸º6ç§æƒ…å†µè®¨è®ºï¼ˆå…¶ä¸­xä¸ºéœ€è¦æ—‹è½¬åˆ°æ ¹çš„èŠ‚ç‚¹ï¼‰ åˆ†æå’•å’•å’• 12345void splay(int x) &#123; for (int f = node[x].fa; f = node[x].fa, f; rotate(x)) if (node[f].fa &amp;&amp; identify(x) == identify(f)) rotate(f); root = x;&#125; æ’å…¥æ“ä½œåˆ†æå’•å’•å’• 123456789101112131415161718192021222324252627282930void insert(int val) &#123; if (root == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; root = cnt; update(root); return; &#125; int cur = root, f = 0; while (1) &#123; if (node[cur].val == val) &#123; node[cur].cnt++; update(cur); update(f); splay(cur); break; &#125; f = cur, cur = node[cur].ch[node[cur].val &lt; k]; if (cur == 0) &#123; node[++cnt].val = val; node[cnt].cnt++; node[cnt].fa = f; node[f].ch[node[f].val &lt; k] = cnt; update(cnt); update(f); splay(cnt); break; &#125; &#125;&#125; æŸ¥è¯¢xçš„æ’ååˆ†æå’•å’•å’• 123456789101112131415int queryid(int val) &#123; int ans = 0, cur = root; while (1) &#123; if (val &lt; node[cur].val) cur = node[cur].ch[0]; else &#123; ans += node[node[cur].ch[0]].sum; if (val == node[cur].val) &#123; splay(cur); return ans + 1; &#125; ans += node[cur].cnt; cur = node[cur].ch[1]; &#125; &#125;&#125; æŸ¥è¯¢æ’åä¸ºkçš„æ•°åˆ†æå’•å’•å’• 1234567891011int queryrid(int k) &#123; int cur = root; while (1) &#123; if (node[cur].ch[0] &amp;&amp; k &lt;= node[node[cur].ch[0]].sum) cur = node[cur].ch[0]; else &#123; k -= node[cur].cnt + node[node[cur].ch[0]].sum; if (k &lt;= 0) return node[cur].val; cur = node[cur].ch[1]; &#125; &#125;&#125; æŸ¥è¯¢å‰é©±åˆ†æå¤å¤å¤ 1234567int querypre(int val) &#123; insert(val); int cur = node[root].ch[0]; while (node[cur].ch[1]) cur = node[cur].ch[1]; delet(val); return cur;&#125; æŸ¥è¯¢åç»§1234567int querynxt(int val) &#123; insert(val); int cur = node[root].ch[1]; while (node[cur].ch[0]) cur = node[cur].ch[0]; delet(val); return cur;&#125; åˆ é™¤å…ƒç´ 1234567891011121314151617181920212223242526272829303132void delet(int val) &#123; queryid(val); if (node[root].cnt &gt; 1) &#123; node[root].cnt--; update(root); return; &#125; if (node[root].ch[0] == 0 &amp;&amp; node[root].ch[1] == 0) &#123; clear(root); root = 0; return; &#125; if (node[root].ch[1] == 0) &#123; int cur = root; root = node[root].ch[0]; node[root].fa = 0; clear(cur); return; &#125; if (node[root].ch[0] == 0) &#123; int cur = root; root = node[root].ch[1]; node[root].fa = 0; clear(cur); return; &#125; int u = querypre(val), cur = root; // ??? node[node[cur].ch[1]].fa = u; node[u].ch[1] = node[cur].ch[1]; clear(cur); update(root);&#125;]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å¹³è¡¡æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p3275ç³–æœ]]></title>
    <url>%2F2019%2F07%2F23%2Fsolution-luogu-p3275%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$n$çš„åºåˆ—ä»¥åŠ$k$ä¸ªæ¡ä»¶ï¼Œæ¯ä¸ªæ¡ä»¶è¦æ±‚åºåˆ—å½“ä¸­ä¸€ä¸ªç‚¹çš„æƒå€¼å¤§äº/å°äº/ä¸å¤§äº/ä¸å°äº/ç­‰äºå¦ä¸€ä¸ªç‚¹ã€‚æ±‚è¿™ä¸ªåºåˆ—æ€»å’Œçš„æœ€å°å€¼ $1 \le k,n \le 100000$ æ„Ÿè°¢@oy çš„è´¡çŒ® å·®åˆ†çº¦æŸç³»ç»Ÿçš„æ¨¡æ¿é¢˜ã€‚ è®° $d$ æ•°ç»„ä¸ºä»¥ $S$ ä¸ºæºç‚¹åˆ°å„ä¸ªèŠ‚ç‚¹çš„æœ€é•¿è·¯ã€‚æ ¹æ®æœ€é•¿è·¯çš„æ€§è´¨ï¼Œå¦‚æœå­˜åœ¨ä¸€æ¡è¾¹ $(u,v,w)$ ï¼Œåˆ™ä¸€å®šæ»¡è¶³ä»¥ä¸‹ä¸ç­‰å¼ï¼š d[u]+w(u,v)\le d[v]æˆ‘ä»¬å¯ä»¥å°†é¢˜ç›®ä¸­ç»™å‡ºçš„ä¸ç­‰å…³ç³»è½¬åŒ–ä¸ºå›¾ä¸­çš„æœ‰å‘è¾¹ï¼Œç„¶åé€šè¿‡å•æºæœ€é•¿è·¯æ±‚å‡ºçš„ä¸€ç»„ $\lbrace d_n\rbrace$ å³ä¸ºå·®åˆ†çº¦æŸç³»ç»Ÿçš„ä¸€ç»„è§£ã€‚ å› æ­¤ï¼Œåœ¨å›¾ä¸­è¿ä¸€æ¡è¾¹ $(u,v,w)$ ç›¸å½“äºå¯¹ $d[u]$ å’Œ $d[v]$ çš„å–å€¼ä½œå‡ºé™åˆ¶ï¼Œæˆ‘ä»¬åªéœ€åœ¨æ„é€ å‡ºä¸€å¼ æœ‰å‘å›¾ï¼Œå¹¶æ±‚å‡ºå…¶å•æºæœ€é•¿è·¯å³ä¸ºç­”æ¡ˆã€‚ æœ‰å‘è¾¹çš„æ„é€ æ–¹å¼å¦‚ä¸‹ï¼š é™åˆ¶ $d[A]=d[B]$ d[A]=d[B] \Leftrightarrow (d[B]\le d[A])\wedge(d[A]\le d[B]) \Leftrightarrow (d[B]+0\le d[A])\wedge(d[A]+0\le d[B])è¿è¾¹ï¼š$(A,B,0)$ï¼Œ$(B,A,0)$ é™åˆ¶ $d[A]&lt;d[B]$ d[A]d[B]\Leftrightarrow d[B]+1\le d[A] è¿è¾¹ï¼š$(B,A,1)$ é™åˆ¶ $d[A]\le d[B]$ è¿è¾¹ï¼š$(A,B,0)$ é™åˆ¶ $d[i]&gt;0$ è¿è¾¹ï¼š$(S,i,1)$ è¿å®Œæ‰€æœ‰çš„è¾¹åï¼Œè·‘ä¸€éå•æºæœ€é•¿è·¯ï¼›å¦‚æœå­˜åœ¨æ­£ç¯åˆ™è¾“å‡ºæ— è§£ã€‚ ç»Ÿè®¡ç­”æ¡ˆæ—¶è®°å¾—å¼€$long$ $long$ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define die &#123;puts("-1"); exit(0);&#125;typedef long long ll;const int MAXN = 100005;struct Edge &#123; int v, w; Edge(int v, int w) &#123; this -&gt; v = v, this -&gt; w = w; &#125;&#125;;vector&lt;Edge&gt; G[MAXN];int N, K;bool inq[MAXN];int d[MAXN], cnt[MAXN];inline void AddEdge(int u, int v, int w) &#123; G[u].push_back(Edge(v, w));&#125;void SPFA() &#123; queue&lt;int&gt; q; q.push(N + 1); d[N + 1] = 0; inq[N + 1] = 1; while (q.size()) &#123; int u = q.front(); q.pop(); if (cnt[u] &gt;= N) die cnt[u]++; inq[u] = 0; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (d[u] + w &gt; d[v]) &#123; d[v] = d[u] + w; if (inq[v] == 0) &#123; inq[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= K; ++i) &#123; int X, A, B; scanf("%d%d%d", &amp;X, &amp;A, &amp;B); switch (X) &#123; case 1: AddEdge(A, B, 0); AddEdge(B, A, 0); break; case 2: if (A == B) die AddEdge(A, B, 1); break; case 3: AddEdge(B, A, 0); break; case 4: if (A == B) die AddEdge(B, A, 1); break; case 5: AddEdge(A, B, 0); break; &#125; &#125; for (register int i = 1; i &lt;= N; ++i) AddEdge(N + 1, i, 1); SPFA(); ll ans = 0; for (register int i = 1; i &lt;= N; ++i) ans += d[i]; printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>å·®åˆ†çº¦æŸç³»ç»Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p4175ç½‘ç»œç®¡ç†]]></title>
    <url>%2F2019%2F07%2F21%2Fsolution-luogu-p4175%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€æ£µ$n$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œè¿›è¡Œ$q$æ¬¡æ“ä½œï¼šå•ç‚¹ä¿®æ”¹ï¼Œæˆ–æŸ¥è¯¢ä¸€æ¡æ ‘é“¾ä¸Šçš„ç¬¬$k$å°å€¼ã€‚ $n,q \le 80000,0 \le k \le n$ æ„Ÿè°¢@oyçš„è´¡çŒ® æ€è·¯ï¼šæ ‘é“¾å‰–åˆ†+æ ‘çŠ¶æ•°ç»„å¥—ä¸»å¸­æ ‘ è€ƒè™‘åˆ°æƒå€¼çº¿æ®µæ ‘è‡ªå¸¦buffâ€”â€”æ•´ä½“äºŒåˆ†ï¼Œä¸éš¾æƒ³åˆ°å¯¹æ ‘é“¾ä¸Šçš„æƒå€¼çº¿æ®µæ ‘æ±‚å’Œï¼Œå¹¶åœ¨åˆå¹¶åçš„æƒå€¼çº¿æ®µæ ‘ä¸Šæ±‚ç¬¬ $k$ å¤§å³å¯æ„‰å¿«åœ°è§£å†³æœ¬é¢˜ã€‚ åœ¨æ ‘é“¾ä¸Šçš„æ±‚å’Œæ“ä½œå¯ä»¥ç”¨æ ‘å‰–åŠ çº¿æ€§æ•°æ®ç»“æ„è¿›è¡Œç»´æŠ¤ã€‚æœ¬é¢˜éœ€è¦æ”¯æŒçš„æ“ä½œåªæœ‰å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„å¥—ä¸»å¸­æ ‘ç»´æŠ¤ dfs åºä¸Šçš„ä¿¡æ¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lson(x) (node[x].l)#define rson(x) (node[x].r)#define sum(x) (node[x].sum)#define lowbit(x) (x &amp; (-x))const int MAXN = 80005 * 2;vector&lt;int&gt; G[MAXN];struct opt &#123;int k, a, b;&#125; op[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125; node[MAXN * 80];int c[MAXN], cnt;int N, Q, L;int t[MAXN], b[MAXN];int q1[MAXN], q2[MAXN], len1, len2;int dep[MAXN], dfn[MAXN], f[MAXN], son[MAXN], top[MAXN], size[MAXN], dfn_idx;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; sum(u) += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(lson(u), l, mid, p, val); else insert(rson(u), mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void dfs1(int u, int fa) &#123; dep[u] = dep[fa] + 1; f[u] = fa; size[u] = 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); if (size[v] &gt; size[son[u]]) son[u] = v; size[u] += size[v]; &#125;&#125;void dfs2(int u, int topc) &#123; dfn[u] = ++dfn_idx; top[u] = topc; modify(dfn[u], t[u], 1); if (son[u]) dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == son[u] || v == f[u]) continue; dfs2(v, v); &#125;&#125;void pre_bin(int u, int* a, int&amp; len) &#123; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int pre(int u, int v) &#123; len1 = len2 = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[top[u]] - 1, q2, len2); u = f[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); pre_bin(dfn[u], q1, len1); pre_bin(dfn[v] - 1, q2, len2); return v;&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, rsum = 0; for (int i = 1; i &lt;= len1; ++i) rsum += sum(rson(q1[i])); for (int i = 1; i &lt;= len2; ++i) rsum -= sum(rson(q2[i])); if (k &lt;= rsum) &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = rson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = rson(q2[i]); return query(mid + 1, r, k); &#125; else &#123; for (int i = 1; i &lt;= len1; ++i) q1[i] = lson(q1[i]); for (int i = 1; i &lt;= len2; ++i) q2[i] = lson(q2[i]); return query(l, mid, k - rsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;Q); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;t[i]), b[++L] = t[i], c[i] = ++cnt; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; for (register int i = 1; i &lt;= Q; ++i) &#123; scanf("%d%d%d", &amp;op[i].k, &amp;op[i].a, &amp;op[i].b); if (op[i].k == 0) b[++L] = op[i].b; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) t[i] = id(t[i]); dfs1(1, 0); dfs2(1, 1); for (register int i = 1; i &lt;= Q; ++i) &#123; int k = op[i].k, a = op[i].a, b_ = op[i].b; if (k == 0) &#123; b_ = id(b_); modify(dfn[a], t[a], -1); t[a] = b_; modify(dfn[a], t[a], 1); &#125; else &#123; int lca = pre(a, b_); int maxk = dep[a] + dep[b_] - dep[lca] * 2 + 1; if (maxk &lt; k) &#123; puts("invalid request!"); continue; &#125; printf("%d\n", rid(query(1, L, k))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ä¸»å¸­æ ‘</tag>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
        <tag>æ ‘çŠ¶æ•°ç»„</tag>
        <tag>æ ‘å¥—æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -æ ‘å¥—æ ‘]]></title>
    <url>%2F2019%2F07%2F21%2Falgorithm-treeintree%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡éƒ¨åˆ†å†…å®¹è½¬è½½è‡ª OI Wiki æ ‘çŠ¶æ•°ç»„å¥—ä¸»å¸­æ ‘ æ¦‚è¿°æ™®é€šæ•°æ®ç»“æ„ç»´æŠ¤å•ä¸€ç»´åº¦ä¿¡æ¯ï¼Œæ ‘å¥—æ ‘ç»´æŠ¤å¤šç»´åº¦ä¿¡æ¯ã€‚ æ ‘çŠ¶æ•°ç»„å¥—æƒå€¼çº¿æ®µæ ‘æ ‘çŠ¶æ•°ç»„å¥—æƒå€¼çº¿æ®µæ ‘å¯ä»¥åœ¨ $O(n \log^2 n)$ çš„æ—¶é—´å¤æ‚åº¦è§£å†³åŠ¨æ€åŒºé—´ $k$ å°å€¼é—®é¢˜ã€‚ å¦‚æœç”¨çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ä¸­æ‰€è®ºè¿°çš„ï¼Œç”¨çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ï¼Œå³å¯¹äºçº¿æ®µæ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¯¹äºå…¶æ‰€è¡¨ç¤ºçš„åŒºé—´ç»´æŠ¤ä¸€ä¸ªå¹³è¡¡æ ‘ï¼Œç„¶åç”¨äºŒåˆ†æ¥æŸ¥æ‰¾ $k$ å°å€¼ã€‚ç”±äºæ¯æ¬¡æŸ¥è¯¢æ“ä½œéƒ½è¦è¦†ç›–å¤šä¸ªåŒºé—´ï¼Œå³æœ‰å¤šä¸ªèŠ‚ç‚¹ï¼Œä½†æ˜¯å¹³è¡¡æ ‘å¹¶ä¸èƒ½å¤šä¸ªå€¼ä¸€èµ·æŸ¥æ‰¾ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n\log^3 n)$ï¼Œå¹¶ä¸æ˜¯æœ€ä¼˜çš„ã€‚ æ€è·¯æ˜¯ï¼ŒæŠŠäºŒåˆ†ç­”æ¡ˆçš„æ“ä½œå’ŒæŸ¥è¯¢å°äºä¸€ä¸ªå€¼çš„æ•°çš„æ•°é‡ä¸¤ç§æ“ä½œç»“åˆèµ·æ¥ã€‚æœ€å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨ çº¿æ®µæ ‘å¥—ä¸»å¸­æ ‘ ã€‚ è¯´æ˜¯ä¸»å¸­æ ‘å…¶å®ä¸å‡†ç¡®ï¼Œå› ä¸ºå¹¶ä¸æ˜¯å¯¹çº¿æ®µæ ‘çš„å¯æŒä¹…åŒ–ï¼Œå„ä¸ªçº¿æ®µæ ‘ä¹‹é—´ä¹Ÿæ²¡æœ‰åƒä¸»å¸­æ ‘å„ç‰ˆæœ¬ä¹‹é—´çš„å¼ºå…³è”æ€§ï¼Œæ‰€ä»¥ç§°ä¸º åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘ æ›´ä¸ºç¡®åˆ‡ã€‚ æ€è·¯ç±»ä¼¼äºçº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ï¼Œå³å¯¹äºçº¿æ®µæ ‘æ‰€ç»´æŠ¤çš„æ¯ä¸ªåŒºé—´ï¼Œå»ºç«‹ä¸€ä¸ªåŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘ï¼Œè¡¨ç¤ºå…¶æ‰€ç»´æŠ¤çš„åŒºé—´çš„å€¼ã€‚ åœ¨ä¿®æ”¹æ“ä½œè¿›è¡Œæ—¶ï¼Œå…ˆåœ¨çº¿æ®µæ ‘ä¸Šä»ä¸Šå¾€ä¸‹è·³åˆ°è¢«ä¿®æ”¹çš„ç‚¹ï¼Œåˆ é™¤æ‰€ç»è¿‡çš„ç‚¹æ‰€æŒ‡å‘çš„åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘ä¸Šçš„åŸæ¥çš„å€¼ï¼Œç„¶åæ’å…¥æ–°çš„å€¼ï¼Œè¦ç»è¿‡ $O(\log n)$ ä¸ªçº¿æ®µæ ‘ä¸Šçš„èŠ‚ç‚¹ï¼Œåœ¨åŠ¨æ€å¼€ç‚¹æƒå€¼çº¿æ®µæ ‘ä¸Šä¸€æ¬¡ä¿®æ”¹æ“ä½œæ˜¯ $O(\log n)$ çš„ï¼Œæ‰€ä»¥ä¿®æ”¹æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log^2 n)$ ã€‚ ç”±äºçº¿æ®µæ ‘çš„å¸¸æ•°è¾ƒå¤§ï¼Œåœ¨å®ç°ä¸­å¾€å¾€ä½¿ç”¨å¸¸æ•°æ›´å°ä¸”æ›´æ–¹ä¾¿å¤„ç†å‰ç¼€å’Œçš„ æ ‘çŠ¶æ•°ç»„ å®ç°ã€‚ ç»™å‡ºä¸€ç§ä»£ç å®ç°ï¼šluogu-p2617 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b + 1, b + L + 1, x) - b)#define rid(x) (b[x])#define lowbit(x) (x &amp; (-x))const int MAXN = 100005 * 2;struct op &#123; char opt; int i, j, k, t;&#125;ops[MAXN];struct Node &#123; int l, r, sum; Node() &#123;l = r = sum = 0;&#125;&#125;node[MAXN * 80];int cnt, c[MAXN];int N, M, L;int a[MAXN], b[MAXN];int qr[MAXN], ql[MAXN], qrlen, qllen;void insert(int&amp; u, int l, int r, int p, int val) &#123; if (u == 0) u = ++cnt; node[u].sum += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) insert(node[u].l, l, mid, p, val); else insert(node[u].r, mid + 1, r, p, val);&#125;void modify(int u, int p, int val) &#123; for (; u &lt;= N; u += lowbit(u)) insert(c[u], 1, L, p, val);&#125;void pre(int u, int* a, int&amp; len) &#123; len = 0; for (; u &gt;= 1; u -= lowbit(u)) a[++len] = c[u];&#125;int query(int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1, lsum = 0; for (int i = 1; i &lt;= qrlen; ++i) lsum += node[node[qr[i]].l].sum; for (int i = 1; i &lt;= qllen; ++i) lsum -= node[node[ql[i]].l].sum; if (lsum &gt;= k) &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].l; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].l; return query(l, mid, k); &#125; else &#123; for (int i = 1; i &lt;= qrlen; ++i) qr[i] = node[qr[i]].r; for (int i = 1; i &lt;= qllen; ++i) ql[i] = node[ql[i]].r; return query(mid + 1, r, k - lsum); &#125;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%d", &amp;a[i]), b[++L] = a[i], c[i] = ++cnt; &#125; for (register int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; ops[i].opt; if (ops[i].opt == 'Q') &#123; scanf("%d%d%d", &amp;ops[i].i, &amp;ops[i].j, &amp;ops[i].k); &#125; else &#123; scanf("%d%d", &amp;ops[i].i, &amp;ops[i].t); b[++L] = ops[i].t; &#125; &#125; sort(b + 1, b + L + 1); L = unique(b + 1, b + L + 1) - b - 1; for (register int i = 1; i &lt;= N; ++i) &#123; a[i] = id(a[i]); modify(i, a[i], 1); &#125; for (register int i = 1; i &lt;= M; ++i) &#123; if (ops[i].opt == 'Q') &#123; pre(ops[i].j, qr, qrlen); pre(ops[i].i - 1, ql, qllen); printf("%d\n", rid(query(1, L, ops[i].k))); &#125; else &#123; modify(ops[i].i, a[ops[i].i], -1); a[ops[i].i] = id(ops[i].t); modify(ops[i].i, a[ops[i].i], 1); &#125; &#125; return 0;&#125; æœªå®Œå¾…ç»­â€¦â€¦ç­‰æˆ‘å­¦å®Œå¹³è¡¡æ ‘å†æ¥ç€å¼„]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>ä¸»å¸­æ ‘</tag>
        <tag>çº¿æ®µæ ‘</tag>
        <tag>æ ‘çŠ¶æ•°ç»„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-cf1195c Basketball Exercise]]></title>
    <url>%2F2019%2F07%2F18%2Fsolution-luogu-cf1195c%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ª$2*n$çš„çŸ©é˜µï¼Œä»ä¸­é€‰å‡ºè‹¥å¹²æ•°ï¼Œä¸”ä»»æ„ä¸¤ä¸ªæ•°ä¸ä¸Šä¸‹æˆ–å·¦å³ç›¸é‚»ï¼Œæ±‚è¿™äº›æ•°çš„æœ€å¤§æ€»å’Œ $1\le n \le 100000,1 \le h_{i,j}\le 1000000000$ å¾ˆæ°´çš„ä¸€é“Cé¢˜â€¦â€¦ç›®æµ‹éš¾åº¦åœ¨é»„~ç»¿å·¦å³ã€‚è¯·å„ä½åˆ‡é¢˜è€…åˆç†è¯„åˆ†ã€‚ æ³¨æ„åˆ°å¯ä»¥é€‰æ‹©çš„çƒå‘˜ç¼–å·æ˜¯ä¸¥æ ¼é€’å¢çš„ï¼Œå› æ­¤å¯ä»¥æŠŠçŠ¶æ€çš„ç¬¬ä¸€ç»´å®šä¹‰ä¸ºçƒå‘˜ç¼–å·ï¼Œç¬¬äºŒç»´æè¿°ç¼–å·åŒä¸º $i$ çš„ä¸¤åçƒå‘˜çš„é€‰å–æƒ…å†µã€‚ å®šä¹‰çŠ¶æ€ï¼š$f[i][0/1/2]$ è¡¨ç¤ºé€‰å–äº†ç¼–å·åœ¨ $i$ åŠä»¥å‰çš„çƒå‘˜ï¼Œæ‰€èƒ½å¾—åˆ°çš„èº«é«˜æ€»å’Œæœ€å¤§å€¼ã€‚å…¶ä¸­ï¼Œç¬¬äºŒç»´çš„ $0$ è¡¨ç¤ºç¼–å·ä¸º $i$ çš„çƒå‘˜ä¸€ä¸ªéƒ½ä¸é€‰ï¼›$1$ è¡¨ç¤ºåªé€‰ä¸Šé¢ä¸€ä¸ªï¼›$i$ è¡¨ç¤ºåªé€‰ä¸‹é¢ä¸€ä¸ªã€‚ï¼ˆæ˜¾ç„¶æ²¡æœ‰ä¸Šä¸‹éƒ½é€‰çš„æƒ…å†µï¼‰ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š f[i][0]=max\lbrace f[i-1][0],f[i-1][1],f[i-1][2]\rbrace f[i][1]=max\lbrace f[i-1][0],f[i-1][2]\rbrace+height[i][1] f[i][2]=max\lbrace f[i-1][0],f[i-1][1]\rbrace+height[i][2]Update: ç”¨è´ªå¿ƒå¯ä»¥è¯æ˜ï¼Œåœ¨æœ€ä¼˜è§£ä¸­ï¼Œä¸ä¼šå‡ºç°è¿ç»­ä¸¤åˆ—ä¸€ä¸ªä¸å–çš„æƒ…å†µã€‚å› æ­¤ï¼Œ $f[i][0]$ å…¶å®æ²¡æœ‰å¿…è¦è€ƒè™‘æ¥è‡ª $f[i-1][0]$ çš„çŠ¶æ€è½¬ç§»ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;ll h[100005][3];ll f[100005][3];int main() &#123; cin &gt;&gt; N; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][1]; for (register int i = 1; i &lt;= N; ++i) cin &gt;&gt; h[i][2]; f[1][0] = 0; f[1][1] = h[1][1]; f[1][2] = h[1][2]; for (register int i = 2; i &lt;= N; ++i) &#123; f[i][0] = max(f[i - 1][0], max(f[i - 1][1], f[i - 1][2])); f[i][1] = max(f[i - 1][0], f[i - 1][2]) + h[i][1]; f[i][2] = max(f[i - 1][0], f[i - 1][1]) + h[i][2]; &#125; cout &lt;&lt; max(f[N][0], max(f[N][1], f[N][2])); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -æ•°è®ºä¸“é¢˜-å¡ç‰¹å…°æ•°]]></title>
    <url>%2F2019%2F07%2F14%2Falgorithm-maths-catalan%2F</url>
    <content type="text"><![CDATA[å’•å’•å’•~]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
        <category>æ•°è®ºä¸“é¢˜</category>
      </categories>
      <tags>
        <tag>å¡ç‰¹å…°æ•°</tag>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1641ç”Ÿæˆå­—ç¬¦ä¸²]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p1641%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ å°†$n$ä¸ª$1$å’Œ$m$ä¸ª$0$ç»„æˆå­—ç¬¦ä¸²ï¼Œä½¿å¾—åœ¨ä»»æ„çš„å‰$k$ä¸ªå­—ç¬¦ä¸­ï¼Œ$1$çš„ä¸ªæ•°ä¸èƒ½å°‘äº$0$çš„ä¸ªæ•°ã€‚æ±‚æ»¡è¶³æ¡ä»¶çš„å­—ç¬¦ä¸²å…±æœ‰å¤šå°‘ä¸ªã€‚ $1\le m \le n \le 1000000$ æœ¬é¢˜æ˜¯å¡ç‰¹å…°æ•°çš„ä¸€ä¸ªç®€å•å˜å¼ã€‚ å›å¿†å¡ç‰¹å…°æ•°çš„æ¨å¯¼è¿‡ç¨‹ï¼Œå¯ä»¥ç”Ÿæˆçš„æ‰€æœ‰å­—ç¬¦ä¸²å…±æœ‰$C_{n+m}^n$ä¸ªï¼Œå…¶ä¸­ä¸åˆæ³•çš„å­—ç¬¦ä¸²æœ‰$C_{n+m}^{n+1}$ä¸ªã€‚æœ€ç»ˆç­”æ¡ˆå³ä¸º$C_{n+m}^{n}-C_{n+m}^{n+1}$ã€‚è®¡ç®—ç»„åˆæ•°å‰é¡»é¢„å¤„ç†å‡ºé˜¶ä¹˜é€†å…ƒã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int p = 20100403;int N, M;int inv[2000005], fac[2000005], facinv[2000005];int C(int n, int m) &#123; return (ll) fac[n] * facinv[m] % p * facinv[n - m] % p;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; M; inv[1] = 1; fac[0] = fac[1] = 1; facinv[1] = 1; for (register int i = 2; i &lt;= N + M; ++i) &#123; inv[i] = (ll) (p - p / i) * inv[p % i] % p; fac[i] = (ll) i * fac[i - 1] % p; facinv[i] = (ll) facinv[i - 1] * inv[i] % p; &#125; cout &lt;&lt; (C(N + M, N) - C(N + M, N + 1) + p) % p; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å¡ç‰¹å…°æ•°</tag>
        <tag>æ•°å­¦</tag>
        <tag>é€†å…ƒ</tag>
        <tag>ç»„åˆæ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -æ•°è®ºä¸“é¢˜-ä¹˜æ³•é€†å…ƒ]]></title>
    <url>%2F2019%2F07%2F13%2Falgorithm-maths-multiplicativeinversion%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿° ä¹˜æ³•é€†å…ƒå®šä¹‰ï¼šå¦‚æœä¸€ä¸ªçº¿æ€§åŒä½™æ–¹ç¨‹$ax\equiv 1 \mod b$ï¼Œåˆ™$x$æˆä¸º$a \mod b$çš„é€†å…ƒï¼Œè®°ä½œ$a^{-1}$ã€‚ ä¹˜æ³•é€†å…ƒä¸€èˆ¬ç”¨äºæ±‚$a\/b\mod p$çš„å€¼ï¼ˆ$p$é€šå¸¸ä¸ºè´¨æ•°ï¼‰ï¼Œæ˜¯è§£å†³æ¨¡æ„ä¹‰ä¸‹åˆ†æ•°æ•°å€¼çš„å¿…è¦æ‰‹æ®µã€‚ å¯¹äº$a\/b\mod p$ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚å‡º$b$åœ¨$\mod p$ä¸‹çš„é€†å…ƒï¼Œç„¶åä¹˜ä¸Š$a$å†$\mod p$ï¼Œå°±æ˜¯è¿™ä¸ªåˆ†æ•°çš„å€¼äº†ã€‚ æ±‚è§£é€†å…ƒçš„æ–¹æ³•æ‰©å±•æ¬§å‡ é‡Œå¾—æ³•æ±‚è§£$ax\equiv 1 \mod b$ ç­‰ä»·äºè§£ä¸å®šæ–¹ç¨‹ $ax+by=1$ï¼Œæ±‚è§£å‡ºçš„$x$å³ä¸º$a \mod b$çš„é€†å…ƒã€‚ 12345678void exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, y, x); y -= a / b * x;&#125; å¿«é€Ÿå¹‚æ³• è´¹é©¬å°å®šç† è‹¥$p$ä¸ºè´¨æ•°ï¼Œ$a$ä¸ºæ­£æ•´æ•°ï¼Œä¸”$a$ã€$p$äº’è´¨ï¼Œåˆ™$a^{p-1}\equiv 1 (\mod p)$ã€‚ å› ä¸º$ax\equiv 1\mod b$ æ‰€ä»¥$ax\equiv a^{b-1}\mod b$ æ‰€ä»¥$x\equiv a^{b-2}\mod b$ ç„¶åå¯ä»¥ä½¿ç”¨å¿«é€Ÿå¹‚æ±‚è§£é€†å…ƒã€‚ ä»£ç ç•¥ã€‚ çº¿æ€§æ±‚é€†å…ƒå‡è®¾ç°åœ¨è¦æ±‚$inv[i]$ã€‚ è€ƒè™‘å¸¦ä½™é™¤æ³•ï¼Œè®¾$p=iq+r$ï¼Œåˆ™æœ‰$iq+r\equiv 0\mod p$ æ³¨æ„åˆ°$p$æ˜¯è´¨æ•°ï¼Œå› æ­¤$r$ä¸ä¸º$0$ï¼Œ$r$çš„é€†å…ƒå­˜åœ¨ ç­‰å¼ä¸¤è¾¹ä¹˜$i^{-1}r^{-1}$ï¼Œå¾—åˆ°$qr^{-1}+i^{-1}\equiv 0\mod p$ å› æ­¤$i^{-1}\equiv -qr^{-1}\equiv -(p\/i)(p \mod i)^{-1}\mod p$ 12for (inv[1] = 1, i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p;]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
        <category>æ•°è®ºä¸“é¢˜</category>
      </categories>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>ä¹˜æ³•é€†å…ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p5021èµ›é“ä¿®å»º]]></title>
    <url>%2F2019%2F07%2F13%2Fsolution-luogu-p5021%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ªæœ‰$n$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œåœ¨å…¶ä¸­é€‰å‡º$m$æ¡æ²¡æœ‰å…¬å…±è¾¹çš„è·¯å¾„ï¼Œå¹¶ä½¿å¾—$m$æ¡è·¯å¾„ä¸­æœ€çŸ­è·¯å¾„çš„é•¿åº¦å°½å¯èƒ½å¤§ã€‚è¾“å‡ºè¿™ä¸ªæœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚ $2\le n \le 50000,1\le m\le n-1 $ é¢˜ç›®è¦æ±‚ä½¿$m$æ¡èµ›é“ä¸­æœ€çŸ­èµ›é“çš„é•¿åº¦å°½å¯èƒ½å¤§ï¼Œä¸éš¾æƒ³åˆ°äºŒåˆ†æœ€çŸ­èµ›é“çš„é•¿åº¦$len$ï¼Œå¹¶åˆ¤å®šæ˜¯å¦èƒ½ä¿®å»ºå‡º$m$æ¡èµ›é“ã€‚ å®šä¹‰$f[u]$ä¸ºè‡ªèŠ‚ç‚¹$u$å‘ä¸‹å»¶ä¼¸çš„ä¸ä½œä¸ºèµ›é“çš„æœ€é•¿é“¾é•¿åº¦ã€‚å‡è®¾å·²çŸ¥æ‰€æœ‰çš„$f[v]+w(u,v) (v\in son(u))$ï¼ˆå³è‡ªèŠ‚ç‚¹$u$å‘ä¸‹å»¶ä¼¸çš„æ‰€æœ‰é“¾çš„é•¿åº¦ï¼‰ï¼Œåˆ™æˆ‘ä»¬åº”åœ¨ä¿è¯è¿™äº›é“¾èƒ½ç»„æˆæœ€å¤šèµ›é“çš„å‰æä¸‹ï¼Œä½¿ä¿ç•™ä¸‹æ¥çš„$f[v]+w(u,v)$æœ€å¤§ã€‚ è€ƒè™‘è´ªå¿ƒã€‚å¯¹äº$f[v]+w(u,v)\ge len$çš„æƒ…å†µï¼Œå¯ä»¥ç›´æ¥å°†å…¶ä½œä¸ºä¸€æ¡èµ›é“ã€‚è€Œå‰©ä½™çš„é“¾ï¼Œåªèƒ½å°†å®ƒä»¬ä¸¤ä¸¤æ‹¼æ¥æˆèµ›é“ã€‚ç”±äºéœ€è¦ä½¿ä¿ç•™ä¸‹æ¥çš„$f[v]+w(u,v)$å–æœ€å¤§å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¼˜å…ˆä½¿è¾ƒçŸ­çš„é“¾å¾—åˆ°åŒ¹é…ï¼Œåœ¨å‰©ä½™çš„æ— æ³•åŒ¹é…çš„é“¾ä¸­å–æœ€å€¼ä½œä¸ºæ–°çš„$f[u]$ã€‚ è´ªå¿ƒæ“ä½œå¯ä»¥ç”¨$multiset$å®ç°ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50005;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G[MAXN];int N, M, L, cnt;int f[MAXN];inline bool cmp(int a, int b) &#123;return a &gt; b;&#125;inline void dfs(int u, int fa) &#123; multiset&lt;int&gt; s; for (vector&lt;Edge&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = it -&gt; v, w = it -&gt; w; if (v == fa) continue; dfs(v, u); if (f[v] + w &gt;= L) cnt++; else s.insert(f[v] + w); &#125; while (!s.empty()) &#123; multiset&lt;int&gt;::iterator it = s.begin(); s.erase(it); multiset&lt;int&gt;::iterator it1 = s.lower_bound(L - *it); if (it1 == s.end()) f[u] = max(f[u], *it); else &#123; cnt++; s.erase(it1); &#125; &#125;&#125;inline bool check() &#123; memset(f, 0, sizeof(f)); cnt = 0; dfs(1, 0); if (cnt &gt;= M) return 1; return 0;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G[u].push_back((Edge)&#123;v, w&#125;); G[v].push_back((Edge)&#123;u, w&#125;); &#125; int l = 0, r = 500000000; int ans = 0; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; L = mid; if (check()) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>äºŒåˆ†ç­”æ¡ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -æ ‘é“¾å‰–åˆ†]]></title>
    <url>%2F2019%2F07%2F04%2Falgorithm-treechainsectioning%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°æ ‘é“¾å‰–åˆ†ç”¨äºå°†æ ‘åˆ†å‰²æˆè‹¥å¹²æ¡é“¾çš„å½¢å¼ï¼Œä»¥ç»´æŠ¤æ ‘ä¸Šè·¯å¾„çš„ä¿¡æ¯ã€‚ å…·ä½“æ¥è¯´ï¼Œå°†æ•´æ£µæ ‘å‰–åˆ†ä¸ºè‹¥å¹²æ¡é“¾ï¼Œä½¿å®ƒç»„åˆæˆçº¿æ€§ç»“æ„ï¼Œç„¶åç”¨å…¶ä»–çš„æ•°æ®ç»“æ„ç»´æŠ¤ä¿¡æ¯ã€‚ æ¨¡æ¿ã€å®ç°è¿‡ç¨‹ã€‘ ç¬¬ä¸€ä¸ª DFS è®°å½•æ¯ä¸ªç»“ç‚¹çš„æ·±åº¦ï¼ˆdeepï¼‰ã€å­æ ‘å¤§å°ï¼ˆsizeï¼‰ã€‚ ç¬¬äºŒä¸ª DFS è®°å½•æ¯ä¸ªç»“ç‚¹çš„é‡å­ç»“ç‚¹ï¼ˆheavy-sonï¼‰ã€é‡è¾¹ä¼˜å…ˆéå†æ—¶çš„ DFN åºã€æ‰€åœ¨é“¾çš„é“¾é¡¶ï¼ˆtopï¼Œä¸”åº”åˆå§‹åŒ–ä¸ºç»“ç‚¹æœ¬èº«ï¼‰ã€‚ é“¾ä¸Šçš„ DFN åºæ˜¯è¿ç»­çš„ï¼Œå¯ä»¥ä½¿ç”¨çº¿æ®µæ ‘ï¼Œæ ‘çŠ¶æ•°ç»„ç»´æŠ¤ã€‚ æ¯æ¬¡é€‰æ‹©æ·±åº¦è¾ƒå¤§çš„é“¾å¾€ä¸Šè·³ï¼Œç›´åˆ°ä¸¤ç‚¹åœ¨åŒä¸€æ¡é“¾ä¸Šã€‚ åœ¨ DFS æœç´¢çš„æ—¶å€™ï¼Œå­æ ‘ä¸­çš„ç»“ç‚¹çš„ DFN åºæ˜¯è¿ç»­çš„ã€‚ æ¯ä¸€ä¸ªç»“ç‚¹è®°å½• bottom è¡¨ç¤ºæ‰€åœ¨å­æ ‘è¿ç»­åŒºé—´æœ«ç«¯çš„ç»“ç‚¹ã€‚ è¿™æ ·å°±æŠŠå­æ ‘ä¿¡æ¯è½¬åŒ–ä¸ºè¿ç»­çš„ä¸€æ®µåŒºé—´ä¿¡æ¯ã€‚ ã€ä»£ç ã€‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100005;vector&lt;int&gt; G[MAXN];int N, M, R, P;int w[MAXN], fa[MAXN], size[MAXN], son[MAXN], top[MAXN], dep[MAXN];int dfn[MAXN], dfn_index;struct Node &#123; int l, r, sum, tag;&#125;node[MAXN * 2];int cnt;int a[MAXN];inline void build(Node&amp; u, int l, int r) &#123; u.tag = 0; if (l == r) &#123; u.sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r); u.sum = (node[u.l].sum + node[u.r].sum);&#125;inline void pushdown(Node&amp; u, int l, int r) &#123; if (u.tag) &#123; int mid = (l + r) &gt;&gt; 1; node[u.l].sum = (node[u.l].sum + u.tag * (mid - l + 1)); node[u.r].sum = (node[u.r].sum + u.tag * (r - mid)); node[u.l].tag = (node[u.l].tag + u.tag); node[u.r].tag = (node[u.r].tag + u.tag); u.tag = 0; &#125;&#125;inline void modify(Node&amp; u, int l, int r, int ql, int qr, int val) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; u.tag = (u.tag + val) % P; u.sum = (u.sum + val * (r - l + 1)) % P; return; &#125; pushdown(u, l, r); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) modify(node[u.l], l, mid, ql, qr, val); if (mid &lt; qr) modify(node[u.r], mid + 1, r, ql, qr, val); u.sum = (node[u.l].sum + node[u.r].sum) % P;&#125;inline int query(Node&amp; u, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; return u.sum; &#125; int mid = (l + r) &gt;&gt; 1, ans = 0; pushdown(u, l, r); if (ql &lt;= mid) ans = (ans + query(node[u.l], l, mid, ql, qr)) % P; if (mid &lt; qr) ans = (ans + query(node[u.r], mid + 1, r, ql, qr)) % P; return ans;&#125;inline void dfs1(int u, int fath) &#123; size[u] = 1; fa[u] = fath; dep[u] = dep[fath] + 1; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fath) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; &#125;&#125;inline void dfs2(int u, int topc) &#123; top[u] = topc; dfn[u] = ++dfn_index; a[dfn[u]] = w[u]; if (son[u] == 0) return; dfs2(son[u], topc); for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;inline void ModifySubtree(int u, int val) &#123; modify(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1, val);&#125;inline int QuerySubtree(int u) &#123; return query(node[0], 1, N, dfn[u], dfn[u] + size[u] - 1);&#125;inline void ModifyChain(int u, int v, int val) &#123; val %= P; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); modify(node[0], 1, N, dfn[top[u]], dfn[u], val); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); modify(node[0], 1, N, dfn[v], dfn[u], val);&#125;inline int QueryChain(int u, int v) &#123; int ans = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[top[u]], dfn[u])) % P; u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) swap(u, v); ans = (ans + query(node[0], 1, N, dfn[v], dfn[u])) % P; return ans;&#125;int main() &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;R, &amp;P); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;w[i]); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs1(R, 0); dfs2(R, R); build(node[0], 1, N); for (register int i = 1; i &lt;= M; ++i) &#123; int opt, x, y, z; scanf("%d", &amp;opt); if (opt == 1) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); ModifyChain(x, y, z); &#125; if (opt == 2) &#123; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", QueryChain(x, y)); &#125; if (opt == 3) &#123; scanf("%d%d", &amp;x, &amp;z); ModifySubtree(x, z); &#125; if (opt == 4) &#123; scanf("%d", &amp;x); printf("%d\n", QuerySubtree(x)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>çº¿æ®µæ ‘</tag>
        <tag>æ ‘é“¾å‰–åˆ†</tag>
        <tag>dfsåº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2831æ„¤æ€’çš„å°é¸Ÿ]]></title>
    <url>%2F2019%2F07%2F03%2Fsolution-luogu-p2831%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸­ç»™å®š$n$ä¸ªä½äºç¬¬ä¸€è±¡é™çš„ç‚¹ï¼Œæ±‚è‡³å°‘éœ€è¦ä»åŸç‚¹å¼•å‡ºå¤šå°‘æ¡å¼€å£å‘ä¸‹çš„æŠ›ç‰©çº¿ï¼Œä½¿å®ƒä»¬ç»è¿‡æ‰€æœ‰çš„ç‚¹ã€‚ $ 1 \le n \le 18 $ æ„Ÿè°¢@oyçš„è´¡çŒ® ä¸€é“å¹¶ä¸æ˜¯ç‰¹åˆ«éš¾çš„çŠ¶å‹dpã€‚ çŠ¶æ€å®šä¹‰ï¼š$f[s]$è¡¨ç¤ºå°†æ‰€æœ‰å‰©ä½™çš„çŒªæ¶ˆç­è‡³å°‘éœ€è¦å¤šå°‘åªå°é¸Ÿï¼Œå…¶ä¸­$s$è¡¨ç¤ºå·²ç»æ¶ˆç­çš„çŒªçš„é›†åˆã€‚ è€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œå‘å°„ä¸€ä¸ªå°é¸Ÿå¯ä»¥æ¶ˆç­å°šæœªè¢«æ¶ˆç­çš„çŒªã€‚è®°$curve[i][j]$ä¸ºä¸€ä¸ªäºŒè¿›åˆ¶é›†åˆï¼Œè¡¨ç¤ºç»è¿‡ç¬¬$i$ã€$j$å·çŒªçš„æŠ›ç‰©çº¿èƒ½æ¶ˆç­å“ªäº›çŒªã€‚ å³ï¼š f[s]=min\lbrace f[s|curve[i][j]]+1\rbraceå¯ä»¥ç”¨è®°å¿†åŒ–æœç´¢å®ç°ï¼Œæ³¨æ„ç²¾åº¦æ§åˆ¶å’Œè§¦æ‘¸çŠ¶æ€ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-7;int T;int N, M;double x[19], y[19];int curve[19][19];int f[524289];inline void equals(double&amp; a, double&amp; b, double x1, double y1, double x2, double y2) &#123; a = (y1 * x2 - x1 * y2) / (x1 * x1 * x2 - x2 * x2 * x1); b = (y1 - x1 * x1 * a) / x1;&#125;inline int dp(int s) &#123; if (f[s] != -1) return f[s]; if (s == (1 &lt;&lt; N) - 1) return f[s] = 0; f[s] = INF; for (register int i = 1; i &lt;= N; ++i) &#123; for (register int j = i; j &lt;= N; ++j) &#123; f[s] = min(f[s], dp(s | curve[i][j]) + 1); &#125; &#125; return f[s];&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; memset(curve, 0, sizeof(curve)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%lf%lf", &amp;x[i], &amp;y[i]); for (register int p1 = 1; p1 &lt;= N; ++p1) &#123; for (register int p2 = p1 + 1; p2 &lt;= N; ++p2) &#123; double a, b; equals(a, b, x[p1], y[p1], x[p2], y[p2]); if (a &gt;= 0) continue; for (register int i = 1; i &lt;= N; ++i) &#123; if (x[i] * x[i] * a + x[i] * b &gt;= y[i] - EPS &amp;&amp; x[i] * x[i] * a + x[i] * b &lt;= y[i] + EPS) &#123; curve[p1][p2] |= (1 &lt;&lt; (i - 1)); curve[p2][p1] |= (1 &lt;&lt; (i - 1)); &#125; &#125; &#125; &#125; for (register int p = 1; p &lt;= N; ++p) curve[p][p] = (1 &lt;&lt; (p - 1)); memset(f, -1, sizeof(f)); printf("%d\n", dp(0)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>çŠ¶æ€å‹ç¼©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p3959å®è—]]></title>
    <url>%2F2019%2F06%2F30%2Fsolution-luogu-p3959%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ è¾“å…¥ä¸€ä¸ªæœ‰$n$ä¸ªç‚¹$m$æ¡è¾¹çš„æœ‰æƒæ— å‘å›¾ã€‚é€‰å®šä»»æ„èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ã€‚æ„é€ ä¸€æ£µç”Ÿæˆæ ‘ï¼Œä½¿å¾—æ ‘ä¸Šæ‰€æœ‰çœŸå®è¾¹æƒçš„æ€»å’Œæœ€å°ã€‚çœŸå®è¾¹æƒçš„è®¡ç®—å…¬å¼ï¼š$w(u,v)\times L$ï¼Œå…¶ä¸­$L$ä¸ºæ ¹èŠ‚ç‚¹åˆ°$u$è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚ $1\le n \le 12,1 \le m \le 1000$ æ„Ÿè°¢@oyçš„è´¡çŒ® è¿™é“é¢˜åšäº†å¾ˆé•¿æ—¶é—´ï¼Œä»ä¸€å¼€å§‹æ¨å‡ºé”™è¯¯çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œåˆ°åŸ‹å¤´ä¼˜åŒ–æ­£ç¡®çš„çŠ¶æ€è½¬ç§»ï¼Œå‰åèŠ±äº†ä¸€ä¸ªå¤šæ˜ŸæœŸâ€¦â€¦ æœ¬é¢˜é¢˜è§£å¯ä»¥ä¿è¯æ­£ç¡®æ€§ï¼ˆå½“ç„¶æ¬¢è¿Hackï¼‰ï¼Œå´åœ¨é€Ÿåº¦ä¸Šç•¥æœ‰æ¬ ç¼ºã€‚ çŠ¶æ€å®šä¹‰ï¼š$f[s][u][d]$ $s$è¡¨ç¤ºå½“å‰å·²è”é€šçš„ç‚¹é›†ï¼Œ$u$è¡¨ç¤ºå½“å‰ç‚¹é›†ç”Ÿæˆæ ‘çš„æ ‘æ ¹ï¼Œ$d$è¡¨ç¤º$u$åˆ°èµ·ç‚¹çš„è·ç¦»ã€‚ï¼ˆæ³¨æ„ï¼š$u$ä¸æ˜¯èµ·ç‚¹ï¼‰ çŠ¶æ€è½¬ç§»ï¼šçŠ¶æ€è‚¯å®šæ˜¯é€šè¿‡æŒ–é€šé“æ¥è½¬ç§»çš„ã€‚å¦‚æœå°†$u$å’Œ$v$ä¹‹é—´æŒ–é€šï¼Œåˆ™$u$æ‰€åœ¨çš„è¿é€šå—å’Œ$v$æ‰€åœ¨çš„è¿é€šå—å°†ä¼šåˆå¹¶ã€‚å¦‚æœä»¥$u$ä½œä¸ºæ ¹ï¼Œ$u$åˆ°èµ·ç‚¹çš„è·ç¦»ä¸º$d$ï¼Œåˆ™$v$åˆ°èµ·ç‚¹çš„è·ç¦»ä¸º$(d+1)$ã€‚æ–¹ç¨‹å¦‚ä¸‹ï¼š f[s][u][d]=min\lbrace f[s1][u][d]+f[s2][v][d+1]+w(u,v)*d\rbraceå…¶ä¸­ï¼š s1 \cup s2=s,u\in s1,v\in s2,w(u,v)\not= \infæœ€ç»ˆè¦æ±‚çš„ç­”æ¡ˆå³ä¸º$\min_{1\le i \le n}f[(1&lt;&lt;n)-1][i][1]$ï¼Œé‡‡ç”¨è®°å¿†åŒ–æœç´¢å®ç°ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;int N, M;int w[13][13];int f[1&lt;&lt;13][13][13];inline int dp(int s, int u, int d) &#123; if (f[s][u][d] != -1) return f[s][u][d]; if (s == (1 &lt;&lt; (u - 1))) return f[s][u][d] = 0; int&amp; ans = f[s][u][d] = INF; for (register int s1 = s; s1; s1 = (s1 - 1) &amp; s) &#123; if (!(s1 &amp; (1 &lt;&lt; (u - 1)))) continue; for (register int v = 1; v &lt;= N; ++v) &#123; if (!(s &amp; (1 &lt;&lt; (v - 1)))) continue; if (w[u][v] == INF) continue; int s2 = s ^ s1; ans = min(ans, dp(s1, u, d) + dp(s2, v, d + 1) + w[u][v] * d); &#125; &#125; return ans;&#125;int main() &#123; memset(w, 0x3f, sizeof(w)); memset(f, -1, sizeof(f)); scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, t; scanf("%d%d%d", &amp;u, &amp;v, &amp;t); w[u][v] = w[v][u] = min(w[u][v], t); &#125; int ans = INF; for (register int u = 1; u &lt;= N; ++u) &#123; ans = min(ans, dp((1 &lt;&lt; N) - 1, u, 1)); &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>çŠ¶æ€å‹ç¼©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…¬å‘Š 2019-6-20]]></title>
    <url>%2F2019%2F06%2F20%2Fbulletin-2019-6-20%2F</url>
    <content type="text"><![CDATA[æ‹›å‹Ÿå¯äº‹tth37æœ€è¿‘å‘ç°ï¼Œä»–å†™äº†å¥½å¤šå¥½å¤šé¢˜è§£å•¦ã€‚ä½†æ˜¯è¿™äº›é¢˜è§£å…¨éƒ½è¢«å±•ç¤ºåœ¨Homepageé‡Œï¼Œå¯¼è‡´Homepageä¸å¤Ÿç®€æ´ï¼Œé¢˜ç›®æ£€ç´¢ä¸å¤ªæ–¹ä¾¿ã€‚ äºæ˜¯ï¼Œtth37å†³å®šåœ¨æ¯ç¯‡é¢˜è§£æœ€å‰é¢ï¼Œå†™ä¸€æ®µé¢˜ç›®å†…å®¹çš„ä¸€å¥è¯æ€»ç»“ã€‚ä½†æ˜¯tth37æ¯”è¾ƒå¿™ï¼Œå®åœ¨ä¸æƒ³åšè¿™ä»¶äº‹ï¼Œå› æ­¤ä»–å†³å®šæ‹›å‹Ÿè·ªæ±‚å·¨ä½¬æ¥å¸®ä»–å®Œæˆè¿™é¡¹å·¥ä½œã€‚ ä¸€ä»½å®Œæ•´çš„ä¸€å¥è¯æ€»ç»“å¿…é¡»æ¸…æ¥šåœ°æ¦‚æ‹¬é¢˜é¢ï¼ˆæ‹’ç»èŠ±é‡Œèƒ¡å“¨ï¼‰ï¼Œå¹¶ä¸”ç»™å‡ºæ•°æ®èŒƒå›´ã€‚ä¸€åˆ‡å­—æ¯å¿…é¡»é‡‡ç”¨$L^AT_EX$å…¬å¼ã€‚ï¼ˆç™¾åº¦ä¸€ä¸‹ï¼Ÿï¼‰ å†™å¥½ä¸€å¥è¯æ€»ç»“åï¼Œè¯·å°†å…¶ä¸Šä¼ è‡³æ´›è°·å‰ªè´´æ¿ï¼Œå¹¶å°†å‰ªè´´æ¿é“¾æ¥å‘ç»™tth37ã€‚tth37ä¼šæ ¹æ®å…¶è´¨é‡ï¼Œé…Œæƒ…å‘é€0.01~0.66å…ƒçº¢åŒ…ä½œä¸ºæŠ¥é…¬ã€‚ å¦‚æœåœ¨åº§çš„å„ä½å¯¹æœ¬æ´»åŠ¨åå“ä¸å¤Ÿçƒ­çƒˆï¼Œtth37å¯èƒ½ä¼šå¼ºè¿«ä½ ä»¬å½“ä¸­çš„ä¸€äº›äººå®Œæˆè¿™é¡¹ä»»åŠ¡ã€‚å½“ç„¶ï¼Œæ²¡æœ‰æŠ¥é…¬ã€‚]]></content>
      <categories>
        <category>å…¬å‘Š</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p3953é€›å…¬å›­]]></title>
    <url>%2F2019%2F06%2F19%2Fsolution-luogu-p3953%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ª$n$ä¸ªç‚¹$m$æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œè®¾èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯ä¸º$d$ï¼Œæ±‚èµ·ç‚¹åˆ°ç»ˆç‚¹æ»¡è¶³æƒå€¼æ€»å’Œå°äºç­‰äº$(d+k)$çš„è·¯å¾„æ•°é‡ $1 \le p\le 10^9 $ , $1 \le n\le 10^5$ , $1 \le m\le 2 \times 10^5$ , $1 \le k\le 50$ æ„Ÿè°¢@oy çš„è´¡çŒ® ä¸€é“çœ‹ä¼¼å›¾è®ºå®åˆ™å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’è§£å†³çš„é¢˜ç›®ã€‚ æœ´ç´ çš„çŠ¶æ€å®šä¹‰ï¼š$f[u][k]$è¡¨ç¤ºä»$1$å·èŠ‚ç‚¹èµ°åˆ°$u$å·èŠ‚ç‚¹ï¼Œè·¯å¾„é•¿åº¦ä¸º$k$çš„æ–¹æ¡ˆæ€»æ•°ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š f[u][k]=\sum_{(u,v)\in E}f[v][k-w(u,v)]ä½†æ˜¯è¿™æ ·çš„çŠ¶æ€å®šä¹‰æœ‰ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ï¼šç©ºé—´æ¶ˆè€—è¿‡å¤§ã€‚è€ƒè™‘åˆ°é¢˜ç›®ä¸­ç»™å‡ºçš„$K$å€¼å¹¶ä¸å¤§ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨é¢˜ç›®æ‰€è¦æ±‚çš„ä¿¡æ¯æ¥ä¼˜åŒ–çŠ¶æ€è®¾è®¡ã€‚ ä¼˜åŒ–åçš„çŠ¶æ€å®šä¹‰ï¼š$d[u]$è¡¨ç¤ºä»$1$å·èŠ‚ç‚¹èµ°åˆ°$u$å·èŠ‚ç‚¹çš„æœ€çŸ­è·¯é•¿åº¦ï¼Œ$f[u][k]$è¡¨ç¤ºä»$1$å·èŠ‚ç‚¹èµ°åˆ°$u$å·èŠ‚ç‚¹ï¼Œè·¯å¾„é•¿åº¦ä¸º$d[u]+k$çš„æ–¹æ¡ˆæ€»æ•°ã€‚ å¦‚æ­¤ä¸€æ¥ï¼ŒçŠ¶æ€æ‰€éœ€çš„ç©ºé—´å¤§å¤§å‡å°‘ï¼Œä½†ç›¸åº”çš„çŠ¶æ€è½¬ç§»ç•¥æ˜¾å¤æ‚ã€‚ä¸å¦¨è®¾$f[u][k]$çŠ¶æ€å¯ä»¥ç”±$f[v][x]$è½¬ç§»å¾—åˆ°ï¼Œåˆ™ï¼š d[v]+x+w(u,v)=d[u]+kç§»é¡¹ï¼Œå¾—åˆ°ï¼š x=d[u]-d[v]+k-w(u,v)å› æ­¤ï¼Œå®Œæ•´çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š f[u][k]=\sum_{(u,v)\in E}f[v][d[u]-d[v]+k-w(u,v)]æˆ‘ä»¬æœ€ç»ˆè¦æ±‚çš„ç­”æ¡ˆå³ä¸º$\sum_{i=0}^Kf[N][i]$ï¼Œç”¨è®°å¿†åŒ–æœç´¢å®ç°å³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100001;struct Edge &#123;int v, w;&#125;;vector&lt;Edge&gt; G1[MAXN], G2[MAXN];int T, N, M, K, P;bool fail;int f[MAXN][51];int d[MAXN];bool vis[MAXN];bool ins[MAXN][51];void Dijkstra() &#123; memset(vis, 0, sizeof(vis)); memset(d, 0x3f, sizeof(d)); priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(0, 1)); d[1] = 0; while (q.size()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (vector&lt;Edge&gt;::iterator it = G1[u].begin(); it != G1[u].end(); it++) &#123; int v = it-&gt;v, w = it-&gt;w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; q.push(make_pair(-d[v], v)); &#125; &#125; &#125;&#125;inline int dp(int u, int k) &#123; if (k &lt; 0) return 0; if (ins[u][k])&#123; fail = 1; return 0; &#125; if (f[u][k]) return f[u][k]; ins[u][k] = 1; int ans = 0; for (vector&lt;Edge&gt;::iterator it = G2[u].begin(); it != G2[u].end(); it++) &#123; int p = it-&gt;v, w = it-&gt;w; ans = (ans + dp(p, d[u] - d[p] + k - w))%P; if (fail == 1) return 0; &#125; ins[u][k] = 0; return f[u][k] = ans;&#125;int main() &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;K, &amp;P); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); G1[u].push_back((Edge)&#123;v, w&#125;); G2[v].push_back((Edge)&#123;u, w&#125;); &#125; Dijkstra(); dp(1, 0); f[1][0] = 1; int ans = 0; for (register int i = 0; i &lt;= K; ++i) &#123; ans = (ans + dp(N, i))%P; &#125; if(fail == 1) puts("-1"); else printf("%d\n", ans); fail = 0; memset(f, 0, sizeof(f)); memset(ins, 0, sizeof(ins)); for (register int i = 1; i &lt;= N; ++i) &#123; G1[i].clear(), G2[i].clear(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2627ä¿®å‰ªè‰åª]]></title>
    <url>%2F2019%2F06%2F09%2Fsolution-luogu-p2627%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ è¯»å…¥$n$ä¸ªæ•´æ•°ï¼Œé€‰å–å…¶ä¸­è‹¥å¹²ä¸ªæ•°ï¼Œæœ€å¤šè¿ç»­å–$k$ä¸ªï¼Œæ±‚å–åˆ°æ•°å­—å’Œçš„æœ€å¤§å€¼ $1\le k \le n \le 100000$ æ„Ÿè°¢@oy çš„è´¡çŒ® ä¸€é“å•è°ƒé˜Ÿåˆ—å…¥é—¨é¢˜ã€‚ é¢å¯¹åŠ¨è§„é¢˜ï¼Œé¦–å…ˆè®¾è®¡çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚ä»¤$f[i]$è¡¨ç¤º$1-i$ä¸­è¿å–ä¸è¶…è¿‡$K$ä¸ªæ•°ï¼Œä¸”ç¬¬$i$ä¸ªæ•°ä¸å–æ‰€èƒ½ç´¯åŠ çš„æœ€å¤§å’Œã€‚ å› ä¸ºç¬¬$i$ä¸ªæ•°ä¸å–ï¼Œæ‰€ä»¥åœ¨$i$ä¹‹å‰ä¸€å®šè¿å–äº†ä¸€æ®µæ•°ã€‚è¿™æ®µæ•°çš„é•¿åº¦å¯èƒ½ä¸º$0-K$ï¼ˆæ³¨æ„æ˜¯$0-K$è€Œä¸æ˜¯$1-K$ï¼Œå¯ä»¥é€šè¿‡æ‰‹æ¨æ ·ä¾‹å‘ç°æœ€ä¼˜è§£ä¸­å¯èƒ½å­˜åœ¨è¿ç€ä¸¤ä¸ªæ•°ä¸å–çš„æƒ…å†µï¼‰ã€‚è¿å–çš„ä¸€æ®µæ•°æ‰€èƒ½ç´¯åŠ çš„å’Œå¯ä»¥ç”¨å‰ç¼€å’Œè®¡ç®—ã€‚è€ƒè™‘è¾¹ç•Œæ¡ä»¶åï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š f[i]=\max_{i-K-1\le j \le i-1} \lbrace f[j]+s[i-1]-s[j] \rbraceç”±äº$max$å‡½æ•°çš„å¾ªç¯å˜é‡æ˜¯$j$ï¼Œæ‰€ä»¥åªä¸$i$ç›¸å…³çš„å˜é‡$s[i-1]$å¯ä»¥ä½œä¸ºå¸¸æ•°æå‡ºåˆ°$max$å‡½æ•°ä¹‹å¤–ï¼Œå³ï¼š f[i]=\max_{i-K-1\le j \le i-1}\lbrace f[j]-s[j]\rbrace +s[i-1]å°†çŠ¶æ€è½¬ç§»æ–¹ç¨‹åŒ–ç®€åˆ°è¿™æ ·ï¼Œå°±å·²ç»å¯ä»¥ç”¨å•è°ƒé˜Ÿåˆ—è¿›è¡Œä¼˜åŒ–äº†ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å•è°ƒé˜Ÿåˆ—ç»´æŠ¤$f[j]-s[j]$çš„æœ€å€¼ï¼Œåœ¨å¾ªç¯æ—¶å°†å…¶æœ€å¤§å€¼å–å‡ºå†åŠ ä¸Š$s[i-1]$å³ä¸º$f[i]$ã€‚ å¦‚æœæƒ³ä¸åˆ°è¯¥å¦‚ä½•æ“ä½œï¼Œä¹Ÿå¯ä»¥è¿™æ ·ç†è§£ï¼š g[i]=f[i]-s[i] f[i]=\max_{i-K-1\le j \le i-1}\lbrace g[j]\rbrace+s[i-1]ç”±äºæˆ‘ä»¬å®šä¹‰$f[i]$æ˜¯ç¬¬$i$ä¸ªæ•°ä¸å–çš„æœ€ä¼˜è§£ï¼Œå¯ä»¥å¼ºè¡Œæ±‚è§£$f[N+1]$ï¼ˆè™½ç„¶å®ƒä¼¼ä¹æ²¡æœ‰å®é™…æ„ä¹‰ï¼‰ä½œä¸ºæœ¬é¢˜çš„æœ€ç»ˆç­”æ¡ˆã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N, K;ll s[100005], f[100005];int q[100005];int main() &#123; scanf("%d%d", &amp;N, &amp;K); for (register int i = 1; i &lt;= N; ++i) &#123; scanf("%lld", &amp;s[i]); s[i] += s[i-1]; &#125; int l = 0, r = 1; q[0] = 0, f[0] = 0; for (register int i = 1; i &lt;= N + 1; ++i) &#123; while (l &lt; r &amp;&amp; q[l] &lt; i - K - 1) l++; f[i] = f[q[l]] - s[q[l]] + s[i-1]; while (l &lt; r &amp;&amp; f[q[r - 1]] - s[q[r - 1]] &lt; f[i] - s[i]) r--; q[r++] = i; &#125; printf("%lld", f[N + 1]); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>å•è°ƒé˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1600å¤©å¤©çˆ±è·‘æ­¥(Beta)]]></title>
    <url>%2F2019%2F06%2F07%2Fsolution-luogu-p1600%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ $n$ä¸ªç‚¹çš„æ ‘ä¸Šæœ‰$m$æ¡è·¯å¾„$(S_i, T_i)$ï¼Œæ¯æ¡è·¯å¾„ä¸Šå„æœ‰ä¸€ä¸ªäººä»$S_i$è·‘åˆ°$T_i$ã€‚ä»–ä»¬åœ¨ç¬¬$0$æ—¶åˆ»åŒæ—¶è·‘ï¼Œæ¯ç§’èƒ½è·‘ä¸€æ¡è¾¹ã€‚å›ç­”$n$ä¸ªè¯¢é—®ï¼Œè¯¢é—®æ°å¥½åœ¨ç¬¬$W_i$æ—¶åˆ»åˆ°è¾¾èŠ‚ç‚¹$i$çš„äººæ•°ã€‚ $1 \le n \le 300000,1 \le m \le 300000 $ æ„Ÿè°¢@tth37 çš„è´¡çŒ® å‡†å¤‡å†™ä¸€ç¯‡è¾ƒä¸ºè¯¦ç»†çš„é¢˜è§£ã€‚éƒ¨åˆ†æ€è·¯æ¥è‡ªã€Šç®—æ³•ç«èµ›è¿›é˜¶æŒ‡å—ã€‹ã€‚ æ¸¸æˆåœ°å›¾æ„æˆæ ‘å½¢ç»“æ„ï¼Œä¸ºæ–¹ä¾¿å¤„ç†ï¼Œå¯ä»¥å–$1$å·èŠ‚ç‚¹ä½œä¸ºæ ¹ï¼Œè½¬åŒ–ä¸ºæœ‰æ ¹æ ‘å¤„ç†ã€‚ å¯ä»¥å‘ç°ï¼Œä»Såˆ°Tçš„è·¯å¾„æœ‰ä¸”åªæœ‰ä¸€æ¡ï¼Œå¹¶ä¸”å¿…å°†ç»è¿‡$lca(S,T)$ã€‚ ä¸å¦¨è®¾$x$èŠ‚ç‚¹ä¸Šæœ‰ä¸€åè§‚å¯Ÿå‘˜ï¼Œå…¶è§‚å¯Ÿæ—¶é—´ä¸º$W[x]$ã€‚æˆ‘ä»¬å¯ä»¥å¯¹$x$çš„ä½ç½®è¿›è¡Œåˆ†æƒ…å†µè®¨è®ºã€‚ $x$åœ¨$S$åˆ°$lca(S,T)$çš„è·¯å¾„ä¸Šï¼ˆè¯¥è·¯å¾„åŒ…å«$lca(S,T)$ï¼‰ã€‚ ä¸ºæ–¹ä¾¿è¯´æ˜ï¼Œå‡è®¾$S=6$ï¼Œ$T=4$ã€‚é‚£ä¹ˆï¼Œæ­¤æ—¶$x$å¯èƒ½ä¸º$1$ï¼Œ$3$æˆ–$6$ã€‚å¦‚æœæ­¤è§‚å¯Ÿå‘˜å¯ä»¥è§‚å¯Ÿåˆ°å½“å‰ç©å®¶ï¼Œå½“ä¸”ä»…å½“$W[x]=d[S]-d[x]$ï¼ˆ$d$æ•°ç»„è¡¨ç¤ºèŠ‚ç‚¹æ·±åº¦ï¼‰ã€‚å¯¹ä¸Šå¼ç§»é¡¹ï¼Œå¾—åˆ°$W[x]+d[x]=d[S]$ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ç»™æ¯ä¸€ä¸ªèŠ‚ç‚¹åˆ†é…è‹¥å¹²ä¸ªæƒå€¼ï¼Œå³åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸Šå¼€ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œè®°å½•å„ä¸ªæƒå€¼ã€‚æ ¹æ®ä¸Šå¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†$S$åˆ°$lca(S,T)$çš„è·¯å¾„ä¸Šæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„$d[S]$å·æƒå€¼åŠ ä¸€ã€‚æŒ‰ç…§è¿™ç§æ–¹å¼å¤„ç†å®Œæ‰€æœ‰ç©å®¶çš„ä¿¡æ¯ä¹‹åï¼Œæˆ‘ä»¬éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸Šçš„$(W[x]+d[x])$å·æƒå€¼å³ä¸ºæ‰€æ±‚ã€‚ è¯¥æ–¹æ³•çš„æ­£ç¡®æ€§åº”è¯¥ä¸éš¾ç†è§£ã€‚$(W[x]+d[x])$å·æƒå€¼çš„æ„ä¹‰å³ä¸ºè¯¥èŠ‚ç‚¹ä¸Šæ»¡è¶³å‰æ–‡æ‰€è¿°ç­‰å¼çš„ç©å®¶ä¸ªæ•°ï¼Œè€Œæ»¡è¶³ç­‰å¼æ„å‘³ç€ç©å®¶å°†ä¼šåœ¨è§‚å¯Ÿå‘˜æ¢å¤´æ—¶ç»è¿‡è§‚å¯Ÿç‚¹ï¼Œç¬¦åˆé¢˜æ„ã€‚ ä½†æ˜¯è¿™ç§æš´åŠ›æ–¹æ³•æ˜¾ç„¶è¿˜æœ‰ä¼˜åŒ–çš„ç©ºé—´ã€‚åœ¨æœ‰æ ¹æ ‘çš„ä¸€æ¡é“¾ä¸Šè¿›è¡Œæƒå€¼æ›´æ”¹ï¼Œå¯ä»¥å°è¯•ç”¨æ ‘ä¸Šå·®åˆ†çš„çŸ¥è¯†è§£å†³ã€‚åœ¨èŠ‚ç‚¹$S$ä¸Šçš„$d[S]$å·æƒå€¼åŠ ä¸€ï¼ŒèŠ‚ç‚¹$fa[lca(S,T)]$ä¸Šçš„$d[S]$å·æƒå€¼å‡ä¸€ï¼ˆå¯ä»¥åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šå¼€ä¸€ä¸ªä¸å®šé•¿æ•°ç»„vectorè®°å½•å½“å‰èŠ‚ç‚¹ä¸Šçš„åŠ å‡æ“ä½œï¼‰ï¼Œæœ€åè¿›è¡Œç»Ÿè®¡æ—¶ï¼Œè®¡ç®—å½“å‰å­æ ‘æ‰€æœ‰$(W[x]+d[x])$å·æƒå€¼å’Œå³å¯ã€‚ä½†å³ä¾¿å¦‚æ­¤ï¼Œç­”æ¡ˆç»Ÿè®¡ä¹Ÿå¹¶ä¸å®¹æ˜“å®ç°ï¼›æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•ï¼š å»ºç«‹å…¨å±€æ•°ç»„$s$ï¼Œå…¶ä¸­$s[i]$è¡¨ç¤º$i$å·æƒå€¼ä¹‹å’Œã€‚æ·±åº¦ä¼˜å…ˆéå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œåœ¨åˆšè®¿é—®åˆ°å½“å‰èŠ‚ç‚¹æ—¶ï¼Œè®°å½•$cnt=s[W[x]+d[x]]$ã€‚éå†å½“å‰èŠ‚ç‚¹ä¸Šçš„vectorï¼Œæ‰§è¡ŒåŠ å‡æ“ä½œï¼ˆä¾‹å¦‚ï¼švectorä¸­çš„ä¸€é¡¹æ“ä½œæŠŠ$3$å·æƒå€¼å‡ä¸€ï¼Œåˆ™$s[3]=s[3]-1$ï¼‰ã€‚é€’å½’è®¿é—®å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ã€‚è®¿é—®ç»“æŸåï¼Œ$(s[W[x]+d[x]]-cnt)$å³ä¸ºæ‰€æ±‚ã€‚ ç»“åˆdfsåºçš„ç›¸å…³çŸ¥è¯†ï¼Œè®¿é—®å®Œå½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ä¹‹åï¼Œ$s$æ•°ç»„å·²ç»è®°å½•äº†ä»¥$x$ä¸ºæ ¹çš„å­æ ‘ä¸Šæ‰€æœ‰æ“ä½œã€‚å› æ­¤å°†è®¿é—®åä¸è®¿é—®å‰çš„æƒå€¼ç›¸å‡ï¼Œå³ä¸ºæ ‘ä¸Šå·®åˆ†æ‰€å¾—åˆ°çš„ç­”æ¡ˆã€‚ åˆ«å¿˜äº†æ‰åˆ†ç±»è®¨è®ºäº†ä¸€åŠå‘¢â€¦â€¦ $x$åœ¨$lca(S,T)$åˆ°$T$çš„è·¯å¾„ä¸Šï¼ˆè¯¥è·¯å¾„ä¸åŒ…å«$lca(S,T)$ï¼‰ã€‚åŒæ ·å‡è®¾$S=6$ï¼Œ$T=4$ã€‚æ­¤æ—¶$x$å¯èƒ½ä¸º$2$æˆ–$4$ã€‚å¦‚æœæ­¤è§‚å¯Ÿå‘˜å¯ä»¥è§‚å¯Ÿåˆ°å½“å‰ç©å®¶ï¼Œå½“ä¸”ä»…å½“$W[x]=(d[S]-d[lca(S,T)])+(d[x]-d[lca(S,T)])$ã€‚å¯¹ä¸Šå¼ç§»é¡¹ï¼Œå¾—åˆ°$W[x]-d[x]=d[S]-2*d[lca(S,T)]$ã€‚ ç±»ä¼¼åœ°ï¼Œæˆ‘ä»¬åªéœ€å°†æ“ä½œæ”¹ä¸ºå¯¹$(d[S]-2*d[lca(S,T)])$å·æƒå€¼çš„æ“ä½œå³å¯ã€‚ç”±äºæƒå€¼æœ‰å¯èƒ½ä¸ºè´Ÿï¼Œéœ€è¦å°†åºå·æ•´ä½“å¹³ç§»$N$ä¸ªå•ä½ï¼Œå³æ”¹ä¸ºå¯¹$(d[S]-2*d[lca(S,T)]+N)$å·æƒå€¼çš„æ“ä½œã€‚åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šå¦å¼€ä¸€ä¸ªæ“ä½œvectorï¼Œç»Ÿè®¡ç­”æ¡ˆæ—¶å¦å¼€ä¸€ä¸ª$s$æ•°ç»„ï¼Œå°†è®¡ç®—å‡ºçš„ç­”æ¡ˆä¸ç¬¬ä¸€ç§æƒ…å†µçš„ç­”æ¡ˆç›¸åŠ å³å¯ã€‚ Qï¼šä¸ºä»€ä¹ˆå¿…é¡»å¦å¼€æ“ä½œvectorå’Œ$s$æ•°ç»„ï¼Ÿ Aï¼šå›é¡¾ä¸€ä¸‹æåˆ°çš„ä¸¤ä¸ªå¼å­ï¼š$W[x]+d[x]=d[S]$ï¼Œ$W[x]-d[x]=d[S]-2*d[lca(S,T)]$å¦‚æœå°†ä¸¤è€…åˆèµ·æ¥æ“ä½œï¼Œæœ‰å¯èƒ½äº§ç”Ÿâ€œå°†$d[S]$å·æƒå€¼åŠ ä¸€ï¼Œç¢°å·§ç»Ÿè®¡ç­”æ¡ˆæ—¶$W[x]-d[x]=d[S]$â€çš„æƒ…å†µã€‚ç„¶è€Œï¼Œä¸Šè¿°ç­‰å¼æ˜¯æ²¡æœ‰ä»»ä½•æ„ä¹‰çš„ï¼š$x$å·èŠ‚ç‚¹æ ¹æœ¬æ— æ³•è§‚å¯Ÿåˆ°ç©å®¶ã€‚ä¸ºäº†é¿å…æ­¤ç±»é”™è¯¯ï¼Œå¿…é¡»å°†ä¸¤ç§æ“ä½œåˆ†å¼€å¤„ç†ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300005;struct opt &#123;int id, op;&#125;;vector&lt;int&gt; G[MAXN];vector&lt;opt&gt; opt1[MAXN], opt2[MAXN];int N, M;int W[MAXN];int f[MAXN][20], d[MAXN];void dfs1(int u, int fa) &#123; f[u][0] = fa, d[u] = d[fa] + 1; for (register int i = 1; i &lt;= 19; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs1(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (d[u] &lt; d[v]) swap(u, v); for (register int i = 19; i &gt;= 0; --i) &#123; if (d[f[u][i]] &gt;= d[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 19; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int s1[MAXN*3], s2[MAXN*3];int ans[MAXN];void dfs2(int u, int fa) &#123; int cnt1 = s1[W[u] + d[u] + N]; int cnt2 = s2[W[u] - d[u] + N]; for (vector&lt;opt&gt;::iterator it = opt1[u].begin(); it != opt1[u].end(); it++) s1[it-&gt;id] += it-&gt;op; for (vector&lt;opt&gt;::iterator it = opt2[u].begin(); it != opt2[u].end(); it++) s2[it-&gt;id] += it-&gt;op; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs2(v, u); &#125; ans[u] = s1[W[u] + d[u] + N] - cnt1 + s2[W[u] - d[u] + N] - cnt2;&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; dfs1(1, 0); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;W[i]); for (register int i = 1; i &lt;= M; ++i) &#123; int S, T; scanf("%d%d", &amp;S, &amp;T); int lca = Lca(S, T); opt1[S].push_back((opt)&#123;d[S] + N, 1&#125;); opt1[f[lca][0]].push_back((opt)&#123;d[S] + N, -1&#125;); opt2[T].push_back((opt)&#123;d[S] - 2*d[lca] + N, 1&#125;); opt2[lca].push_back((opt)&#123;d[S] - 2*d[lca] + N, -1&#125;); &#125; dfs2(1, 0); for (register int i = 1; i &lt;= N; ++i) printf("%d ", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ ‘ä¸Šå·®åˆ†</tag>
        <tag>æœ€è¿‘å…¬å…±ç¥–å…ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2633 Count on a tree(COT)]]></title>
    <url>%2F2019%2F05%2F20%2Fsolution-luogu-p2633%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ç»™å®šä¸€æ£µ$n$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸Šæœ‰ä¸€ä¸ªæƒå€¼ã€‚å¯¹äº$m$æ¬¡è¯¢é—®ï¼Œéœ€è¦è¾“å‡º$u$åˆ°$v$çš„æœ€çŸ­è·¯å¾„ä¸Šç¬¬$k$å°çš„ç‚¹æƒã€‚ $1\le n\le 100000,1 \le m\le 100000$ æ„Ÿè°¢@tth37 çš„è´¡çŒ® è¿™é¢˜ä¸éš¾å‘€ï¼Œæ€ä¹ˆè°ƒäº†è¿™ä¹ˆä¹…ï¼Ÿ â€”â€”Mr. G å‰ç½®çŸ¥è¯†æ˜¯ä¸»å¸­æ ‘ã€‚åœ¨åˆ©ç”¨ä¸»å¸­æ ‘æ±‚è§£åŒºé—´ç¬¬Kå°æ•°æ—¶å¯ä»¥å‘ç°ï¼Œä¸»å¸­æ ‘æ˜¯ä¸€ç§ç±»ä¼¼å‰ç¼€å’Œçš„æ•°æ®ç»“æ„ï¼Œå…·æœ‰å’Œå‰ç¼€å’Œç±»ä¼¼çš„åŒºé—´åŠ å‡åŠå·®åˆ†ç­‰ä¼˜ç§€æ€§è´¨ã€‚åœ¨æ±‚è§£çº¿æ€§åŒºé—´çš„ç¬¬Kå°æ•°æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†è¯¥åŒºé—´å†…çš„æ‰€æœ‰æ•°å€¼ä¿¡æ¯æ‰”åˆ°ä¸€æ£µä¸»å¸­æ ‘ä¸­ï¼Œå¹¶åœ¨è¿™æ£µä¸»å¸­æ ‘ä¸Šå·¦å³é€’å½’ï¼Œä»¥æ‰¾åˆ°ç¬¬Kå°æ•°ï¼›åŒæ ·çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç±»æ¯”æ ‘ä¸Šå‰ç¼€å’Œçš„æ“ä½œï¼Œå®šä¹‰$s[u]$ä¸ºä»æ ¹èŠ‚ç‚¹åˆ°ç¬¬$u$å·èŠ‚ç‚¹çš„â€œå‰ç¼€ä¸»å¸­æ ‘â€ï¼ˆæ„Ÿæ€§ç†è§£è°¢è°¢ï¼‰ã€‚é‚£ä¹ˆï¼ŒåŒ…å«$u$åˆ°$v$ä¸Šæ‰€æœ‰æ•°å€¼ä¿¡æ¯çš„ä¸»å¸­æ ‘å°±åº”è¯¥æ˜¯ï¼š s[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]ç†è§£ä¸Šå¼åï¼Œé—®é¢˜åŸºæœ¬å¯ä»¥è§£å†³äº†ã€‚å¦å¤–æ³¨æ„ç¦»æ•£åŒ–å’Œä¸»å¸­æ ‘çš„ä»£ç ç»†èŠ‚ã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;// ç¦»æ•£åŒ–æ“ä½œ#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN = 100005;struct Node &#123; int l, r, sum;&#125;node[10000005];int head[MAXN],cnt;vector&lt;int&gt; G[MAXN];int N, M, L, lastans;int a[MAXN], b[MAXN];int f[MAXN][19], dep[MAXN];inline void build(Node &amp;u, int l, int r) &#123; u.sum = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(node[u.l = ++cnt], l, mid); build(node[u.r = ++cnt], mid + 1, r);&#125;inline void insert(Node c, Node &amp;u, int l, int r, int p) &#123; u.sum = c.sum + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r; else insert(node[c.r], node[u.r = ++cnt], mid+1, r, p), u.l = c.l;&#125;inline void dfs(int u, int fa) &#123; insert(node[head[fa]], node[head[u] = ++cnt], 1, L, id(u)); f[u][0] = fa; dep[u] = dep[fa] + 1; for (register int i = 1; i &lt;= 18; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (vector&lt;int&gt;::iterator it = G[u].begin(); it != G[u].end(); it++) &#123; int v = *it; if (v == fa) continue; dfs(v, u); &#125;&#125;inline int Lca(int u, int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); for (register int i = 18; i &gt;= 0; --i) &#123; if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; &#125; if (u == v) return u; for (register int i = 18; i &gt;= 0; --i) &#123; if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;inline int query(Node x, Node y, Node z, Node w, int l, int r, int k) &#123; if (l == r) return l; int sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum; int mid = (l + r) &gt;&gt; 1; if(sum &gt;= k) return query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k); return query(node[x.r], node[y.r], node[z.r], node[w.r], mid+1, r, k - sum);&#125;inline int querypath(int u, int v, int k) &#123; int lca = Lca(u, v); return rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][0]]], 1, L, k));&#125;int main() &#123; scanf("%d%d", &amp;N, &amp;M); for (register int i = 1; i &lt;= N; ++i) scanf("%d", &amp;a[i]), b[i] = a[i]; for (register int i = 1; i &lt; N; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; sort(b + 1, b + N + 1); L = unique(b + 1, b + N + 1) - (b + 1); build(node[head[0] = ++cnt], 1, L); dfs(1, 0); for (register int i = 1; i &lt;= M; ++i) &#123; int u, v, k; scanf("%d%d%d", &amp;u, &amp;v, &amp;k); int nowans = querypath(u^lastans, v, k); printf("%d\n", nowans); lastans = nowans; &#125;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ä¸»å¸­æ ‘</tag>
        <tag>æ ‘ä¸Šå‰ç¼€å’Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…¬å‘Š 2019-5-18]]></title>
    <url>%2F2019%2F05%2F18%2Fbulletin-2019-5-18%2F</url>
    <content type="text"><![CDATA[Hi~ è®¿é—®æˆ‘ç½‘ç«™çš„å°å´½å­ä»¬~ æƒ³åœ¨è¯„è®ºåŒºå‘è¨€çš„åŒæ—¶ç•™ä¸‹è‡ªå·±çš„ä¸ªäººå¤´åƒå—ï¼Ÿé€Ÿæˆ³è¿™é‡Œï¼ï¼ˆGravatar.comï¼‰ åœ¨è¿™ä¸ªç½‘ç«™æ³¨å†Œç”¨æˆ·ï¼Œå¹¶åœ¨è¯„è®ºåŒºç•™è¨€æ—¶ç•™ä¸‹åœ¨Gravatarçš„è´¦å·é‚®ç®±ï¼Œå³å¯åœ¨è¯„è®ºåŒºæ˜¾ç¤ºå¤´åƒï¼ å¯ä»¥åœ¨è¿™é‡Œæµ‹è¯•ä¸€ä¸‹ ç”±äºç½‘ç«™æ˜¯å›½å®¶é¡¶çº§åŸŸåï¼ˆ*.cnï¼‰ï¼Œæ‰€ä»¥ç¼“å­˜å¯èƒ½éœ€è¦ä¸€å‘¨ï¼ˆæˆ–æ›´é•¿ï¼‰çš„æ—¶é—´æ‰èƒ½æ›´æ–°ï¼Œè¯·è€å¿ƒç­‰å¾…ï¼ è°¢è°¢èµ„ç“·ï¼]]></content>
      <categories>
        <category>å…¬å‘Š</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1273æœ‰çº¿ç”µè§†ç½‘]]></title>
    <url>%2F2019%2F04%2F25%2Fsolution-luogu-p1273%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ èƒŒåŒ…ç±»æ ‘å½¢dpã€‚æœ¬é¢˜éœ€è¦è¿ç”¨åˆ†ç»„èƒŒåŒ…æ¨¡å‹ã€‚ é¦–å…ˆå®šä¹‰çŠ¶æ€ï¼š$f[u][i]$è¡¨ç¤ºä»¥$u$ä¸ºæ ¹çš„å­æ ‘ä¸Šï¼Œé€‰æ‹©$i$ä¸ªç”¨æˆ·æ—¶çš„æœ€å¤§åˆ©æ¶¦ã€‚ç”±äºç”µè§†å…¬å¸å¯èƒ½äºæœ¬ï¼Œå› æ­¤$f$æ•°ç»„åº”èµ‹æå°åˆå€¼ã€‚ å¯ä»¥å°†é€‰æ‹©çš„ç”¨æˆ·ä¸ªæ•°çœ‹ä½œèƒŒåŒ…çš„å®¹é‡ç»´åº¦ï¼Œå°†è·å¾—çš„åˆ©æ¶¦çœ‹ä½œèƒŒåŒ…çš„ä»·å€¼ç»´åº¦ã€‚å¯ä»¥è®¾è®¡å‡ºå¦‚ä¸‹çš„çŠ¶æ€è½¬ç§»ï¼š f[u][i]=\max_{v\in son(u)}\{f[u][i-j]+f[v][j]-w\}å…¶ä¸­ï¼Œ$v$ä¸º$u$çš„å­èŠ‚ç‚¹ï¼Œ$w$ä¸ºè¿™æ¡è¾¹çš„æƒå€¼ã€‚åœ¨$u$æ¯ä¸ªå­èŠ‚ç‚¹ä¸Šæœ‰è®¸å¤šâ€œç‰©å“â€ï¼Œâ€œç‰©å“â€æ€»æ•°å³ä¸ºä»¥$v$ä¸ºæ ¹çš„å­æ ‘ä¸Šç”¨æˆ·çš„ä¸ªæ•°ï¼›æ¯ä¸ªâ€œç‰©å“â€æ‰€å…·æœ‰çš„ä»·å€¼å³ä¸ºå…¶æœ€å¤§åˆ©æ¶¦ï¼Œå³$f[v][j]$ã€‚åŒæ—¶ä¸åº”å¿½ç•¥è¾¹æƒå¯¹åˆ©æ¶¦å¸¦æ¥çš„å½±å“ã€‚ æ³¨æ„ç»†èŠ‚å¤„ç†åŠè¾¹ç•Œã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>èƒŒåŒ…</tag>
        <tag>æ ‘å½¢dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -æ•°è®ºä¸“é¢˜-ç´ æ•°çš„åˆ¤å®š]]></title>
    <url>%2F2019%2F04%2F13%2Falgorithm-maths-primecheck%2F</url>
    <content type="text"><![CDATA[ç‰ˆæƒå£°æ˜ï¼šæœ¬ç¯‡æ–‡ç« ç”±ç‰¹é‚€è®²å¸ˆèƒ¡å®¶ç¿æ’°å†™ï¼Œtth37åªè´Ÿè´£æ¬è¿ã€æ•´ç†å’Œå‘å¸ƒï¼›ç‰ˆæƒå½’èƒ¡å®¶ç¿æ‰€æœ‰ã€‚ æ¦‚è¿° ç´ æ•°å®šä¹‰ï¼šé™¤1å’Œæœ¬èº«ä»¥å¤–æ²¡æœ‰å…¶ä»–å› æ•°çš„æ•° ç´ æ•°åœ¨ä¿¡æ¯å­¦ç«èµ›ä¸­æœ‰è¾ƒå¤šçš„åº”ç”¨ï¼Œç´ æ•°åˆ¤å®šæ˜¯è§£å†³å¤æ‚æ•°è®ºé—®é¢˜çš„åŸºç¡€ã€‚æœ¬ç¯‡æ–‡ç« ä»‹ç»äº†ä¸€äº›ç´ æ•°åˆ¤å®šçš„æ–¹æ³•ã€‚ å•ä¸ªç´ æ•°åˆ¤å®šæœ´ç´ åˆ¤å®šï¼š 1234567bool prime(int n)&#123; if(n==1) return false;//ç‰¹åˆ¤1ï¼ˆä¸ä¸ºç´ æ•°ï¼‰ for(int i=2;i&lt;n;++i)&#123; if(n%i==0) return false;//é™¤1ã€nä»¥å¤–è¿˜å­˜åœ¨å› æ•°ï¼Œæ‰€ä»¥nä¸ºåˆæ•°ï¼› &#125; return trueï¼›//å¾ªç¯åæ²¡æœ‰åˆ¤å®šä¸ºåˆæ•°ï¼Œåˆ™ä¸ºç´ æ•°ã€‚&#125; æ—¶é—´å¤æ‚åº¦ï¼š$\Theta (n)$ ä¼˜åŒ–ï¼š 1234567bool prime(int n)&#123; if(n==1) return false;//ç‰¹åˆ¤1ï¼ˆä¸ä¸ºç´ æ•°ï¼‰ for(int i=2;i&lt;=sqrt(n);++i)&#123; if(n%i==0) return false; &#125; return trueï¼›&#125; æ—¶é—´å¤æ‚åº¦ï¼š$\Theta(\sqrt{n})$ è¯æ˜ï¼š â€‹ è‹¥ä¸€ä¸ªæ•°$n$ä¸ºåˆæ•°ï¼Œåˆ™å®ƒä¸€å®šæ‹¥æœ‰ä¸€ä¸ªè´¨å› æ•°$k$ã€‚å¯ä»¥çŸ¥é“ï¼Œ$n/k$ï¼ˆè®°ä¸º$s$ï¼‰ä¸º$n$çš„å› æ•°ï¼Œä¸”$s$ä¸ç­‰äº$n$ã€‚$k$å’Œ$s$äºŒè€…å¿…å®šæœ‰ä¸€ä¸ªæ•°å°äºç­‰äº$\sqrt{n}$ï¼Œå¦åˆ™$k*s$ä¸€å®šå¤§äº$n$ã€‚æ‰€ä»¥åªè¦åœ¨$\sqrt{n}$ä»¥å†…å¾ªç¯ä¸€éå³å¯ã€‚ åŸƒæ°ç´ æ•°ç­›å¦‚æœç”¨ä¸Šé¢çš„æ–¹æ³•åˆ¤å®š$1-n$ä»¥å†…æ‰€æœ‰ç´ æ•°ï¼Œä¼šå‘ç°æ—¶é—´å¤æ‚åº¦éå¸¸é«˜ã€‚é‚£ä¹ˆè¿™ä¸ªæ—¶å€™å°±è¦ç”¨ç­›æ³•äº†ã€‚å¤§è‡´æ„æ€æ˜¯ç”¨ç´ æ•°æ¥ç­›æ‰åˆæ•°ï¼Œç„¶åç”¨$f$æ•°ç»„å‚¨å­˜æ˜¯å¦æ˜¯ç´ æ•°ã€‚ 1234567f[1]=true;//ç‰¹åˆ¤è¿˜æ˜¯å¾ˆå¿…è¦çš„for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue;//iä¸ºåˆæ•°ç›´æ¥è·³è¿‡ for(int j=i+i;j&lt;=n;j+=i)&#123; f[j]=true;//iä¸ºç´ æ•°ï¼Œiçš„å€æ•°ä¸€å®šä¸ºåˆæ•° &#125;&#125; ä¼˜åŒ–ï¼š 1234567f[1]=true;for(int i=2;i&lt;=n;++i)&#123; if(f[i]) continue; for(int j=i*i;j&lt;=n;j+=i)&#123;//è¿™é‡Œåªå˜äº†ä¹˜å·ï¼Œä½†æ˜¯ä¼šå¿«å¾ˆå¤šå–” f[j]=true; &#125;&#125; åŸå› æ˜¯ï¼š$i*i$ä»¥ä¸‹çš„æ‰€æœ‰åˆæ•°éƒ½å·²ç»è¢«ç­›æ‰äº†ã€‚å…·ä½“è¯æ³•ï¼Œå¯ä»¥æ¥ç€çœ‹ä¸‹å»ï¼ˆåœ¨çº¿æ€§ç­›é‡Œæœ‰ç±»ä¼¼çš„æ€æƒ³ï¼Œæ‰€ä»¥çœ‹å®Œå¯ä»¥å°è¯•ä¸€ä¸‹è‡ªå·±è¯æ˜ï¼‰ã€‚ ç´ æ•°çº¿æ€§ç­›ä¸Šä¸€ä¸ªç­›æ³•æ—¶é—´å¤æ‚åº¦$\Theta(log log n)$éå¸¸æ¥è¿‘çº¿æ€§ã€‚ä½†æ˜¯è¦è¾¾åˆ°çº¿æ€§è¿˜å·®ä¸€ç‚¹ï¼ˆè¿™é‡Œä¸æ˜¯æ¯”èµ›è¦æ±‚æŒæ¡æ‰€ä»¥å°±å½“å…´è¶£å­¦å§ï¼‰ ä¸Šä¸€ä¸ªç­›æ³•çš„å¤§æ¦‚æƒ³æ³•ï¼Œæ˜¯æ¯ä¸€ä¸ªç´ æ•°çš„å€æ•°éƒ½ç­›æ‰ï¼Œæ‰€ä»¥æ˜¯è®©æ¯ä¸€ä¸ªåˆæ•°éƒ½è¢«å®ƒçš„è´¨å› å­ç­›ä¸€éã€‚ é‚£ä¹ˆæ¥ä¸‹æ¥çš„ç­›æ³•ï¼Œå°±æ˜¯è®©æ¯ä¸ªåˆæ•°çš„æœ€å°è´¨å› å­ç­›ä¸€éï¼ˆè¦å¼€ä¸€ä¸ªprimeæ•°ç»„å­˜æ‰€æœ‰ç´ æ•°ï¼‰ã€‚å…ˆæ”¾ä»£ç ï¼š 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll f[10005],prime[10005];int main()&#123; ll n,i,j,cnt=0; cin&gt;&gt;n; //è¿™ä¸ªåœ°æ–¹ä¸ç”¨ç‰¹åˆ¤1,å› ä¸ºæˆ‘ä»¬åˆ¤å®šæ˜¯å¦ä¸ºç´ æ•°çš„æ–¹æ³•æ˜¯f[i]æ˜¯å¦ä¸º0; for(i=2;i&lt;=n;++i) &#123; if(!f[i]) &#123; prime[++cnt]=i;//å­˜å…¥ç´ æ•°; f[i]=i; &#125; for(j=1;j&lt;=cnt;++j) &#123; if(prime[j]*i&gt;n||prime[j]&gt;f[i]) break;//åˆ¤å®šå‡ºç•Œæˆ–içš„å› å­ä¸­æœ‰æ¯”å½“å‰ç´ æ•°æ›´å°çš„ï¼ˆå³prime[j]*iå·²ç»è¢«f[i]ç­›è¿‡äº†ï¼‰; f[prime[j]*i]=prime[j];//æ ‡è®°æ‰€æœ‰æœªè¢«æ ‡è®°çš„içš„å€æ•°ï¼› &#125; &#125; cin&gt;&gt;i; cout&lt;&lt;f[i]&lt;&lt;" "; return 0; &#125; æ ¸å¿ƒå°±åœ¨äºç¥å¥‡çš„åˆ¤å®šæ–¹æ³•ï¼Œå¯ä»¥å¤šå’€åš¼å’€åš¼ æ—¶é—´å¤æ‚åº¦$\Theta(n)$æå®šï¼Œè¿˜å¯ä»¥æ‰¾åˆ°$1-n$å†…æ‰€æœ‰åˆæ•°çš„æœ€å°è´¨å› æ•°ã€‚]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
        <category>æ•°è®ºä¸“é¢˜</category>
      </categories>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>ç´ æ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p4559åˆ—é˜Ÿ]]></title>
    <url>%2F2019%2F04%2F10%2Fsolution-luogu-p4559%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ æœ¬é¢˜æ˜¯ä¸»å¸­æ ‘çš„ä¸€ä¸ªç®€å•åº”ç”¨ã€‚ é˜…è¯»é¢˜ç›®ï¼Œä¸éš¾å¾—å‡ºè´ªå¿ƒç­–ç•¥ã€‚åœ¨ç¼–å·ä½äº$[l,r]$çš„æ‰€æœ‰äººä¸­ï¼Œå…¶ä½ç½®æœ€é å‰çš„è·‘åˆ°$K$ä½ç½®ï¼Œä½ç½®ç¬¬äºŒé å‰çš„è·‘åˆ°$K+1$ä½ç½®ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå¯ä»¥ä½¿ä½“åŠ›å€¼æ€»å’Œæœ€å°ã€‚æ­£ç¡®æ€§ä¸ç»™å‡ºè¯æ˜ã€‚ï¼ˆä¸ä¼šè¯ï¼‰ å¯¹äºæ‰€æœ‰å­¦ç”Ÿçš„ä½ç½®åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸»å¸­æ ‘ï¼Œå¹¶å¯ä»¥ç”¨ä¸»å¸­æ ‘çš„åŸºæœ¬æŸ¥è¯¢æ“ä½œæå–å‡ºåŒºé—´ä¸º$[l,r]$çš„å­¦ç”Ÿä½ç½®å€¼åŸŸä¿¡æ¯ã€‚ ä¸ºäº†æ–¹ä¾¿å­¦ç”Ÿå·¦å³è·‘åŠ¨æ—¶ä½“åŠ›å€¼çš„ç»Ÿè®¡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸»å¸­æ ‘ä¸Šé¢å¤–è®°å½•ä¸¤ä¸ªæ•°å€¼ï¼š$gl$å’Œ$gr$ï¼Œåˆ†åˆ«è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å¯¹åº”çš„åŒºé—´å†…æ‰€æœ‰å­¦ç”Ÿè·‘åŠ¨è‡³å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹æ‰€æ¶ˆè€—çš„ä½“åŠ›å€¼ã€‚åœ¨å»ºæ ‘è¿‡ç¨‹ä¸­å³å¯å¯¹è¿™ä¸¤ä¸ªå˜é‡è¿›è¡Œç»Ÿè®¡ï¼Œå…¶ä¸­$gl$ç­‰äºå½“å‰èŠ‚ç‚¹$u$çš„å·¦å„¿å­ä¸Šçš„$gl$ï¼ŒåŠ ä¸Š$u$çš„å³å„¿å­ä¸Šçš„$gl$ï¼Œå†åŠ ä¸Šå³å„¿å­ä¸Šæ‰€æœ‰å­¦ç”Ÿä»å³å„¿å­çš„å·¦ç«¯ç‚¹è·‘åˆ°$u$çš„å·¦ç«¯ç‚¹æ‰€è¦æ¶ˆè€—çš„ä½“åŠ›å€¼ã€‚ï¼ˆå¯ä»¥è‡ªå·±åœ¨æ•°è½´ä¸Šæ¨¡æ‹Ÿä¸€ä¸‹ï¼‰ æ¥ä¸‹æ¥è®¾è®¡æŸ¥è¯¢å‡½æ•°ã€‚å‚æ•°åŒ…æ‹¬å€¼åŸŸçš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹$l$å’Œ$r$ï¼Œä»¥åŠç›®æ ‡ä½ç½®åŒºé—´çš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹$ql$å’Œ$qr$ã€‚æ˜¾ç„¶å¯¹äºä»¥ä¸‹æƒ…å†µï¼Œå‡½æ•°å¯ä»¥ç›´æ¥é€šè¿‡è®¡ç®—å¾—å‡ºç­”æ¡ˆï¼š $r\le ql$ æ­¤æ—¶å¤„äºå½“å‰å€¼åŸŸå†…çš„æ‰€æœ‰å­¦ç”Ÿéƒ½è¦å¾€å³è·‘ $qr\le l$ æ­¤æ—¶å¤„äºå½“å‰å€¼åŸŸå†…çš„æ‰€æœ‰å­¦ç”Ÿéƒ½è¦å¾€å·¦è·‘ å½“å‰å€¼åŸŸå†…æ²¡æœ‰å­¦ç”Ÿ è¿”å› $0$ å¦åˆ™ï¼Œå¿…é¡»å°†å€¼åŸŸæ‹†åˆ†ï¼Œé€’å½’åˆ°å·¦å³å­èŠ‚ç‚¹è¿›è¡Œç»Ÿè®¡ã€‚ æœ¬é¢˜æœ€ç»•çš„åœ°æ–¹åœ¨äºå­¦ç”Ÿç¼–å·å’Œå­¦ç”Ÿä½ç½®æ˜¯ä¸¤ä¸ªä¸åŒçš„ä¸œè¥¿ï¼Œåœ¨è®¾è®¡æŸ¥è¯¢å‡½æ•°æ—¶å¿…é¡»åŒºåˆ†å€¼åŸŸå’Œç¼–å·çš„æ¦‚å¿µã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int L=1000005;int N,M;struct Node&#123; int l,r; ll gl,gr,sum;&#125;node[L*22+5];int head[MAXN];int cnt;inline void build(Node&amp; u,int l,int r)&#123; u.sum=u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1;u.gl=u.gr=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l; u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+1); u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);&#125;inline ll query(Node x,Node y,int l,int r,ll ql,ll qr)&#123; ll sum=y.sum-x.sum; ll gl=y.gl-x.gl,gr=y.gr-x.gr; if(sum==0) return 0; if(qr&lt;=l) return gl+(2*l-ql-qr)*(qr-ql+1)/2; if(ql&gt;=r) return gr+(ql+qr-2*r)*(qr-ql+1)/2; int mid=(l+r)&gt;&gt;1; ll lsum=node[y.l].sum-node[x.l].sum; return query(node[x.l],node[y.l],l,mid,ql,ql+lsum-1)+ query(node[x.r],node[y.r],mid+1,r,ql+lsum,qr);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); build(node[0],1,L); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); insert(node[head[i-1]],node[head[i]=++cnt],1,L,a); &#125; for(register int i=1;i&lt;=M;++i)&#123; ll l,r,k; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;k); printf("%lld\n",query(node[head[l-1]],node[head[r]],1,L,k,k+r-l)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>ä¸»å¸­æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p5283å¼‚æˆ–ç²½å­]]></title>
    <url>%2F2019%2F04%2F09%2Fsolution-luogu-p5283%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ åˆ†æé¢˜æ„ï¼Œå³æ‰¾å‡º$n$ä¸ªæ•°ä¸­äº’ä¸ç›¸åŒä¸”å¼‚æˆ–å’Œæœ€å¤§çš„å‰$k$æ®µåŒºé—´ã€‚ ç”¨å¼‚æˆ–å‰ç¼€å’Œ$s[i]$è¡¨ç¤º$a[1]\oplus a[2]\oplus â€¦ \oplus a[i]$ã€‚æ ¹æ®å¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼ŒåŒºé—´$[l,r]$çš„å¼‚æˆ–å’Œå³ä¸º$s[r] \oplus s[l-1]$ã€‚ å°†$s[1]$åˆ°$s[n]$ä¾æ¬¡æ’å…¥$01trie$æ ‘ä¸­ï¼Œæ¯æ¬¡æ‰¾å‡ºå¯¹äºå›ºå®šçš„å³ç«¯ç‚¹$r$ï¼Œä¸$s[r]$å¼‚æˆ–å€¼æœ€å¤§çš„$s[l]$ã€‚æ˜¾ç„¶ï¼Œæ­¤æ¬¡æ“ä½œæ‰¾åˆ°çš„æ˜¯å›ºå®šå³ç«¯ç‚¹ä¸º$r$æ—¶çš„æœ€å¤§åŒºé—´å¼‚æˆ–å’Œã€‚ å°†æ¯ä¸ªä¸åŒçš„$r$å€¼æ‰€å¯¹åº”çš„æœ€å¤§åŒºé—´å¼‚æˆ–å’Œæ’å…¥å †ä¸­ï¼Œæ˜¾ç„¶å †é¡¶çš„å…ƒç´ å³ä¸º$n$ä¸ªæ•°ä¸­ä»»æ„åŒºé—´çš„æœ€å¤§å¼‚æˆ–å’Œã€‚å–å‡ºå †é¡¶å…ƒç´ ï¼Œå¹¶åŒæ—¶å¾—åˆ°è¿™æ˜¯ä»¥$r$ä¸ºå³ç«¯ç‚¹çš„ç¬¬$1$å¤§åŒºé—´å¼‚æˆ–å’Œã€‚å‘å †ä¸­æ’å…¥ä»¥$r$ä¸ºå³ç«¯ç‚¹çš„ç¬¬$2$å¤§åŒºé—´å¼‚æˆ–å’Œã€‚ åœ¨æŸ¥è¯¢ä»¥$r$ä¸ºå³ç«¯ç‚¹çš„ç¬¬$k$å¤§åŒºé—´å¼‚æˆ–å’Œæ—¶ï¼Œåªéœ€ç¨å¾®æ›´æ”¹åœ¨$01trie$æ ‘ä¸ŠæŸ¥æ‰¾çš„æ–¹å¼å³å¯ï¼Œä¸ä¸»å¸­æ ‘æŸ¥è¯¢åŒºé—´ç¬¬$k$å°æ•°çš„æ€æƒ³ç±»ä¼¼ã€‚ç”±äºéœ€è¦è®¿é—®$01trie$æ ‘çš„å†å²çŠ¶æ€ï¼Œå› æ­¤$01trie$éœ€è¦å¯æŒä¹…åŒ–ã€‚ æ³¨æ„ï¼šä»¥$r$ä¸ºå³ç«¯ç‚¹çš„åŒºé—´å¼‚æˆ–å’Œä¸€å…±åªæœ‰$r$ä¸ªï¼Œå› æ­¤æŸ¥è¯¢ä»¥$r$ä¸ºå³ç«¯ç‚¹çš„ç¬¬$r+1$å¤§åŒºé—´å¼‚æˆ–å’Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚ å¦å¤–ï¼Œåœ¨å°†(1&lt;&lt;d)è¿™æ ·çš„å¼å­è½¬long longæ—¶ï¼Œä¸èƒ½å†™æˆ(long long)(1&lt;&lt;d)ï¼Œè€Œæ˜¯((long long)1&lt;&lt;d)ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=500005;const int DEP=31;int N,M;ll ans,s[MAXN];struct State&#123; ll val; int r,k; bool operator &lt;(const State&amp; rhs) const &#123;return val&lt;rhs.val;&#125;&#125;;priority_queue&lt;State&gt; q;struct Node&#123; int son[2],sum;&#125;trie[MAXN*(DEP+2)];int head[MAXN],cnt;inline void insert(Node c,Node&amp; u,ll val,int d)&#123; u.sum=c.sum+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; u.son[!x]=c.son[!x]; insert(trie[c.son[x]],trie[u.son[x]=++cnt],val,d-1);&#125;inline ll query(Node u,ll val,int d,int k)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; int lsum=trie[u.son[!x]].sum; if(lsum&gt;=k) return ((ll)1&lt;&lt;d)+(ll)query(trie[u.son[!x]],val,d-1,k); return (ll)query(trie[u.son[x]],val,d-1,k-lsum);&#125;int main()&#123; trie[0].son[0]=trie[0].son[1]=trie[0].sum=0; insert(trie[0],trie[head[0]=++cnt],0,DEP); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; ll a; scanf("%lld",&amp;a); s[i]=s[i-1]^a; insert(trie[head[i-1]],trie[head[i]=++cnt],s[i],DEP); q.push((State)&#123;query(trie[head[i-1]],s[i],DEP,1),i,1&#125;); &#125; for(register int i=1;i&lt;=M;++i)&#123; ans+=q.top().val; int r=q.top().r,k=q.top().k; q.pop(); if(k==r) continue; q.push((State)&#123;query(trie[head[r-1]],s[r],DEP,k+1),r,k+1&#125;); &#125; printf("%lld",ans); return 0;&#125; $p.s.$æ´›è°·è¯„æµ‹æœºæœ‰ç‚¹å°æ…¢ï¼Œä¸å¼€O2ä¼šå°æ¦‚ç‡å‘ç”ŸTLE QwQ]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>å¯æŒä¹…åŒ–trie</tag>
        <tag>å¼‚æˆ–</tag>
        <tag>äºŒå‰å †</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…¬å‘Š 2019-04-08]]></title>
    <url>%2F2019%2F04%2F08%2Fbulletin-2019-4-8%2F</url>
    <content type="text"><![CDATA[tth37 Blogå·²ç»ç»‘å®šäº†æœ€æ–°åŸŸåï¼štth37.cn ï¼(è´­ä¹°è‡ªé˜¿é‡Œäº‘) ç”±äºä¸€äº›å¥‡æ€ªçš„åŸå› ï¼ˆDNSåŸŸåè§£æå’ŒCNAMEé…ç½®é—®é¢˜ï¼‰ï¼Œæˆ‘çš„åšå®¢åœ¨å››æœˆä¸ƒæ—¥è‡³å››æœˆå…«æ—¥å‡ºç°è®¸å¤šå¼‚å¸¸ï¼Œç°å·²å…¨éƒ¨ä¿®å¤ã€‚ ä½†åœ¨å››æœˆä¹æ—¥è‡³å››æœˆåæ—¥çš„æµ‹è¯•ä¸­ï¼Œæˆ‘è¢«ç–¯ç‹‚æ‰“è„¸ï¼›ç°åœ¨å·²ç»å¯ä»¥ä¿è¯ï¼Œåªè¦åœ¨æµè§ˆå™¨è¾“å…¥æ è¾“å…¥ tth37.cnï¼Œå³å¯è‡ªåŠ¨è·³è½¬https://tth37.cnï¼Œå¹¶åœ¨*CloudFlare*è¯ä¹¦æˆæƒä¸‹å®‰å…¨è¿è¡Œã€‚ è¯·å¤§ä½¬ä»¬åœ¨æ–°åŸŸåä¸‹ä½“éªŒé«˜é€ŸåŠ è½½å’Œæµç•…è®¿é—®æ–°ä½“éªŒå§ï¼ å¦å¤–ï¼Œå·¦ä¾§è¾¹æ â€œæ—¥ç¨‹è¡¨â€å·²ç»å¯ç”¨ï¼›ç½‘ç«™åŸºæœ¬æ­å»ºå®Œæ¯•ã€‚ä»¥åå°†ç¼©å‡ç½‘ç«™ç»´æŠ¤æ—¶é—´ã€‚]]></content>
      <categories>
        <category>å…¬å‘Š</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -å¯æŒä¹…åŒ–æ•°æ®ç»“æ„]]></title>
    <url>%2F2019%2F03%2F29%2Falgorithm-persistentdatastructure%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°å¯æŒä¹…åŒ–æ•°æ®ç»“æ„å¯ä»¥å­˜å‚¨æ•°æ®é›†åœ¨ä»»æ„æ—¶é—´çš„å†å²çŠ¶æ€ã€‚â€œå¯æŒä¹…åŒ–â€çš„åŸºæœ¬æ€æƒ³æ˜¯åœ¨æ¯é¡¹æ“ä½œç»“æŸåï¼Œä»…åˆ›å»ºæ•°æ®ç»“æ„ä¸­å‘ç”Ÿæ”¹å˜çš„éƒ¨åˆ†çš„å‰¯æœ¬ï¼Œä¸æ‹·è´å…¶ä»–éƒ¨åˆ†ã€‚è¿™æ ·ä¸€æ¥ï¼Œç»´æŠ¤æ•°æ®ç»“æ„çš„æ—¶é—´å¤æ‚åº¦æ²¡æœ‰å¢åŠ ï¼Œç©ºé—´å¤æ‚åº¦ä»…å¢é•¿ä¸ºä¸æ—¶é—´åŒçº§çš„è§„æ¨¡ã€‚æ¢è¨€ä¹‹ï¼Œå¯æŒä¹…åŒ–æ•°æ®ç»“æ„èƒ½å¤Ÿé«˜æ•ˆåœ°è®°å½•ä¸€ä¸ªæ•°æ®ç»“æ„çš„æ‰€æœ‰å†å²çŠ¶æ€ã€‚ å¯æŒä¹…åŒ–Trieã€å®ç°è¿‡ç¨‹ã€‘ è®¾å½“å‰å¯æŒä¹…åŒ–Trieçš„æ ¹èŠ‚ç‚¹ä¸ºrootï¼Œä»¤p=rootï¼Œi=0 å»ºç«‹ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œä»¤rootâ€˜=q è‹¥p!=0ï¼Œåˆ™å¯¹äºæ¯ç§å­—ç¬¦cï¼Œä»¤trie[q,c]=trie[p,c] å»ºç«‹ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹qâ€™ï¼Œä»¤trie[q,s]=qâ€˜ ä»¤p=trie[p,s]ï¼Œq=trie[q,s]ï¼Œi=i+1 é‡å¤æ­¥éª¤3-5ï¼Œç›´åˆ°iåˆ°è¾¾å­—ç¬¦ä¸²æœ«å°¾ ã€ä¾‹é¢˜ã€‘æœ€å¤§å¼‚æˆ–å’Œ luogu-p4735ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°åºåˆ—{a}ï¼Œåˆå§‹é•¿åº¦ä¸ºNã€‚ æœ‰Mä¸ªæ“ä½œï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æ“ä½œç±»å‹ï¼š A xï¼šæ·»åŠ æ“ä½œï¼Œè¡¨ç¤ºåœ¨åºåˆ—æœ«å°¾æ·»åŠ ä¸€ä¸ªæ•°xï¼Œåºåˆ—çš„é•¿åº¦N+1ã€‚ Q l r xï¼šè¯¢é—®æ“ä½œï¼Œä½ éœ€è¦æ‰¾åˆ°ä¸€ä¸ªä½ç½®pï¼Œæ»¡è¶³lâ‰¤pâ‰¤rï¼Œä½¿å¾—ï¼š a[p]âŠ•a[p+1]âŠ•â€¦âŠ•a[N]âŠ•x æœ€å¤§ï¼Œè¾“å‡ºæœ€å¤§æ˜¯å¤šå°‘ã€‚ ã€åˆ†æã€‘è€ƒè™‘å¼‚æˆ–å‰ç¼€å’Œã€‚æ ¹æ®å¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼š a[p]\oplus a[p+1]\oplus ...\oplus a[N]\oplus x=s[p-1]\oplus s[N]\oplus xå¯¹äºæ·»åŠ æ“ä½œï¼Œåºåˆ—så¾ˆå®¹æ˜“ç»´æŠ¤ã€‚å¯¹äºè¯¢é—®æ“ä½œï¼Œé—®é¢˜å˜ä¸ºï¼šå·²çŸ¥ä¸€ä¸ªæ•´æ•°val=s[N] xor xï¼Œæ±‚ä¸€ä¸ªä½ç½®pï¼Œæ»¡è¶³l-1&lt;=p&lt;=r-1ï¼Œä½¿å¾—s[p] xor valæœ€å¤§ã€‚æ˜¾ç„¶å¯ä»¥å°†sæ•°ç»„æ’å…¥å¯æŒä¹…åŒ–Trieä¸­ï¼Œæ¯æ¬¡å–å‡ºåœ¨lä¸rèŒƒå›´å†…çš„æ•°æ®è¿›è¡Œè´ªå¿ƒï¼ˆå°½é‡å¾€ç›¸åçš„èŠ‚ç‚¹èµ°ï¼‰ï¼Œä»è€Œæ±‚å‡ºç­”æ¡ˆã€‚ ã€ä»£ç ã€‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC optimize(3)//QwQ#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=600005;const int DEP=24;int N,M;int trie[MAXN*26][2],sum[MAXN*26];int head[MAXN],cnt=1;int s[MAXN];inline void insert(int c,int u,int val,int d)&#123; sum[u]=sum[c]+1; if(d&lt;0) return; int x=(val&gt;&gt;d)&amp;1; trie[u][!x]=trie[c][!x]; insert(trie[c][x],trie[u][x]=++cnt,val,d-1);&#125;inline int query(int c,int u,int val,int d)&#123; if(d&lt;0) return 0; int x=(val&gt;&gt;d)&amp;1; if(sum[trie[u][!x]]&gt;sum[trie[c][!x]]) return (1&lt;&lt;d)+query(trie[c][!x],trie[u][!x],val,d-1); else return query(trie[c][x],trie[u][x],val,d-1);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); insert(0,0,0,DEP); for(register int i=1;i&lt;=N;++i)&#123; int a; scanf("%d",&amp;a); s[i]=s[i-1]^a; insert(head[i-1],head[i]=++cnt,s[i],DEP); &#125; for(register int i=1;i&lt;=M;++i)&#123; char opt; getchar(),opt=getchar(); if(opt=='A')&#123; int a; scanf("%d",&amp;a); N++; s[N]=s[N-1]^a; insert(head[N-1],head[N]=++cnt,s[N],DEP); &#125; else&#123; int l,r,a; scanf("%d%d%d",&amp;l,&amp;r,&amp;a); if(l==r) printf("%d\n",s[l-1]^s[N]^a); else printf("%d\n",query(head[l-2],head[r-1],a^s[N],DEP)); &#125; &#125; return 0;&#125; å¯æŒä¹…åŒ–æ•°ç»„ã€ä¾‹é¢˜ã€‘ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–æ•°ç»„ luogu-p3919å¦‚é¢˜ï¼Œä½ éœ€è¦ç»´æŠ¤è¿™æ ·çš„ä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•°ç»„ï¼Œæ”¯æŒå¦‚ä¸‹å‡ ç§æ“ä½œ åœ¨æŸä¸ªå†å²ç‰ˆæœ¬ä¸Šä¿®æ”¹æŸä¸€ä¸ªä½ç½®ä¸Šçš„å€¼ è®¿é—®æŸä¸ªå†å²ç‰ˆæœ¬ä¸Šçš„æŸä¸€ä½ç½®çš„å€¼ æ­¤å¤–ï¼Œæ¯è¿›è¡Œä¸€æ¬¡æ“ä½œï¼ˆå¯¹äºæ“ä½œ2ï¼Œå³ä¸ºç”Ÿæˆä¸€ä¸ªå®Œå…¨ä¸€æ ·çš„ç‰ˆæœ¬ï¼Œä¸ä½œä»»ä½•æ”¹åŠ¨ï¼‰ï¼Œå°±ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰ˆæœ¬ã€‚ç‰ˆæœ¬ç¼–å·å³ä¸ºå½“å‰æ“ä½œçš„ç¼–å·ï¼ˆä»1å¼€å§‹ç¼–å·ï¼Œç‰ˆæœ¬0è¡¨ç¤ºåˆå§‹çŠ¶æ€æ•°ç»„ï¼‰ ã€åˆ†æã€‘åœ¨åŸæ•°ç»„ä¸Šå»ºç«‹çº¿æ®µæ ‘ï¼Œåœ¨å¶å­èŠ‚ç‚¹ä¸Šè®°å½•åŸæ•°ç»„æ•°å€¼ã€‚æ‰§è¡Œå®Œä¿®æ”¹æ“ä½œåï¼Œæ ¹æ®å¯æŒä¹…åŒ–çš„æ€æƒ³ï¼Œåªéœ€æ›´æ”¹ä¸€æ¡é“¾ä¸Šçš„èŠ‚ç‚¹ä¿¡æ¯ï¼›æ‰§è¡Œå®Œè®¿é—®æ“ä½œåï¼Œåˆ™å¯ä»¥å°†ç›®å‰æ“ä½œçš„æ ¹èŠ‚ç‚¹æŒ‡é’ˆæŒ‡å‘è¢«æŸ¥è¯¢çš„å†å²çŠ¶æ€æ ¹èŠ‚ç‚¹ã€‚ ã€ä»£ç ã€‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;struct Node&#123; int l,r,val;&#125;node[MAXN*22+5];int N,M,cnt;int a[MAXN],head[MAXN];inline void build(Node&amp; u,int l,int r)&#123; if(l==r)&#123; u.val=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void change(Node c,Node&amp; u,int l,int r,int p,int val)&#123; if(l==r)&#123; u.val=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)&#123; change(node[c.l],node[u.l=++cnt],l,mid,p,val); u.r=c.r; &#125; else&#123; change(node[c.r],node[u.r=++cnt],mid+1,r,p,val); u.l=c.l; &#125;&#125;inline int query(Node u,int l,int r,int p)&#123; if(l==r) return u.val; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) return query(node[u.l],l,mid,p); else return query(node[u.r],mid+1,r,p);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) scanf("%d",&amp;a[i]); build(node[0],1,N); for(register int i=1;i&lt;=M;++i)&#123; int v,opt,p,val; scanf("%d%d",&amp;v,&amp;opt); if(opt==1)&#123; scanf("%d%d",&amp;p,&amp;val); change(node[head[v]],node[head[i]=++cnt],1,N,p,val); &#125; else&#123; scanf("%d",&amp;p); head[i]=head[v]; printf("%d\n",query(node[head[i]],1,N,p)); &#125; &#125; return 0;&#125; å¯æŒä¹…åŒ–å€¼åŸŸçº¿æ®µæ ‘ï¼ˆä¸»å¸­æ ‘ï¼‰ã€ä¾‹é¢˜ã€‘ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ luogu-p3834ç»™å®šNä¸ªæ•´æ•°æ„æˆçš„åºåˆ—ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬Kå°å€¼ã€‚ ã€åˆ†æã€‘å€¼åŸŸæœ‰è´Ÿæ•°å‡ºç°ï¼Œè€ƒè™‘ç¦»æ•£åŒ–ã€‚å‡è®¾ç¦»æ•£åŒ–åçš„å€¼åŸŸä¸º[1,L]ã€‚ åœ¨å€¼åŸŸä¸Šå»ºç«‹çº¿æ®µæ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸Šå­˜å‚¨è¯¥å€¼åŸŸå†…æœ‰å¤šå°‘ä¸ªæ•°æ®ã€‚å¯¹çº¿æ®µæ ‘è¿›è¡Œå¯æŒä¹…åŒ–å¤„ç†ï¼Œä¸ä¸Šä¸€é¢˜å¯æŒä¹…åŒ–æ•°ç»„å®ç°æ–¹å¼ç±»ä¼¼ã€‚ åœ¨æŸ¥è¯¢æ—¶ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ä¸Šçš„cntå€¼å°äºç­‰äºæ­£åœ¨æŸ¥è¯¢çš„Kï¼Œåˆ™é—®é¢˜è½¬åŒ–ä¸ºæ±‚å·¦åŠåŒºé—´å†…ç¬¬Kå°å€¼ï¼›å¦åˆ™ï¼Œè½¬åŒ–ä¸ºæ±‚å³åŠåŒºé—´å†…ç¬¬K-cntå°å€¼ã€‚ æŸ¥è¯¢æ—¶çš„æ“ä½œç±»ä¼¼äºåœ¨å€¼åŸŸä¸Šçš„äºŒåˆ†ï¼Œå› æ­¤å¤æ‚åº¦åœ¨logçº§åˆ«ã€‚ ã€ä»£ç ã€‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)#define rid(x) (b[x])const int MAXN=200005;struct Node&#123; int l,r,sum;&#125;node[MAXN&lt;&lt;6];int N,M,L,cnt;int a[MAXN],b[MAXN];int head[MAXN];inline void build(Node u,int l,int r)&#123; u.sum=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(node[u.l=++cnt],l,mid); build(node[u.r=++cnt],mid+1,r);&#125;inline void insert(Node c,Node&amp; u,int l,int r,int p)&#123; u.sum=c.sum+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(node[c.l],node[u.l=++cnt],1,mid,p),u.r=c.r; else insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l;&#125;inline int query(Node c,Node u,int l,int r,int k)&#123; if(l==r) return l; int sum=node[u.l].sum-node[c.l].sum,mid=(l+r)&gt;&gt;1; if(sum&gt;=k) return query(node[c.l],node[u.l],1,mid,k); else return query(node[c.r],node[u.r],mid+1,r,k-sum);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i)&#123; scanf("%d",&amp;a[i]); b[i]=a[i]; &#125; sort(b+1,b+N+1); L=unique(b+1,b+N+1)-(b+1); head[0]=0; build(node[0],1,L); for(register int i=1;i&lt;=N;++i) insert(node[head[i-1]],node[head[i]=++cnt],1,L,id(i)); for(register int i=1;i&lt;=M;++i)&#123; int l,r,k; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",rid(query(node[head[l-1]],node[head[r]],1,L,k))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å¯æŒä¹…åŒ–trie</tag>
        <tag>ä¸»å¸­æ ‘</tag>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p4516æ½œå…¥è¡ŒåŠ¨]]></title>
    <url>%2F2019%2F03%2F28%2Fsolution-luogu-p4516%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯ä¸€ä¸ªå¹¶ä¸ç®€å•çš„èƒŒåŒ…ç±»æ ‘å½¢dpâ€¦â€¦ å¾ˆè‡ªç„¶åœ°æƒ³åˆ°çŠ¶æ€å®šä¹‰ï¼š$f[u][k][0/1][0/1]$è¡¨ç¤ºä»¥$u$ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæ€»å…±é€‰æ‹©$k$ä¸ªç»“ç‚¹ï¼Œå…¶ä¸­é™¤äº†$u$ä»¥å¤–çš„æ‰€æœ‰ç»“ç‚¹å‡è¢«ç›‘å¬åˆ°ï¼Œ$u$ç»“ç‚¹é€‰æˆ–ä¸é€‰ï¼Œ$u$ç»“ç‚¹æ˜¯å¦è¢«è¦†ç›–çš„æƒ…å†µä¸‹ï¼Œä¸€å…±æœ‰å¤šå°‘ç§æ–¹æ¡ˆã€‚ çŠ¶æ€è½¬ç§»çœ‹ä¼¼ååˆ†éº»çƒ¦ã€‚æ¯ä¸ªç»“ç‚¹$u$éƒ½æœ‰è®¸å¤šå­ç»“ç‚¹ï¼Œå¾ˆéš¾ç»Ÿè®¡å‡ºæ¯ä¸ªå­ç»“ç‚¹çš„æ‰€æœ‰æƒ…å†µï¼ˆä¼¼ä¹åœ¨ç»„åˆæ•°å­¦çš„èŒƒç•´ï¼‰ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨ååˆ†å·§å¦™çš„æ ‘å½¢èƒŒåŒ…æ¥è¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚æ ‘ä¸ŠèƒŒåŒ…çš„è½¬ç§»å¥—è·¯æ˜¯ï¼š f[u][i+j]=combine(f[u][i],f[v][j])ç›¸å½“äºæ¯é€’å½’è®¿é—®å®Œä¸€ä¸ªå­ç»“ç‚¹ï¼Œå°±æŠŠå­èŠ‚ç‚¹ä¸Šçš„çŠ¶æ€ä¸å½“å‰å·²ç»å¤„ç†çš„çŠ¶æ€ä¸€ä¸€é…å¯¹ï¼Œä¿è¯ä¸é‡ä¸æ¼ä¸”å…¼é¡¾æ•ˆç‡ã€‚å…·ä½“çš„è½¬ç§»æ–¹ç¨‹ä¸ºï¼š f[u][i+j][0][0]=\sum f[u][i][0][0]*f[v][j][0][1] f[u][i+j][1][0]=\sum f[u][i][1][0]*(f[v][j][0][0]+f[v][j][0][1]) f[u][i+j][0][1]=\sum (f[u][i][0][1]\*(f[v][j][0][1]+f[v][j][1][1])+f[u][i][0][0]\*f[v][j][1][1] f[u][i+j][1][1]=\sum (f[u][i][1][0]\*(f[v][j][1][0]+f[v][j][1][1])+f[u][i][1][1]\*(f[v][j][0][0]+f[v][j][0][1]+f[v][j][1][0]+f[v][j][1][1]))å…·ä½“å®ç°æ—¶è¿˜åº”æ³¨æ„ï¼šå› ä¸ºé˜¶æ®µï¼ˆå³æ‰«æå­ç»“ç‚¹ä¸ªæ•°ï¼‰çš„åˆ’åˆ†ï¼Œåœ¨æ¯æ¬¡è½¬ç§»å‰éƒ½è¦å…ˆè®°å½•åŸå§‹çš„$u$ç»“ç‚¹ä¸Šçš„æ•°æ®ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ··ä¹±ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100005;const int mod=1000000007;int N,K;int f[MAXN][105][2][2];int g[105][2][2];int size[MAXN];vector&lt;int&gt; G[MAXN];inline int Mod(ll x,ll y)&#123; x%=mod,y%=mod; return (int)(x+y)%mod;&#125;void dp(int u,int fa)&#123; size[u]=1; f[u][0][0][0]=f[u][1][1][0]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(v,u); for(register int i=0;i&lt;=min(size[u],K);++i)&#123; g[i][0][0]=f[u][i][0][0],f[u][i][0][0]=0; g[i][0][1]=f[u][i][0][1],f[u][i][0][1]=0; g[i][1][0]=f[u][i][1][0],f[u][i][1][0]=0; g[i][1][1]=f[u][i][1][1],f[u][i][1][1]=0; &#125; for(register int i=0;i&lt;=min(size[u],K);++i)&#123; for(register int j=0;j&lt;=min(size[v],K-i);++j)&#123; f[u][i+j][0][0]=Mod((ll)f[u][i+j][0][0],(ll)g[i][0][0]*(ll)f[v][j][0][1]); f[u][i+j][0][1]=Mod((ll)f[u][i+j][0][1],(ll)g[i][0][0]*(ll)f[v][j][1][1]+(ll)g[i][0][1]*((ll)f[v][j][1][1]+(ll)f[v][j][0][1])); f[u][i+j][1][0]=Mod((ll)f[u][i+j][1][0],(ll)g[i][1][0]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1])); f[u][i+j][1][1]=Mod((ll)f[u][i+j][1][1],(ll)g[i][1][0]*((ll)f[v][j][1][0]+(ll)f[v][j][1][1])+(ll)g[i][1][1]*((ll)f[v][j][0][0]+(ll)f[v][j][0][1]+(ll)f[v][j][1][0]+(ll)f[v][j][1][1])); &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(1,0); printf("%d",(int)(f[1][K][0][1]+f[1][K][1][1])%mod); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>èƒŒåŒ…</tag>
        <tag>æ ‘å½¢dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•å­¦ä¹ -èƒŒåŒ…ç±»æ ‘å½¢dp]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-knapsacktreedp%2F</url>
    <content type="text"><![CDATA[æ ‘å½¢åˆ†ç»„èƒŒåŒ…ã€ä¾‹é¢˜ã€‘ é€‰è¯¾ luogu-p2014 åœ¨å¤§å­¦é‡Œæ¯ä¸ªå­¦ç”Ÿï¼Œä¸ºäº†è¾¾åˆ°ä¸€å®šçš„å­¦åˆ†ï¼Œå¿…é¡»ä»å¾ˆå¤šè¯¾ç¨‹é‡Œé€‰æ‹©ä¸€äº›è¯¾ç¨‹æ¥å­¦ä¹ ï¼Œåœ¨è¯¾ç¨‹é‡Œæœ‰äº›è¯¾ç¨‹å¿…é¡»åœ¨æŸäº›è¯¾ç¨‹ä¹‹å‰å­¦ä¹ ï¼Œå¦‚é«˜ç­‰æ•°å­¦æ€»æ˜¯åœ¨å…¶å®ƒè¯¾ç¨‹ä¹‹å‰å­¦ä¹ ã€‚ç°åœ¨æœ‰Né—¨åŠŸè¯¾ï¼Œæ¯é—¨è¯¾æœ‰ä¸ªå­¦åˆ†ï¼Œæ¯é—¨è¯¾æœ‰ä¸€é—¨æˆ–æ²¡æœ‰ç›´æ¥å…ˆä¿®è¯¾ï¼ˆè‹¥è¯¾ç¨‹aæ˜¯è¯¾ç¨‹bçš„å…ˆä¿®è¯¾å³åªæœ‰å­¦å®Œäº†è¯¾ç¨‹aï¼Œæ‰èƒ½å­¦ä¹ è¯¾ç¨‹bï¼‰ã€‚ä¸€ä¸ªå­¦ç”Ÿè¦ä»è¿™äº›è¯¾ç¨‹é‡Œé€‰æ‹©Mé—¨è¯¾ç¨‹å­¦ä¹ ï¼Œé—®ä»–èƒ½è·å¾—çš„æœ€å¤§å­¦åˆ†æ˜¯å¤šå°‘ï¼Ÿ ã€åˆ†æã€‘è®°å½•çŠ¶æ€ï¼š$f[u][i]$ä¸ºä»¥$u$ä¸ºæ ¹çš„å­æ ‘ä¸Šï¼Œé€‰æ‹©$i$é—¨è¯¾æ‰€èƒ½è·å¾—çš„æœ€å¤§å­¦åˆ†ã€‚ è®°$u$ä¸ºå½“å‰æ­£åœ¨å¤„ç†çš„ç»“ç‚¹ï¼Œ$v$ä¸ºåˆšåˆšé€’å½’è®¿é—®ç»“æŸçš„ç»“ç‚¹ã€‚é‚£ä¹ˆåœ¨$u$ä¸Šç›¸å½“äºæœ‰ä¸€ä¸ªå®¹é‡ä¸º$M$çš„èƒŒåŒ…ï¼Œæ¯ä¸ªå­æ ‘ä¸­ä¸åŒçš„çŠ¶æ€ç›¸å½“äºä¸åŒçš„ç‰©å“ï¼Œä¾‹å¦‚$f[v][j]$ä¸ºä½“ç§¯ä¸º$j$ï¼Œä»·å€¼ä¸º$f[v][j]$ä¸­å­˜å‚¨çš„æ•°å€¼ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼Œç”±äºæ‰€æœ‰å…³ç³»æ„æˆæ£®æ—ç»“æ„ï¼Œå› æ­¤å¯ä»¥è®¾$0$å·ç»“ç‚¹ä¸ºâ€œæ²¡æœ‰å…ˆä¿®è¯¾â€çš„è¯¾çš„å…ˆä¿®è¯¾ã€‚ç„¶åä»¥$0$ä¸ºæ ¹ï¼Œè¿›è¡ŒçŠ¶æ€è½¬ç§»å³å¯ã€‚ ã€ä»£ç ã€‘1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define Pb push_backconst int MAXN=305;const int MAXM=305;int N,M;vector&lt;int&gt; son[MAXN];int a[MAXN],f[MAXN][MAXM];inline void dp(int u)&#123; for(vector&lt;int&gt;::iterator it=son[u].begin();it!=son[u].end();it++) &#123; int v=*it; dp(v); for(register int i=M;i&gt;=0;--i) for(register int j=0;j&lt;=i;++j) f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]); &#125; if(u) &#123; for(register int i=M;i&gt;=1;--i) f[u][i]=f[u][i-1]+a[u]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N;++i) &#123; int k,s; scanf("%d%d",&amp;k,&amp;s); son[k].Pb(i);a[i]=s; &#125; dp(0); printf("%d",f[0][M]); return 0;&#125; ã€ä¾‹é¢˜ã€‘æœ‰çº¿ç”µè§†ç½‘ luogu-p1273æŸæ”¶è´¹æœ‰çº¿ç”µè§†ç½‘è®¡åˆ’è½¬æ’­ä¸€åœºé‡è¦çš„è¶³çƒæ¯”èµ›ã€‚ä»–ä»¬çš„è½¬æ’­ç½‘å’Œç”¨æˆ·ç»ˆç«¯æ„æˆä¸€æ£µæ ‘çŠ¶ç»“æ„ï¼Œè¿™æ£µæ ‘çš„æ ¹ç»“ç‚¹ä½äºè¶³çƒæ¯”èµ›çš„ç°åœºï¼Œæ ‘å¶ä¸ºå„ä¸ªç”¨æˆ·ç»ˆç«¯ï¼Œå…¶ä»–ä¸­è½¬ç«™ä¸ºè¯¥æ ‘çš„å†…éƒ¨èŠ‚ç‚¹ã€‚ ä»è½¬æ’­ç«™åˆ°è½¬æ’­ç«™ä»¥åŠä»è½¬æ’­ç«™åˆ°æ‰€æœ‰ç”¨æˆ·ç»ˆç«¯çš„ä¿¡å·ä¼ è¾“è´¹ç”¨éƒ½æ˜¯å·²çŸ¥çš„ï¼Œä¸€åœºè½¬æ’­çš„æ€»è´¹ç”¨ç­‰äºä¼ è¾“ä¿¡å·çš„è´¹ç”¨æ€»å’Œã€‚ ç°åœ¨æ¯ä¸ªç”¨æˆ·éƒ½å‡†å¤‡äº†ä¸€ç¬”è´¹ç”¨æƒ³è§‚çœ‹è¿™åœºç²¾å½©çš„è¶³çƒæ¯”èµ›ï¼Œæœ‰çº¿ç”µè§†ç½‘æœ‰æƒå†³å®šç»™å“ªäº›ç”¨æˆ·æä¾›ä¿¡å·è€Œä¸ç»™å“ªäº›ç”¨æˆ·æä¾›ä¿¡å·ã€‚ å†™ä¸€ä¸ªç¨‹åºæ‰¾å‡ºä¸€ä¸ªæ–¹æ¡ˆä½¿å¾—æœ‰çº¿ç”µè§†ç½‘åœ¨ä¸äºæœ¬çš„æƒ…å†µä¸‹ä½¿è§‚çœ‹è½¬æ’­çš„ç”¨æˆ·å°½å¯èƒ½å¤šã€‚ ã€åˆ†æã€‘è®°å½•çŠ¶æ€ï¼š$f[i][j]$ä¸ºä»¥$i$ä¸ºæ ¹ï¼Œé€‰æ‹©$j$ä¸ªç”¨æˆ·æœ€å¤šæœ‰å¤šå°‘æ”¶å…¥ã€‚çŠ¶æ€è½¬ç§»æ—¶å¦‚æœæ— æ³•ä»æ­£é¢å…¥æ‰‹ï¼ˆå¦‚æœ¬é¢˜ä¸çŸ¥é“ä»·æ ¼çš„æœ€å€¼ï¼Œä¸”ä»·å€¼åˆ†å¸ƒæ›´ä¸ºç¨€ç–ï¼‰ï¼Œå¯ä»¥ä»åé¢è®¾è®¡çŠ¶æ€ï¼Œåœ¨è¾“å‡ºç­”æ¡ˆæ—¶è¿›è¡Œåˆ¤æ–­å³å¯ã€‚è½¬ç§»æ—¶å¯ä»¥è®°å½•$size$æ•°ç»„è¿›è¡Œä¼˜åŒ–ã€‚ ã€ä»£ç ã€‘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int v,w,nxt;&#125;mem[3005*2];int head[3005],cnt;int size[3005];inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].v=v; mem[cnt].w=w; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int N,M;int leaf[3005];int f[3005][3005];inline void dfs(int u)&#123; if(leaf[u])&#123; f[u][1]=leaf[u]; size[u]=1; return; &#125; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; dfs(v); size[u]+=size[v]; for(register int j=M;j&gt;=1;--j) for(register int k=0;k&lt;=min(size[v],j);++k) f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125;&#125;int main()&#123; memset(f,0xcf,sizeof(f)); scanf("%d%d",&amp;N,&amp;M); for(register int i=1;i&lt;=N-M;++i)&#123; int k; scanf("%d",&amp;k); for(register int j=1;j&lt;=k;++j)&#123; int a,c; scanf("%d%d",&amp;a,&amp;c); AddEdge(i,a,c); &#125; &#125; for(register int i=1;i&lt;=M;++i) scanf("%d",&amp;leaf[N-M+i]); for(register int i=1;i&lt;=N;++i) f[i][0]=0; dfs(1); for(register int i=M;i&gt;=1;--i)&#123; if(f[1][i]&gt;=0)&#123; printf("%d",i); return 0; &#125; &#125; return 0;&#125; ç»„åˆè®¡æ•°ç±»æ ‘å½¢èƒŒåŒ…ã€ä¾‹é¢˜ã€‘æ ‘çš„ç‹¬ç«‹é›† ï¼ˆåŸåˆ›ï¼‰ç»™å®šä¸€æ£µæœ‰$N$ä¸ªç»“ç‚¹çš„æ ‘ï¼Œè¾“å‡ºè¿™æ£µæ ‘ä¸­åŒ…å«$K$ä¸ªç»“ç‚¹çš„ç‹¬ç«‹é›†ä¸ªæ•°ã€‚ ã€åˆ†æã€‘æœ‰å…³ç»„åˆè®¡æ•°çš„èƒŒåŒ…ç±»æ ‘å½¢dpé—®é¢˜ï¼Œä¸€èˆ¬å‡å¯ç”¨ä»¥ä¸‹æ–¹å¼è§£å†³ã€‚ è®°å½•çŠ¶æ€ï¼š$f[u][k][0/1]$ ä¸ºä»¥$u$ä¸ºæ ¹çš„å­æ ‘ï¼Œ$u$çš„çŠ¶æ€ä¸ºé€‰æˆ–ä¸é€‰ï¼Œå…±é€‰æ‹©$k$ä¸ªç»“ç‚¹æ—¶ç‹¬ç«‹é›†çš„ä¸ªæ•°ã€‚ è®°$u$ä¸ºå½“å‰æ­£åœ¨å¤„ç†çš„ç»“ç‚¹ï¼Œ$v$ä¸ºåˆšåˆšé€’å½’è®¿é—®ç»“æŸçš„ç»“ç‚¹ã€‚æ¯é€’å½’è®¿é—®ç»“æŸä¸€ä¸ªå­ç»“ç‚¹ï¼Œå°±è€ƒè™‘æŠŠè¯¥å­ç»“ç‚¹çš„çŠ¶æ€ä¸å·²ç»å¤„ç†ä¸€éƒ¨åˆ†çš„å½“å‰ç»“ç‚¹çŠ¶æ€ç›¸åŒ¹é…ã€‚æ¯è®¿é—®å®Œä¸€ä¸ªç»“ç‚¹ï¼Œå°±æŠŠé…å¯¹åäº§ç”Ÿçš„çŠ¶æ€å½’ä¸ºå·²å¤„ç†çš„çŠ¶æ€ã€‚ç”±äºéœ€è¦æ ¹æ®ä¹‹å‰çš„çŠ¶æ€æ¨å¯¼åç»­çŠ¶æ€ï¼Œå› æ­¤ä¸éš¾çœ‹å‡ºåˆ©ç”¨åˆ°èƒŒåŒ…çš„æ€æƒ³ã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„åŸºæœ¬æ€æƒ³å¦‚ä¸‹ï¼š f[u][i+j][(state)]=combine(f[u][i][(state)]*f[u][j][(state)])æœ¬é¢˜çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¹Ÿä¸éš¾æ¨å‡ºï¼š f[u][0][i+j]=\sum f[u][0][i]*(f[v][0][j]+f[v][1][j]) f[u][1][i+j]=\sum f[u][1][i]*f[v][0][j]ã€ä»£ç ã€‘123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=10005;int N,K;vector&lt;int&gt; G[MAXN];int f[MAXN][105][2];int g[105][2];int size[MAXN];void dp(int fa,int u)&#123; size[u]=1; f[u][0][0]=1,f[u][1][1]=1; for(vector&lt;int&gt;::iterator it=G[u].begin();it!=G[u].end();it++)&#123; int v=*it; if(v==fa) continue; dp(u,v); for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; g[i][0]=f[u][i][0],f[u][i][0]=0; g[i][1]=f[u][i][1],f[u][i][1]=0; &#125; for(register int i=0;i&lt;=min(K,size[u]);++i)&#123; for(register int j=0;j&lt;=min(K-i,size[v]);++j)&#123; f[u][i+j][0]+=g[i][0]*(f[v][j][0]+f[v][j][1]); f[u][i+j][1]+=g[i][1]*f[v][j][0]; &#125; &#125; size[u]+=size[v]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(register int i=1;i&lt;N;++i)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dp(0,1); printf("%d",f[1][K][0]+f[1][K][1]); return 0;&#125; ä¹ é¢˜æ½œå…¥è¡ŒåŠ¨ æœªå®Œå¾…ç»­~]]></content>
      <categories>
        <category>ç®—æ³•å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>èƒŒåŒ…</tag>
        <tag>æ ‘å½¢dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p2774æ–¹æ ¼å–æ•°é—®é¢˜]]></title>
    <url>%2F2019%2F03%2F24%2Fsolution-luogu-p2774%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ä¸éš¾å‘ç°ï¼Œæ¯ä¸ªæ–¹æ ¼ä¼šä¸å…¶ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹æ ¼äº§ç”ŸçŸ›ç›¾ã€‚ç¼–ç¨‹çš„ä»»åŠ¡å³æ‰¾åˆ°ä¸€ç§ä¸äº§ç”ŸçŸ›ç›¾çš„é€‰æ‹©æ–¹æ¡ˆï¼Œå¹¶ä¸”ä½¿å¾—å–å‡ºçš„æ•°æ€»å’Œæœ€å¤§ã€‚ é¦–å…ˆå¯¹å›¾è¿›è¡Œé»‘ç™½æŸ“è‰²ï¼Œç›®çš„æ˜¯ä½¿äº§ç”ŸçŸ›ç›¾çš„ä¸¤ä¸ªä½ç½®åˆ†åˆ«ä½äºä¸åŒçš„è‰²å—ä¸­ï¼Œæ–¹ä¾¿å»ºå›¾ã€‚ æºç‚¹ä¸æ‰€æœ‰ç™½è‰²ä½ç½®ç›¸è¿ï¼Œæƒå€¼ä¸ºè¯¥ä½ç½®ä¸Šçš„æ•°å­—ï¼›æ‰€æœ‰é»‘è‰²ä½ç½®ä¸æ±‡ç‚¹ç›¸è¿ï¼Œæƒå€¼ä¹Ÿä¸ºè¯¥ä½ç½®ä¸Šçš„æ•°å­—ï¼›æ‰€æœ‰ç™½è‰²ä½ç½®ä¸å…¶ä¸Šä¸‹å·¦å³ï¼ˆæ³¨æ„è¾¹ç•Œæƒ…å†µï¼‰çš„é»‘è‰²ä½ç½®ç›¸è¿ï¼Œæƒå€¼ä¸ºæ— ç©·å¤§ã€‚ å¦‚æ­¤å»ºå›¾åï¼Œå¯ä»¥å‘ç°å­˜åœ¨æºç‚¹åˆ°æ±‡ç‚¹çš„å¢å¹¿è·¯ï¼Œè¿™ä¹Ÿæ„å‘³ç€åŸå›¾ä¸­å­˜åœ¨äº§ç”ŸçŸ›ç›¾çš„ä¸¤ä¸ªä½ç½®ã€‚å‡è®¾ä¸€å¼€å§‹é€‰å–M*Nç½‘æ ¼ä¸­çš„æ‰€æœ‰æ–¹å—ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ˜¯å‰²æ‰ç½‘ç»œä¸­çš„ä¸€äº›è¾¹ï¼ˆå³åˆ å»ä¸€äº›æ–¹å—ï¼‰ï¼Œä½¿å¾—å‰²å»çš„è¾¹æƒæœ€å°ã€‚å‰²å»ç½‘ç»œä¸­çš„è¾¹å°±ç›¸å½“äºåˆ æ‰ä¸¤ä¸ªçŸ›ç›¾ä½ç½®ä¸­çš„å…¶ä¸­ä¸€ä¸ªï¼Œå› æ­¤å½“ç½‘ç»œä¸­ä¸å†æœ‰æºç‚¹åˆ°æ±‡ç‚¹çš„å¢å¹¿è·¯ï¼Œå°±æ„å‘³ç€çŸ›ç›¾å…¨éƒ¨æ¶ˆé™¤ã€‚ é—®é¢˜ä¾¿è½¬åŒ–ä¸ºæ±‚è§£æœ€å°å‰²ï¼ˆæœ€å¤§æµï¼‰çš„é—®é¢˜ã€‚è¾“å‡ºç­”æ¡ˆä¸ºå…¨å±€å’Œå‡å»æœ€å°å‰²ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAXN=100005;int N,M,S,T;ll sum;int nx[]=&#123;0,1,0,-1&#125;;int ny[]=&#123;1,0,-1,0&#125;;struct Edge&#123; int v,w,nxt;&#125;mem[MAXN];int head[MAXN],cnt=1;inline void AddEdge(int u,int v,int w)&#123; mem[++cnt].w=w; mem[cnt].v=v; mem[cnt].nxt=head[u]; head[u]=cnt;&#125;int d[MAXN];bool vis[MAXN];inline bool bfs()&#123; memset(vis,0,sizeof(vis)); vis[S]=1;d[S]=0; queue&lt;int&gt; q; q.push(S); while(q.size())&#123; int u=q.front();q.pop(); for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(vis[v]||(w==0)) continue; vis[v]=1;d[v]=d[u]+1; q.push(v); &#125; &#125; return vis[T];&#125;inline int dfs(int u,int flow)&#123; if(u==T) return flow; int rflow; for(register int i=head[u];i;i=mem[i].nxt)&#123; int v=mem[i].v,w=mem[i].w; if(w==0||d[u]+1!=d[v]) continue; if(rflow=dfs(v,min(flow,w)))&#123; mem[i].w-=rflow; mem[i^1].w+=rflow; return rflow; &#125; &#125; return 0;&#125;inline int Dinic()&#123; int maxflow=0,lowflow; while(bfs())&#123; while(lowflow=dfs(S,INF)) maxflow+=lowflow; &#125; return maxflow;&#125;int main()&#123; scanf("%d%d",&amp;M,&amp;N); S=0,T=M*N+1; for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125; printf("%lld",sum-Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç½‘ç»œæµ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜ç›®åˆ—è¡¨-ç½‘ç»œæµ]]></title>
    <url>%2F2019%2F03%2F24%2Flist-networkflow%2F</url>
    <content type="text"><![CDATA[æ–¹æ ¼å–æ•°é—®é¢˜ï¼ˆäºŒåˆ†å›¾+å»ºæ¨¡æŠ€å·§ï¼‰å°†åŸå›¾é»‘ç™½æŸ“è‰²ï¼Œå¹¶ä¿è¯äº§ç”ŸçŸ›ç›¾çš„ä¸¤ä¸ªä½ç½®é¢œè‰²ä¸åŒã€‚æºç‚¹è¿æ¥é»‘ç‚¹ï¼Œç™½ç‚¹è¿æ¥æ±‡ç‚¹ï¼Œé»‘ç‚¹è¿æ¥ä¸ä¹‹äº§ç”ŸçŸ›ç›¾çš„ç™½ç‚¹ã€‚é€šè¿‡ æœ€å¤§å’Œ=å…¨å±€å’Œ-æœ€å°å‰²ï¼Œåœ¨å»ºç«‹çš„ç½‘ç»œä¸Šè·‘æœ€å°å‰²ï¼ˆæœ€å¤§æµï¼‰å³å¯ã€‚ 123456789101112131415161718192021for(register int i=1;i&lt;=M;++i)&#123; for(register int j=1;j&lt;=N;++j)&#123; int w; scanf("%d",&amp;w); sum+=w; if((i+j)&amp;1)&#123; AddEdge(S,(i-1)*N+j,w); AddEdge((i-1)*N+j,S,INF); for(register int k=0;k&lt;=3;++k)&#123; int tx=i+nx[k],ty=j+ny[k]; if(tx&lt;1||tx&gt;M||ty&lt;1||ty&gt;N) continue; AddEdge((i-1)*N+j,(tx-1)*N+ty,INF); AddEdge((tx-1)*N+ty,(i-1)*N+j,0); &#125; &#125; else&#123; AddEdge((i-1)*N+j,T,w); AddEdge(T,(i-1)*N+j,INF); &#125; &#125; &#125;]]></content>
      <categories>
        <category>é¢˜ç›®åˆ—è¡¨</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[å…¬å‘Š 2019-03-24]]></title>
    <url>%2F2019%2F03%2F24%2Fbulletin-2019-3-24%2F</url>
    <content type="text"><![CDATA[2019/3/24ï¼Œtth37æ­å»ºäº†è¿™ä¸ªgithubåšå®¢ã€‚ tth37å¸Œæœ›åœ¨è¿™ä¸ªåšå®¢é‡Œè®°å½•ä¸€äº›è‡ªå·±å­¦ä¹ OIçš„å¿ƒå¾—ï¼Œå¹¶å‘å¸ƒä¸€äº›é¢˜è§£ï¼Œè´´å‡ºå­¦ä¹ è§„åˆ’ã€‚ ä½†tth37å®åœ¨æ˜¯å¤ªå¼±äº†ï¼Œå› æ­¤ä»–ä¼šæ›´æ–°å¾—ååˆ†ç¼“æ…¢ã€‚ å¦å¤–ï¼Œè¿˜è¯·shiwtå·¨ä½¬å¤šå¤šæŒ‡æ•™ã€‚ ä»»ä½•ä¸€ä¸ªä¼Ÿå¤§çš„æ€æƒ³ï¼Œéƒ½æœ‰ä¸€ä¸ªå¾®ä¸è¶³é“çš„å¼€å§‹ã€‚ p.s. å¯èƒ½ä¼šå°†æ´›è°·åšå®¢ä¸Šçš„æ–‡ç« æ¬è¿è¿‡æ¥ï¼Œæ‰€ä»¥æœ‰äº›æ–‡ç« çš„å‘å¸ƒæ—¶é—´å¯èƒ½åœ¨æ­¤ä¹‹å‰ï¼Œè¯·åˆ«è§æ€ªã€‚]]></content>
      <categories>
        <category>å…¬å‘Š</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é¢˜ç›®åˆ—è¡¨-åŠ¨æ€è§„åˆ’]]></title>
    <url>%2F2019%2F03%2F20%2Flist-dp%2F</url>
    <content type="text"><![CDATA[ä»»åŠ¡å®‰æ’ï¼ˆæ–œç‡ä¼˜åŒ–+è´¹ç”¨æå‰è®¡ç®—ï¼‰ f[i]=min_{0\le j]]></content>
      <categories>
        <category>é¢˜ç›®åˆ—è¡¨</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1080å›½ç‹æ¸¸æˆ]]></title>
    <url>%2F2019%2F01%2F26%2Fsolution-luogu-p1080%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ é«˜ç²¾åº¦æ€èƒ½å°‘äº†Python3é¢˜è§£ã€‚ã€‚ã€‚ è´ªå¿ƒç­–ç•¥ä¸€æ¥¼dalaoå·²ç»è®²å¾—å¾ˆæ¸…æ¥šäº†ï¼Œä¸Šä¸€å‘è¶…çŸ­ä»£ç ï¼ˆå­¦Pythonå°±æ˜¯ä¸ºäº†æ°´é«˜ç²¾ï¼‰ 123456789101112131415N=int(input())s=input().split()S=int(s[0])T=int(s[1])a=[]for i in range(1,N+1): k=input().split() a.append((int(k[0]),int(k[1])))a.sort(key=lambda x:x[0]*x[1])ans=0for i in range(0,N): if(S//(a[i])[1]&gt;ans): ans=S//(a[i])[1] S*=(a[i])[0]print(ans)]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>è´ªå¿ƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1022è®¡ç®—å™¨çš„æ”¹è‰¯]]></title>
    <url>%2F2018%2F12%2F19%2Fsolution-luogu-p1022%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ æœ¬é¢˜æ˜¯ä¸€é“éå¸¸æ¼‚äº®çš„æ¨¡æ‹Ÿã€‚åªè¦èƒ½ç†æ¸…æ€è·¯ï¼Œä»£ç å¹¶ä¸ä¼šç‰¹åˆ«å¤æ‚ã€‚ é¦–å…ˆåˆ†æé¢˜ç›®ã€‚è§£ä¸€å…ƒä¸€æ¬¡æ–¹ç¨‹æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯ç§»é¡¹ï¼ŒæŠŠå¸¸æ•°ç§»åˆ°ç­‰å·å³ä¾§ï¼ŒæŠŠä¸€æ¬¡é¡¹ç³»æ•°ç§»åˆ°ç­‰å·å·¦ä¾§ï¼Œç”¨å¸¸æ•°é™¤ä»¥ç³»æ•°å³ä¸ºç­”æ¡ˆã€‚é‚£ä¹ˆåœ¨è¯»å…¥å­—ç¬¦ä¸²çš„è¿‡ç¨‹ä¸­ï¼Œä¾¿å¯ä»¥è¿›è¡Œæ“ä½œã€‚ å¯¹äºå­—ç¬¦ä¸²ä¸­çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼å¿«è¯»çš„æ–¹æ³•è¯»å…¥ã€‚ç„¶è€Œï¼Œè¦åˆ¤æ–­è¿™äº›æ•°æ®ä»å“ªé‡Œæ¥ï¼Œåˆ°å“ªé‡Œå»ï¼Œä¾¿æ˜¯æœ¬é¢˜çš„å…³é”®æ‰€åœ¨ã€‚ å¯¹äºæ¯ä¸ªæ•°æ®ï¼Œè¦æƒ³æ¸…æ¥šåœ°è¾¨åˆ«å®ƒçš„èº«ä»½ï¼Œæˆ‘ä»¬åªéœ€è§£å†³ä¸‰ä¸ªé—®é¢˜ï¼š 1.è¯¥æ•°æ®æ˜¯æ­£æ•°è¿˜æ˜¯è´Ÿæ•°ï¼Ÿ 3.è¯¥æ•°æ®åœ¨ç­‰å·å·¦ä¾§è¿˜æ˜¯åœ¨ç­‰å·å³ä¾§ï¼Ÿ 2.è¯¥æ•°æ®æ˜¯å¸¸æ•°è¿˜æ˜¯ç³»æ•°ï¼Ÿ ç¬¬ä¸€ä¸ªé—®é¢˜çœ‹ä¼¼ååˆ†æ— è„‘ï¼Œç”¨ä¸€ä¸ªå˜é‡f1æ¥å­˜å‚¨ç¬¦å·å³å¯ï¼ˆå°†f1èµ‹å€¼ä¸º1æˆ–-1ï¼Œåœ¨è¯»å…¥æ•°æ®ç»“æŸæ—¶å°†å¾—åˆ°çš„æ•°æ®ä¹˜ä»¥f1ï¼‰ã€‚ä½†éœ€ç‰¹åˆ«æ³¨æ„ï¼Œåœ¨ä¸€ä¸ªè¡¨è¾¾å¼çš„å¼€å¤´ï¼ˆç­‰å·å·¦ä¾§å’Œç­‰å·å³ä¾§çš„è¡¨è¾¾å¼ï¼‰ä¸ä¼šæœ‰â€˜+â€™ã€â€˜-â€™ç¬¦å·ï¼Œæ‰€ä»¥åœ¨ç¨‹åºçš„å¼€å¤´å’Œè¯»å…¥â€˜=â€™å·æ˜¯ï¼Œè¦å°†f1èµ‹å€¼ä¸º1ã€‚ ç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿéå¸¸ç®€å•ï¼Œå¯ä»¥ç”¨å˜é‡f2æ¥å­˜å‚¨ã€‚å› ä¸ºè¿™ä¸ªé—®é¢˜ä¸ç§»é¡¹è¿ç®—çš„ç¬¦å·æœ‰å…³ï¼Œå› æ­¤ä¹Ÿå¯ä»¥å°†f2èµ‹å€¼ä¸º1æˆ–-1ï¼Œå¹¶çº¦å®šåœ¨ç­‰å·å·¦ä¾§æ—¶f2ä¸º1ï¼Œåœ¨ç­‰å·å³ä¾§æ—¶f2ä¸º-1ã€‚ï¼ˆå½“ç„¶ä½ ä¹Ÿå¯ä»¥åç€çº¦å®šï¼‰ ç¬¬ä¸‰ä¸ªé—®é¢˜åŒæ ·ä¸éš¾è§£å†³ã€‚åœ¨è¯»å…¥æ•°æ®ç»“æŸåï¼ˆå³è¯»å…¥äº†ä¸€ä¸ªç¬¦å·ï¼‰ï¼Œåˆ¤æ–­è¿™ä¸ªç¬¦å·æ˜¯è¿ç®—ç¬¦è¿˜æ˜¯å­—æ¯å³å¯ã€‚å¦‚æœæ˜¯å­—æ¯ï¼Œåˆ™å°†å¾—åˆ°çš„æ•°æ®ç§»åˆ°ç­‰å·å³ä¾§ï¼Œå¦åˆ™å°†æ•°æ®ç§»åˆ°ç­‰å·å·¦ä¾§ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªæ³¨æ„ç‚¹ï¼šå¦‚æœä¸€ä¸ªæœªçŸ¥æ•°çš„ç³»æ•°ä¸º1ï¼Œæˆ‘ä»¬ä¼šå°†ç³»æ•°çœç•¥ã€‚å› æ­¤åœ¨è¯»å…¥æ•°æ®ä¸º0æ—¶ï¼Œæˆ‘ä»¬è¦å°†å…¶æ›´æ”¹ä¸º1ã€‚ ç»è¿‡åˆ†æï¼Œä½ ä¼šå‘ç°æœ¬é¢˜ä¸€ç‚¹ä¹Ÿä¸éš¾å®ç°ã€‚å…¶å…³é”®åœ¨äºå¯¹æ•°æ®çŠ¶æ€çš„å‡†ç¡®æè¿°ã€‚ç”¨æ¸…æ™°ã€ç®€æ´çš„å˜é‡æè¿°çŠ¶æ€ï¼Œæ ¹æ®ä¸åŒçš„çŠ¶æ€é‡‡å–ä¸åŒçš„æªæ–½ï¼Œè¿™ä¾¿æ˜¯ç¼–ç¨‹å­¦ä¹ çš„ä¸€å¤§åŸºæœ¬ç´ å…»ã€‚ ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int l,r;//lä»£è¡¨ç³»æ•°ï¼Œrä»£è¡¨å¸¸æ•° char x; //ç”¨xå­˜å‚¨å­—æ¯ void solve()&#123; char c; int f1=1,f2=1,tmp=0; while(~scanf("%c",&amp;c)) &#123; if(c&gt;='0'&amp;&amp;c&lt;='9')//ç±»ä¼¼å¿«è¯»çš„è¯»å…¥æ–¹å¼ &#123; tmp*=10; tmp+=c-'0'; &#125; else &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') l+=(tmp==0)?f2*f1:tmp*f2*f1,x=c;//åˆ¤æ–­ç³»æ•°æ˜¯å¦ä¸º1 else r+=tmp*(-f2)*f1; tmp=0; &#125; if(c=='+') &#123;f1=1;continue;&#125; if(c=='-') &#123;f1=-1;continue;&#125; if(c=='=') &#123;f2=-1;f1=1;continue;&#125; &#125;&#125;int main()&#123; solve(); printf("%c=%0.3f",x,(float)r/l==0?abs((float)r/l):(float)r/l); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>æ•°å­¦</tag>
        <tag>å­—ç¬¦ä¸²</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢˜è§£-luogu-p1204æŒ¤ç‰›å¥¶]]></title>
    <url>%2F2018%2F12%2F15%2Fsolution-luogu-p1204%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ ä»‹ç»ä¸€ç§æœ¬é¢˜çš„è´ªå¿ƒè§£æ³•ã€‚ æœ¬é¢˜è¦æ±‚è¯»å…¥ä¸€äº›æŒ¤ç‰›å¥¶çš„æ—¶é—´æ®µï¼Œæ±‚æœ€é•¿è‡³å°‘æœ‰ä¸€äººåœ¨æŒ¤ç‰›å¥¶çš„æ—¶é—´æ®µå’Œæœ€é•¿æ²¡æœ‰äººåœ¨æŒ¤ç‰›å¥¶çš„æ—¶é—´æ®µã€‚æŠŠè¯»å…¥çš„åŒºé—´è§†ä½œçº¿æ®µï¼Œåˆ™é¢˜æ„è½¬å˜ä¸ºæ±‚è‡³å°‘æœ‰ä¸€æ¡çº¿æ®µè¦†ç›–çš„æœ€å¤§åŒºé—´å’Œæ²¡æœ‰çº¿æ®µè¦†ç›–çš„åŒºé—´ã€‚ å‡è®¾è¯»å…¥æ•°æ®å¦‚ä¸‹ï¼š é¦–å…ˆæŒ‰ç…§4æ¡çº¿æ®µçš„èµ·ç‚¹ä½ç½®æ’åºï¼ˆå…·ä½“åŸå› åé¢è§£é‡Šï¼‰ã€‚å°†beginè®¾ç½®ä¸ºç¬¬ä¸€æ¡çº¿æ®µçš„èµ·ç‚¹ï¼Œå°†endè®¾ç½®ä¸ºç¬¬ä¸€æ¡çº¿æ®µçš„ç»ˆç‚¹ã€‚ ç„¶åä»ç¬¬äºŒæ¡çº¿æ®µå¼€å§‹åˆ¤æ–­ã€‚å¦‚æœè¯¥çº¿æ®µçš„èµ·ç‚¹å°äºendï¼Œåˆ™è¯´æ˜è¿™ä¸¤æ¡çº¿æ®µæœ‰é‡åˆéƒ¨åˆ†ï¼Œå°†endæ›´æ–°ä¸ºmax{end,è¯¥çº¿æ®µçš„ç»ˆç‚¹ä½ç½®}ã€‚å¦‚æœè¯¥çº¿æ®µçš„èµ·ç‚¹å¤§äºendï¼Œåˆ™è¯´æ˜è¯¥çº¿æ®µåŠä»¥åçš„çº¿æ®µå†ä¹Ÿä¸ä¼šä¸å‰é¢çš„çº¿æ®µäº§ç”Ÿä»»ä½•é‡åˆéƒ¨åˆ†ï¼ˆè¿™ä¹Ÿå°±æ˜¯æ’åºçš„ä½œç”¨ï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥æ›´æ–°ans1å’Œans2çš„å€¼ï¼šans1æ›´æ–°ä¸ºmax{ans1,end-begin},ans2æ›´æ–°ä¸ºmax{ans2,è¯¥çº¿æ®µçš„èµ·ç‚¹ä½ç½®-end}ã€‚å…·ä½“å‚è§å›¾ä¸­ç¬¬4æ¡çº¿æ®µï¼Œans1è¢«æ›´æ–°ä¸º1200-0ï¼Œans2è¢«æ›´æ–°ä¸º1400-1200ã€‚ ç¨‹åºå·²ç»åŸºæœ¬æˆå‹ï¼Œä½†è¦æ³¨æ„åœ¨è¾“å‡ºç­”æ¡ˆå‰æ›´æ–°ä¸€éans1çš„å€¼ï¼Œè¿™æ˜¯ä¸ºäº†é¿å…æ‰€æœ‰çº¿æ®µå‡æœ‰é‡åˆéƒ¨åˆ†è€Œæ— æ³•åˆ¤æ–­çš„æƒ…å†µã€‚å¦å¤–ï¼Œans1å’Œans2è¦åˆå§‹åŒ–ä¸º0ã€‚ ç¨‹åºå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int N; struct node&#123; int begin,end;&#125;m[5005];bool cmp(node a,node b)&#123; return a.begin&lt;b.begin;&#125;int main()&#123; scanf("%d",&amp;N); for(register int i=1;i&lt;=N;++i) scanf("%d%d",&amp;m[i].begin,&amp;m[i].end); sort(m+1,m+1+N,cmp); int begin=m[1].begin; int end=m[1].end; int ans1=0,ans2=0; for(register int i=2;i&lt;=N;++i)&#123; if(m[i].begin&lt;=end) end=max(end,m[i].end); else&#123; ans1=max(ans1,end-begin); ans2=max(ans2,m[i].begin-end); begin=m[i].begin; end=m[i].end; &#125; &#125; ans1=max(ans1,end-begin); printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>è´ªå¿ƒ</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
</search>
